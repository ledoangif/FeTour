{"version":3,"file":"server.mjs","sources":["../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/paths.mjs","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/fetch.mjs","../../../node_modules/nuxt/dist/app/nuxt.js","../../../node_modules/nuxt/dist/app/components/injections.js","../../../node_modules/nuxt/dist/app/composables/router.js","../../../node_modules/nuxt/dist/app/composables/error.js","../../../node_modules/@unhead/vue/dist/shared/vue.cf295fb1.mjs","../../../node_modules/nuxt/dist/head/runtime/plugins/unhead.js","../../../node_modules/unctx/dist/index.mjs","../../../node_modules/nuxt/dist/pages/runtime/utils.js","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/nuxt.config.mjs","../../../node_modules/nuxt/dist/app/composables/manifest.js","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/routes.mjs","../../../node_modules/nuxt/dist/app/components/utils.js","../../../node_modules/nuxt/dist/pages/runtime/router.options.js","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/router.options.mjs","../../../node_modules/nuxt/dist/pages/runtime/validate.js","../../../node_modules/nuxt/dist/app/middleware/manifest-route-rule.js","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/middleware.mjs","../../../node_modules/nuxt/dist/pages/runtime/plugins/router.js","../../../node_modules/nuxt/dist/app/composables/payload.js","../../../node_modules/nuxt/dist/app/plugins/revive-payload.server.js","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/components.plugin.mjs","../../../node_modules/nuxt/dist/app/components/client-only.js","../../../node_modules/@vueuse/core/index.mjs","../../../node_modules/usebootstrap/dist/runtime/utils/helpers.mjs","../../../node_modules/usebootstrap/dist/runtime/utils/useProps.mjs","../../../node_modules/usebootstrap/dist/runtime/composables/directive/useDirective.mjs","../../../node_modules/usebootstrap/dist/runtime/plugins/bootstrap.mjs","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/element-plus-teleports.plugin.mjs","../../../node_modules/element-plus/es/hooks/use-id/index.mjs","../../../node_modules/element-plus/es/hooks/use-z-index/index.mjs","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/element-plus-injection.plugin.mjs","../../../plugins/vue-draggable.js","../../../plugins/api.ts","../../../plugins/axious.ts","../../../node_modules/vee-validate/dist/vee-validate.esm.js","../../../node_modules/@vee-validate/rules/dist/vee-validate-rules.esm.js","../../../plugins/vee-validate.ts","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/plugins/server.mjs","../../../virtual:nuxt:C:/Users/doan1/Desktop/FeTour/.nuxt/layouts.mjs","../../../node_modules/nuxt/dist/app/components/nuxt-layout.js","../../../node_modules/nuxt/dist/app/components/route-provider.js","../../../node_modules/nuxt/dist/pages/runtime/page.js","../../../app.vue","../../../node_modules/nuxt/dist/app/components/nuxt-error-page.vue","../../../node_modules/nuxt/dist/app/components/nuxt-root.vue","../../../node_modules/nuxt/dist/app/entry.js"],"sourcesContent":["import { joinRelativeURL as joinURL } from 'ufo'\nimport { useRuntimeConfig } from '#internal/nitro'\nconst appConfig = useRuntimeConfig().app\nexport const baseURL = () => appConfig.baseURL\nexport const buildAssetsDir = () => appConfig.buildAssetsDir\nexport const buildAssetsURL = (...path) => joinURL(publicAssetsURL(), buildAssetsDir(), ...path)\nexport const publicAssetsURL = (...path) => {\n  const publicBase = appConfig.cdnURL || appConfig.baseURL\n  return path.length ? joinURL(publicBase, ...path) : publicBase\n}\nif (import.meta.client) {\n  globalThis.__buildAssetsURL = buildAssetsURL\n  globalThis.__publicAssetsURL = publicAssetsURL\n}","import { $fetch } from 'ofetch'\nimport { baseURL } from '#build/paths.mjs'\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  })\n}","import { effectScope, getCurrentInstance, hasInjectionContext, reactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nconst nuxtAppCtx = /* @__PURE__ */ getContext(\"nuxt-app\", {\n  asyncContext: !!__NUXT_ASYNC_CONTEXT__ && import.meta.server\n});\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    _scope: effectScope(),\n    provide: void 0,\n    globalName: \"nuxt\",\n    versions: {\n      get nuxt() {\n        return __NUXT_VERSION__;\n      },\n      get vue() {\n        return nuxtApp.vueApp.version;\n      }\n    },\n    payload: reactive({\n      data: {},\n      state: {},\n      once: /* @__PURE__ */ new Set(),\n      _errors: {},\n      ...import.meta.client ? window.__NUXT__ ?? {} : { serverRendered: true }\n    }),\n    static: {\n      data: {}\n    },\n    runWithContext: (fn) => nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn)),\n    isHydrating: import.meta.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: {},\n    _payloadRevivers: {},\n    ...options\n  };\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  if (import.meta.server) {\n    const contextCaller = async function(hooks, args) {\n      for (const hook of hooks) {\n        await nuxtApp.runWithContext(() => hook(...args));\n      }\n    };\n    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);\n  }\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (import.meta.server) {\n    if (nuxtApp.ssrContext) {\n      nuxtApp.ssrContext.nuxt = nuxtApp;\n      nuxtApp.ssrContext._payloadReducers = {};\n      nuxtApp.payload.path = nuxtApp.ssrContext.url;\n    }\n    nuxtApp.ssrContext = nuxtApp.ssrContext || {};\n    if (nuxtApp.ssrContext.payload) {\n      Object.assign(nuxtApp.payload, nuxtApp.ssrContext.payload);\n    }\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.ssrContext.config = {\n      public: options.ssrContext.runtimeConfig.public,\n      app: options.ssrContext.runtimeConfig.app\n    };\n  }\n  if (import.meta.client) {\n    window.addEventListener(\"nuxt.preloadError\", (event) => {\n      nuxtApp.callHook(\"app:chunkError\", { error: event.payload });\n    });\n    window.useNuxtApp = window.useNuxtApp || useNuxtApp;\n    const unreg = nuxtApp.hook(\"app:error\", (...args) => {\n      console.error(\"[nuxt] error caught during app initialization\", ...args);\n    });\n    nuxtApp.hook(\"app:mounted\", unreg);\n  }\n  const runtimeConfig = import.meta.server ? options.ssrContext.runtimeConfig : reactive(nuxtApp.payload.config);\n  nuxtApp.provide(\"config\", runtimeConfig);\n  return nuxtApp;\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (plugin.hooks) {\n    nuxtApp.hooks.addHooks(plugin.hooks);\n  }\n  if (typeof plugin === \"function\") {\n    const { provide } = await nuxtApp.runWithContext(() => plugin(nuxtApp)) || {};\n    if (provide && typeof provide === \"object\") {\n      for (const key in provide) {\n        nuxtApp.provide(key, provide[key]);\n      }\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  const resolvedPlugins = [];\n  const unresolvedPlugins = [];\n  const parallels = [];\n  const errors = [];\n  let promiseDepth = 0;\n  async function executePlugin(plugin) {\n    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.includes(name)) ?? [];\n    if (unresolvedPluginsForThisPlugin.length > 0) {\n      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);\n    } else {\n      const promise = applyPlugin(nuxtApp, plugin).then(async () => {\n        if (plugin._name) {\n          resolvedPlugins.push(plugin._name);\n          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {\n            if (dependsOn.has(plugin._name)) {\n              dependsOn.delete(plugin._name);\n              if (dependsOn.size === 0) {\n                promiseDepth++;\n                await executePlugin(unexecutedPlugin);\n              }\n            }\n          }));\n        }\n      });\n      if (plugin.parallel) {\n        parallels.push(promise.catch((e) => errors.push(e)));\n      } else {\n        await promise;\n      }\n    }\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    await executePlugin(plugin);\n  }\n  await Promise.all(parallels);\n  if (promiseDepth) {\n    for (let i = 0; i < promiseDepth; i++) {\n      await Promise.all(parallels);\n    }\n  }\n  if (errors.length) {\n    throw errors[0];\n  }\n}\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtPlugin(plugin) {\n  if (typeof plugin === \"function\") {\n    return plugin;\n  }\n  const _name = plugin._name || plugin.name;\n  delete plugin.name;\n  return Object.assign(plugin.setup || (() => {\n  }), plugin, { [NuxtPluginIndicator]: true, _name });\n}\nexport const definePayloadPlugin = defineNuxtPlugin;\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  if (import.meta.server) {\n    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return nuxt.vueApp.runWithContext(fn);\n  }\n}\n// @__NO_SIDE_EFFECTS__\nexport function tryUseNuxtApp() {\n  let nuxtAppInstance;\n  if (hasInjectionContext()) {\n    nuxtAppInstance = getCurrentInstance()?.appContext.app.$nuxt;\n  }\n  nuxtAppInstance = nuxtAppInstance || nuxtAppCtx.tryUse();\n  return nuxtAppInstance || null;\n}\n// @__NO_SIDE_EFFECTS__\nexport function useNuxtApp() {\n  const nuxtAppInstance = /* @__PURE__ */ tryUseNuxtApp();\n  if (!nuxtAppInstance) {\n    if (import.meta.dev) {\n      throw new Error(\"[nuxt] A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function. This is probably not a Nuxt bug. Find out more at `https://nuxt.com/docs/guide/concepts/auto-imports#vue-and-nuxt-composables`.\");\n    } else {\n      throw new Error(\"[nuxt] instance unavailable\");\n    }\n  }\n  return nuxtAppInstance;\n}\n// @__NO_SIDE_EFFECTS__\nexport function useRuntimeConfig(_event) {\n  return (/* @__PURE__ */ useNuxtApp()).$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\n","export const LayoutMetaSymbol = Symbol(\"layout-meta\");\nexport const PageRouteSymbol = Symbol(\"route\");\n","import { getCurrentInstance, hasInjectionContext, inject, onScopeDispose } from \"vue\";\nimport { sanitizeStatusCode } from \"h3\";\nimport { hasProtocol, isScriptProtocol, joinURL, parseURL, withQuery } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { PageRouteSymbol } from \"../components/injections.js\";\nimport { createError, showError } from \"./error.js\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (import.meta.dev && isProcessingMiddleware()) {\n    console.warn(\"[nuxt] Calling `useRoute` within middleware may lead to misleading results. Instead, use the (to, from) arguments passed to the middleware to access the new and old routes.\");\n  }\n  if (hasInjectionContext()) {\n    return inject(PageRouteSymbol, useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onScopeDispose(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onScopeDispose(unsubscribe);\n};\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtRouteMiddleware(middleware) {\n  return middleware;\n}\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const global = options.global || typeof name !== \"string\";\n  const mw = typeof name !== \"string\" ? name : middleware;\n  if (!mw) {\n    console.warn(\"[nuxt] No route middleware passed to `addRouteMiddleware`.\", name);\n    return;\n  }\n  if (global) {\n    nuxtApp._middleware.global.push(mw);\n  } else {\n    nuxtApp._middleware.named[name] = mw;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n  return false;\n};\nexport const navigateTo = (to, options) => {\n  if (!to) {\n    to = \"/\";\n  }\n  const toPath = typeof to === \"string\" ? to : withQuery(to.path || \"/\", to.query || {}) + (to.hash || \"\");\n  if (options?.open) {\n    if (import.meta.client) {\n      const { target = \"_blank\", windowFeatures = {} } = options.open;\n      const features = Object.entries(windowFeatures).filter(([_, value]) => value !== void 0).map(([feature, value]) => `${feature.toLowerCase()}=${value}`).join(\", \");\n      open(toPath, target, features);\n    }\n    return Promise.resolve();\n  }\n  const isExternal = options?.external || hasProtocol(toPath, { acceptRelative: true });\n  if (isExternal) {\n    if (!options?.external) {\n      throw new Error(\"Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.\");\n    }\n    const protocol = parseURL(toPath).protocol;\n    if (protocol && isScriptProtocol(protocol)) {\n      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);\n    }\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (import.meta.client && !isExternal && inMiddleware) {\n    return to;\n  }\n  const router = useRouter();\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (nuxtApp.ssrContext) {\n      const fullPath = typeof to === \"string\" || isExternal ? toPath : router.resolve(to).fullPath || \"/\";\n      const location2 = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath);\n      const redirect = async function(response) {\n        await nuxtApp.callHook(\"app:redirected\");\n        const encodedLoc = location2.replace(/\"/g, \"%22\");\n        nuxtApp.ssrContext._renderResponse = {\n          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),\n          body: `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`,\n          headers: { location: location2 }\n        };\n        return response;\n      };\n      if (!isExternal && inMiddleware) {\n        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);\n        return to;\n      }\n      return redirect(!inMiddleware ? void 0 : (\n        /* abort route navigation */\n        false\n      ));\n    }\n  }\n  if (isExternal) {\n    nuxtApp._scope.stop();\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    if (inMiddleware) {\n      if (!nuxtApp.isHydrating) {\n        return false;\n      }\n      return new Promise(() => {\n      });\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (import.meta.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (!err) {\n    return false;\n  }\n  err = createError(err);\n  if (err.fatal) {\n    useNuxtApp().runWithContext(() => showError(err));\n  }\n  throw err;\n};\nexport const setPageLayout = (layout) => {\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (import.meta.dev && getCurrentInstance() && nuxtApp.payload.state._layout !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    nuxtApp.payload.state._layout = layout;\n  }\n  if (import.meta.dev && nuxtApp.isHydrating && nuxtApp.payload.serverRendered && nuxtApp.payload.state._layout !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || import.meta.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\n","import { createError as createH3Error } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRouter } from \"./router.js\";\nexport const NUXT_ERROR_SIGNATURE = \"__nuxt_error\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (error) => {\n  const nuxtError = createError(error);\n  try {\n    const nuxtApp = useNuxtApp();\n    const error2 = useError();\n    if (import.meta.client) {\n      nuxtApp.hooks.callHook(\"app:error\", nuxtError);\n    }\n    error2.value = error2.value || nuxtError;\n  } catch {\n    throw nuxtError;\n  }\n  return nuxtError;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await useRouter().replace(options.redirect);\n  }\n  error.value = null;\n};\nexport const isNuxtError = (error) => !!error && typeof error === \"object\" && NUXT_ERROR_SIGNATURE in error;\nexport const createError = (error) => {\n  const nuxtError = createH3Error(error);\n  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {\n    value: true,\n    configurable: false,\n    writable: false\n  });\n  return nuxtError;\n};\n","import { version, unref, nextTick, inject } from 'vue';\nimport { createServerHead as createServerHead$1, createHead as createHead$1, getActiveHead } from 'unhead';\nimport { defineHeadPlugin } from '@unhead/shared';\n\nconst Vue3 = version.startsWith(\"3\");\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nfunction resolveUnrefHeadInput(ref, lastKey = \"\") {\n  if (ref instanceof Promise)\n    return ref;\n  const root = resolveUnref(ref);\n  if (!ref || !root)\n    return root;\n  if (Array.isArray(root))\n    return root.map((r) => resolveUnrefHeadInput(r, lastKey));\n  if (typeof root === \"object\") {\n    return Object.fromEntries(\n      Object.entries(root).map(([k, v]) => {\n        if (k === \"titleTemplate\" || k.startsWith(\"on\"))\n          return [k, unref(v)];\n        return [k, resolveUnrefHeadInput(v, k)];\n      })\n    );\n  }\n  return root;\n}\n\nconst VueReactivityPlugin = defineHeadPlugin({\n  hooks: {\n    \"entries:resolve\": function(ctx) {\n      for (const entry of ctx.entries)\n        entry.resolvedInput = resolveUnrefHeadInput(entry.input);\n    }\n  }\n});\n\nconst headSymbol = \"usehead\";\nfunction vueInstall(head) {\n  const plugin = {\n    install(app) {\n      if (Vue3) {\n        app.config.globalProperties.$unhead = head;\n        app.config.globalProperties.$head = head;\n        app.provide(headSymbol, head);\n      }\n    }\n  };\n  return plugin.install;\n}\nfunction createServerHead(options = {}) {\n  const head = createServerHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\nfunction createHead(options = {}) {\n  options.domDelayFn = options.domDelayFn || ((fn) => nextTick(() => setTimeout(() => fn(), 0)));\n  const head = createHead$1(options);\n  head.use(VueReactivityPlugin);\n  head.install = vueInstall(head);\n  return head;\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__unhead_injection_handler__\";\nfunction setHeadInjectionHandler(handler) {\n  _global[globalKey] = handler;\n}\nfunction injectHead() {\n  if (globalKey in _global) {\n    return _global[globalKey]();\n  }\n  const head = inject(headSymbol);\n  if (!head && process.env.NODE_ENV !== \"production\")\n    console.warn(\"Unhead is missing Vue context, falling back to shared context. This may have unexpected results.\");\n  return head || getActiveHead();\n}\n\nexport { Vue3 as V, createServerHead as a, createHead as c, headSymbol as h, injectHead as i, resolveUnrefHeadInput as r, setHeadInjectionHandler as s };\n","import { createHead as createClientHead, setHeadInjectionHandler } from \"@unhead/vue\";\nimport { renderDOMHead } from \"@unhead/dom\";\nimport { defineNuxtPlugin, useNuxtApp } from \"#app/nuxt\";\nimport unheadPlugins from \"#build/unhead-plugins.mjs\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:head\",\n  enforce: \"pre\",\n  setup(nuxtApp) {\n    const head = import.meta.server ? nuxtApp.ssrContext.head : createClientHead({\n      plugins: unheadPlugins\n    });\n    setHeadInjectionHandler(\n      // need a fresh instance of the nuxt app to avoid parallel requests interfering with each other\n      () => useNuxtApp().vueApp._context.provides.usehead\n    );\n    nuxtApp.vueApp.use(head);\n    if (import.meta.client) {\n      let pauseDOMUpdates = true;\n      const syncHead = async () => {\n        pauseDOMUpdates = false;\n        await renderDOMHead(head);\n      };\n      head.hooks.hook(\"dom:beforeRender\", (context) => {\n        context.shouldRender = !pauseDOMUpdates;\n      });\n      nuxtApp.hooks.hook(\"page:start\", () => {\n        pauseDOMUpdates = true;\n      });\n      nuxtApp.hooks.hook(\"page:finish\", () => {\n        if (!nuxtApp.isHydrating) {\n          syncHead();\n        }\n      });\n      nuxtApp.hooks.hook(\"app:error\", syncHead);\n      nuxtApp.hooks.hook(\"app:suspense:resolve\", syncHead);\n    }\n  }\n});\n","function createContext(opts = {}) {\n  let currentInstance;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  let als;\n  if (opts.asyncContext) {\n    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;\n    if (_AsyncLocalStorage) {\n      als = new _AsyncLocalStorage();\n    } else {\n      console.warn(\"[unctx] `AsyncLocalStorage` is not provided.\");\n    }\n  }\n  const _getCurrentInstance = () => {\n    if (als && currentInstance === void 0) {\n      const instance = als.getStore();\n      if (instance !== void 0) {\n        return instance;\n      }\n    }\n    return currentInstance;\n  };\n  return {\n    use: () => {\n      const _instance = _getCurrentInstance();\n      if (_instance === void 0) {\n        throw new Error(\"Context is not available\");\n      }\n      return _instance;\n    },\n    tryUse: () => {\n      return _getCurrentInstance();\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = void 0;\n      isSingleton = false;\n    },\n    call: (instance, callback) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return als ? als.run(instance, callback) : callback();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n      }\n    },\n    async callAsync(instance, callback) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = als ? als.run(instance, callback) : callback();\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace(defaultOpts = {}) {\n  const contexts = {};\n  return {\n    get(key, opts = {}) {\n      if (!contexts[key]) {\n        contexts[key] = createContext({ ...defaultOpts, ...opts });\n      }\n      contexts[key];\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key, opts = {}) => defaultNamespace.get(key, opts);\nconst useContext = (key, opts = {}) => getContext(key, opts).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(function_) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = function_();\n  if (awaitable && typeof awaitable === \"object\" && \"catch\" in awaitable) {\n    awaitable = awaitable.catch((error) => {\n      restore();\n      throw error;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(function_, transformed) {\n  if (!transformed) {\n    console.warn(\n      \"[unctx] `withAsyncContext` needs transformation for async context support in\",\n      function_,\n      \"\\n\",\n      function_.toString()\n    );\n  }\n  return function_;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n","import { KeepAlive, h } from \"vue\";\nconst interpolatePath = (route, match) => {\n  return match.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (routeProps, override) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => import.meta.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n","export const appHead = {\"meta\":[{\"charset\":\"utf-8\"},{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"name\":\"description\",\"content\":\"Tour\"}],\"link\":[{\"rel\":\"icon\",\"type\":\"image/x-icon\",\"href\":\"/favicon.ico\"},{\"rel\":\"stylesheet\",\"href\":\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\"},{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i,800,800i\"},{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css?family=Raleway:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i\"},{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i,500,500i,700,700i,900,900i\"},{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css?family=Playfair+Display:400,400i,700,700i&display=swap\"},{\"rel\":\"stylesheet\",\"href\":\"https://cdnjs.cloudflare.com/ajax/libs/ionicons/4.5.6/css/ionicons.min.css\"}],\"style\":[],\"script\":[{\"src\":\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js\",\"type\":\"text/javascript\"},{\"src\":\"_nuxt/assets/vendor/jquery/jquery.min.js\",\"type\":\"text/javascript\"},{\"src\":\"https://kit.fontawesome.com/efab6387bf.js\"}],\"noscript\":[],\"title\":\"Tour\"}\n\nexport const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appViewTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"\n\nexport const appTeleportTag = \"div\"\n\nexport const appTeleportId = \"teleports\"\n\nexport const renderJsonPayloads = true\n\nexport const componentIslands = false\n\nexport const payloadExtraction = true\n\nexport const cookieStore = false\n\nexport const appManifest = true\n\nexport const remoteComponentIslands = false\n\nexport const selectiveClient = false\n\nexport const devPagesDir = null\n\nexport const devRootDir = null\n\nexport const devLogs = false\n\nexport const nuxtLinkDefaults = {\"componentName\":\"NuxtLink\"}\n\nexport const asyncDataDefaults = {\"deep\":true}\n\nexport const fetchDefaults = {}\n\nexport const vueAppRootContainer = '#__nuxt'\n\nexport const viewTransition = false","import { createMatcherFromExport, createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport { defu } from \"defu\";\nimport { useAppConfig } from \"../config.js\";\nimport { useRuntimeConfig } from \"../nuxt.js\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport { buildAssetsURL } from \"#build/paths.mjs\";\nlet manifest;\nlet matcher;\nfunction fetchManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  const buildId = useAppConfig().nuxt?.buildId;\n  manifest = $fetch(buildAssetsURL(`builds/meta/${buildId}.json`));\n  manifest.then((m) => {\n    matcher = createMatcherFromExport(m.matcher);\n  });\n  return manifest;\n}\nexport function getAppManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  return manifest || fetchManifest();\n}\nexport async function getRouteRules(url) {\n  if (import.meta.server) {\n    const _routeRulesMatcher = toRouteMatcher(\n      createRadixRouter({ routes: useRuntimeConfig().nitro.routeRules })\n    );\n    return defu({}, ..._routeRulesMatcher.matchAll(url).reverse());\n  }\n  await getAppManifest();\n  return defu({}, ...matcher.matchAll(url).reverse());\n}\n","import { default as indexzc5bUCA1PZMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/account/index.vue?macro=true\";\nimport { default as indexk0KrxXnq23Meta } from \"C:/Users/doan1/Desktop/FeTour/pages/booking/index.vue?macro=true\";\nimport { default as index66DuR8OpPIMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/contact/index.vue?macro=true\";\nimport { default as indexwJXpYU1uE2Meta } from \"C:/Users/doan1/Desktop/FeTour/pages/country/index.vue?macro=true\";\nimport { default as index4twE8aghL4Meta } from \"C:/Users/doan1/Desktop/FeTour/pages/customer/index.vue?macro=true\";\nimport { default as indexPwtMYXqADvMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/customerbooking/index.vue?macro=true\";\nimport { default as indexDKRhpt2WUqMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/customerInTour/index.vue?macro=true\";\nimport { default as DashboardMQtclcGVyYMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/Dashboard.vue?macro=true\";\nimport { default as index3doNfbYmFAMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/hotel/index.vue?macro=true\";\nimport { default as indexQFS8UuDefUMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/index.vue?macro=true\";\nimport { default as LoginnA5DhZTgawMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/Login.vue?macro=true\";\nimport { default as indexLlkwI5GDNsMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/payment/index.vue?macro=true\";\nimport { default as indexT2RRD80e9XMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/paymentResponse/index.vue?macro=true\";\nimport { default as _91id_93YPi7dvCebxMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/profile/[id].vue?macro=true\";\nimport { default as indexn3uAJjZTH5Meta } from \"C:/Users/doan1/Desktop/FeTour/pages/tour/index.vue?macro=true\";\nimport { default as indexcarUxwjvFJMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/tourcustomer/index.vue?macro=true\";\nimport { default as indexM0sA6R6T0uMeta } from \"C:/Users/doan1/Desktop/FeTour/pages/tourdetail/index.vue?macro=true\";\nexport default [\n  {\n    name: indexzc5bUCA1PZMeta?.name ?? \"account\",\n    path: indexzc5bUCA1PZMeta?.path ?? \"/account\",\n    meta: indexzc5bUCA1PZMeta || {},\n    alias: indexzc5bUCA1PZMeta?.alias || [],\n    redirect: indexzc5bUCA1PZMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/account/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexk0KrxXnq23Meta?.name ?? \"booking\",\n    path: indexk0KrxXnq23Meta?.path ?? \"/booking\",\n    meta: indexk0KrxXnq23Meta || {},\n    alias: indexk0KrxXnq23Meta?.alias || [],\n    redirect: indexk0KrxXnq23Meta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/booking/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: index66DuR8OpPIMeta?.name ?? \"contact\",\n    path: index66DuR8OpPIMeta?.path ?? \"/contact\",\n    meta: index66DuR8OpPIMeta || {},\n    alias: index66DuR8OpPIMeta?.alias || [],\n    redirect: index66DuR8OpPIMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/contact/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexwJXpYU1uE2Meta?.name ?? \"country\",\n    path: indexwJXpYU1uE2Meta?.path ?? \"/country\",\n    meta: indexwJXpYU1uE2Meta || {},\n    alias: indexwJXpYU1uE2Meta?.alias || [],\n    redirect: indexwJXpYU1uE2Meta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/country/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: index4twE8aghL4Meta?.name ?? \"customer\",\n    path: index4twE8aghL4Meta?.path ?? \"/customer\",\n    meta: index4twE8aghL4Meta || {},\n    alias: index4twE8aghL4Meta?.alias || [],\n    redirect: index4twE8aghL4Meta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/customer/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexPwtMYXqADvMeta?.name ?? \"customerbooking\",\n    path: indexPwtMYXqADvMeta?.path ?? \"/customerbooking\",\n    meta: indexPwtMYXqADvMeta || {},\n    alias: indexPwtMYXqADvMeta?.alias || [],\n    redirect: indexPwtMYXqADvMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/customerbooking/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexDKRhpt2WUqMeta?.name ?? \"customerInTour\",\n    path: indexDKRhpt2WUqMeta?.path ?? \"/customerInTour\",\n    meta: indexDKRhpt2WUqMeta || {},\n    alias: indexDKRhpt2WUqMeta?.alias || [],\n    redirect: indexDKRhpt2WUqMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/customerInTour/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: DashboardMQtclcGVyYMeta?.name ?? \"Dashboard\",\n    path: DashboardMQtclcGVyYMeta?.path ?? \"/Dashboard\",\n    meta: DashboardMQtclcGVyYMeta || {},\n    alias: DashboardMQtclcGVyYMeta?.alias || [],\n    redirect: DashboardMQtclcGVyYMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/Dashboard.vue\").then(m => m.default || m)\n  },\n  {\n    name: index3doNfbYmFAMeta?.name ?? \"hotel\",\n    path: index3doNfbYmFAMeta?.path ?? \"/hotel\",\n    meta: index3doNfbYmFAMeta || {},\n    alias: index3doNfbYmFAMeta?.alias || [],\n    redirect: index3doNfbYmFAMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/hotel/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexQFS8UuDefUMeta?.name ?? \"index\",\n    path: indexQFS8UuDefUMeta?.path ?? \"/\",\n    meta: indexQFS8UuDefUMeta || {},\n    alias: indexQFS8UuDefUMeta?.alias || [],\n    redirect: indexQFS8UuDefUMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: LoginnA5DhZTgawMeta?.name ?? \"Login\",\n    path: LoginnA5DhZTgawMeta?.path ?? \"/Login\",\n    meta: LoginnA5DhZTgawMeta || {},\n    alias: LoginnA5DhZTgawMeta?.alias || [],\n    redirect: LoginnA5DhZTgawMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/Login.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexLlkwI5GDNsMeta?.name ?? \"payment\",\n    path: indexLlkwI5GDNsMeta?.path ?? \"/payment\",\n    meta: indexLlkwI5GDNsMeta || {},\n    alias: indexLlkwI5GDNsMeta?.alias || [],\n    redirect: indexLlkwI5GDNsMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/payment/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexT2RRD80e9XMeta?.name ?? \"paymentResponse\",\n    path: indexT2RRD80e9XMeta?.path ?? \"/paymentResponse\",\n    meta: indexT2RRD80e9XMeta || {},\n    alias: indexT2RRD80e9XMeta?.alias || [],\n    redirect: indexT2RRD80e9XMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/paymentResponse/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: _91id_93YPi7dvCebxMeta?.name ?? \"profile-id\",\n    path: _91id_93YPi7dvCebxMeta?.path ?? \"/profile/:id()\",\n    meta: _91id_93YPi7dvCebxMeta || {},\n    alias: _91id_93YPi7dvCebxMeta?.alias || [],\n    redirect: _91id_93YPi7dvCebxMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/profile/[id].vue\").then(m => m.default || m)\n  },\n  {\n    name: indexn3uAJjZTH5Meta?.name ?? \"tour\",\n    path: indexn3uAJjZTH5Meta?.path ?? \"/tour\",\n    meta: indexn3uAJjZTH5Meta || {},\n    alias: indexn3uAJjZTH5Meta?.alias || [],\n    redirect: indexn3uAJjZTH5Meta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/tour/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexcarUxwjvFJMeta?.name ?? \"tourcustomer\",\n    path: indexcarUxwjvFJMeta?.path ?? \"/tourcustomer\",\n    meta: indexcarUxwjvFJMeta || {},\n    alias: indexcarUxwjvFJMeta?.alias || [],\n    redirect: indexcarUxwjvFJMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/tourcustomer/index.vue\").then(m => m.default || m)\n  },\n  {\n    name: indexM0sA6R6T0uMeta?.name ?? \"tourdetail\",\n    path: indexM0sA6R6T0uMeta?.path ?? \"/tourdetail\",\n    meta: indexM0sA6R6T0uMeta || {},\n    alias: indexM0sA6R6T0uMeta?.alias || [],\n    redirect: indexM0sA6R6T0uMeta?.redirect,\n    component: () => import(\"C:/Users/doan1/Desktop/FeTour/pages/tourdetail/index.vue\").then(m => m.default || m)\n  }\n]","import { h } from \"vue\";\nimport { isString, isPromise, isArray, isObject } from \"@vue/shared\";\nimport { START_LOCATION } from \"#build/pages\";\nexport const _wrapIf = (component, props, slots) => {\n  props = props === true ? {} : props;\n  return { default: () => props ? h(component, props, slots) : slots.default?.() };\n};\nfunction generateRouteKey(route) {\n  const source = route?.meta.key ?? route.path.replace(/(:\\w+)\\([^)]+\\)/g, \"$1\").replace(/(:\\w+)[?+*]/g, \"$1\").replace(/:\\w+/g, (r) => route.params[r.slice(1)]?.toString() || \"\");\n  return typeof source === \"function\" ? source(route) : source;\n}\nexport function isChangingPage(to, from) {\n  if (to === from || from === START_LOCATION) {\n    return false;\n  }\n  if (generateRouteKey(to) !== generateRouteKey(from)) {\n    return true;\n  }\n  const areComponentsSame = to.matched.every(\n    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default\n  );\n  if (areComponentsSame) {\n    return false;\n  }\n  return true;\n}\nexport function createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n      } else {\n        buffer.push(item);\n      }\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nexport function vforToArray(source) {\n  if (isArray(source)) {\n    return source;\n  } else if (isString(source)) {\n    return source.split(\"\");\n  } else if (typeof source === \"number\") {\n    if (import.meta.dev && !Number.isInteger(source)) {\n      console.warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    const array = [];\n    for (let i = 0; i < source; i++) {\n      array[i] = i;\n    }\n    return array;\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      return Array.from(\n        source,\n        (item) => item\n      );\n    } else {\n      const keys = Object.keys(source);\n      const array = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        array[i] = source[key];\n      }\n      return array;\n    }\n  }\n  return [];\n}\nexport function getFragmentHTML(element, withoutSlots = false) {\n  if (element) {\n    if (element.nodeName === \"#comment\" && element.nodeValue === \"[\") {\n      return getFragmentChildren(element, [], withoutSlots);\n    }\n    if (withoutSlots) {\n      const clone = element.cloneNode(true);\n      clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n        n.innerHTML = \"\";\n      });\n      return [clone.outerHTML];\n    }\n    return [element.outerHTML];\n  }\n  return null;\n}\nfunction getFragmentChildren(element, blocks = [], withoutSlots = false) {\n  if (element && element.nodeName) {\n    if (isEndFragment(element)) {\n      return blocks;\n    } else if (!isStartFragment(element)) {\n      const clone = element.cloneNode(true);\n      if (withoutSlots) {\n        clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n          n.innerHTML = \"\";\n        });\n      }\n      blocks.push(clone.outerHTML);\n    }\n    getFragmentChildren(element.nextSibling, blocks, withoutSlots);\n  }\n  return blocks;\n}\nfunction isStartFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"[\";\n}\nfunction isEndFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"]\";\n}\n","import { useNuxtApp } from \"#app/nuxt\";\nimport { isChangingPage } from \"#app/components/utils\";\nimport { useRouter } from \"#app/composables/router\";\nimport { appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    const behavior = useRouter().options?.scrollBehaviorType ?? \"auto\";\n    let position = savedPosition || void 0;\n    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === \"function\" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;\n    if (!position && from && to && routeAllowsScrollToTop !== false && isChangingPage(to, from)) {\n      position = { left: 0, top: 0 };\n    }\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior };\n      }\n      return false;\n    }\n    const hasTransition = (route) => !!(route.meta.pageTransition ?? defaultPageTransition);\n    const hookToWait = hasTransition(from) && hasTransition(to) ? \"page:transition:finish\" : \"page:finish\";\n    return new Promise((resolve) => {\n      nuxtApp.hooks.hookOnce(hookToWait, async () => {\n        await new Promise((resolve2) => setTimeout(resolve2, 0));\n        if (to.hash) {\n          position = { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior };\n        }\n        resolve(position);\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  try {\n    const elem = document.querySelector(selector);\n    if (elem) {\n      return parseFloat(getComputedStyle(elem).scrollMarginTop);\n    }\n  } catch {\n  }\n  return 0;\n}\n","import routerOptions0 from \"C:/Users/doan1/Desktop/FeTour/node_modules/nuxt/dist/pages/runtime/router.options\";\nconst configRouterOptions = {\n  hashMode: false,\n  scrollBehaviorType: \"auto\"\n}\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import { createError, showError } from \"#app/composables/error\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { defineNuxtRouteMiddleware, useRouter } from \"#app/composables/router\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const nuxtApp = useNuxtApp();\n  const router = useRouter();\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (result === true) {\n    return;\n  }\n  if (import.meta.server) {\n    return result;\n  }\n  const error = createError({\n    statusCode: 404,\n    statusMessage: `Page Not Found: ${to.fullPath}`,\n    data: {\n      path: to.fullPath\n    }\n  });\n  const unsub = router.beforeResolve((final) => {\n    unsub();\n    if (final === to) {\n      const unsub2 = router.afterEach(async () => {\n        unsub2();\n        await nuxtApp.runWithContext(() => showError(error));\n        window.history.pushState({}, \"\", to.fullPath);\n      });\n      return false;\n    }\n  });\n});\n","import { hasProtocol } from \"ufo\";\nimport { defineNuxtRouteMiddleware } from \"../composables/router.js\";\nimport { getRouteRules } from \"../composables/manifest.js\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (import.meta.server || import.meta.test) {\n    return;\n  }\n  const rules = await getRouteRules(to.path);\n  if (rules.redirect) {\n    if (hasProtocol(rules.redirect, { acceptRelative: true })) {\n      window.location.href = rules.redirect;\n      return false;\n    }\n    return rules.redirect;\n  }\n});\n","import validate from \"C:/Users/doan1/Desktop/FeTour/node_modules/nuxt/dist/pages/runtime/validate.js\";\nimport manifest_45route_45rule from \"C:/Users/doan1/Desktop/FeTour/node_modules/nuxt/dist/app/middleware/manifest-route-rule.js\";\nexport const globalMiddleware = [\n  validate,\n  manifest_45route_45rule\n]\nexport const namedMiddleware = {\n  admin: () => import(\"C:/Users/doan1/Desktop/FeTour/middleware/admin.js\"),\n  auth: () => import(\"C:/Users/doan1/Desktop/FeTour/middleware/auth.js\"),\n  \"auth-admin\": () => import(\"C:/Users/doan1/Desktop/FeTour/middleware/authAdmin.js\")\n}","import { isReadonly, reactive, shallowReactive, shallowRef } from \"vue\";\nimport {\n  START_LOCATION,\n  createMemoryHistory,\n  createRouter,\n  createWebHashHistory,\n  createWebHistory\n} from \"#vue-router\";\nimport { createError } from \"h3\";\nimport { isEqual, withoutBase } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { getRouteRules } from \"#app/composables/manifest\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { clearError, showError, useError } from \"#app/composables/error\";\nimport { navigateTo } from \"#app/composables/router\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport _routes from \"#build/routes\";\nimport routerOptions from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location, renderedPath) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const displayedPath = withoutBase(pathname, base);\n  const path = !renderedPath || isEqual(displayedPath, renderedPath, { trailingSlash: true }) ? displayedPath : renderedPath;\n  return path + (path.includes(\"?\") ? \"\" : search) + hash;\n}\nconst plugin = defineNuxtPlugin({\n  name: \"nuxt:router\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    let routerBase = useRuntimeConfig().app.baseURL;\n    if (routerOptions.hashMode && !routerBase.includes(\"#\")) {\n      routerBase += \"#\";\n    }\n    const history = routerOptions.history?.(routerBase) ?? (import.meta.client ? routerOptions.hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n    const routes = routerOptions.routes?.(_routes) ?? _routes;\n    let startPosition;\n    const initialURL = import.meta.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path);\n    const router = createRouter({\n      ...routerOptions,\n      scrollBehavior: (to, from, savedPosition) => {\n        if (from === START_LOCATION) {\n          startPosition = savedPosition;\n          return;\n        }\n        if (routerOptions.scrollBehavior) {\n          router.options.scrollBehavior = routerOptions.scrollBehavior;\n          if (\"scrollRestoration\" in window.history) {\n            const unsub = router.beforeEach(() => {\n              unsub();\n              window.history.scrollRestoration = \"manual\";\n            });\n          }\n          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);\n        }\n      },\n      history,\n      routes\n    });\n    if (import.meta.client && \"scrollRestoration\" in window.history) {\n      window.history.scrollRestoration = \"auto\";\n    }\n    nuxtApp.vueApp.use(router);\n    const previousRoute = shallowRef(router.currentRoute.value);\n    router.afterEach((_to, from) => {\n      previousRoute.value = from;\n    });\n    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n      get: () => previousRoute.value\n    });\n    const _route = shallowRef(router.resolve(initialURL));\n    const syncCurrentRoute = () => {\n      _route.value = router.currentRoute.value;\n    };\n    nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n    router.afterEach((to, from) => {\n      if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n        syncCurrentRoute();\n      }\n    });\n    const route = {};\n    for (const key in _route.value) {\n      Object.defineProperty(route, key, {\n        get: () => _route.value[key]\n      });\n    }\n    nuxtApp._route = shallowReactive(route);\n    nuxtApp._middleware = nuxtApp._middleware || {\n      global: [],\n      named: {}\n    };\n    const error = useError();\n    try {\n      if (import.meta.server) {\n        await router.push(initialURL);\n      }\n      await router.isReady();\n    } catch (error2) {\n      await nuxtApp.runWithContext(() => showError(error2));\n    }\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {\n      return { provide: { router } };\n    }\n    const initialLayout = nuxtApp.payload.state._layout;\n    router.beforeEach(async (to, from) => {\n      await nuxtApp.callHook(\"page:loading:start\");\n      to.meta = reactive(to.meta);\n      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {\n        to.meta.layout = initialLayout;\n      }\n      nuxtApp._processingMiddleware = true;\n      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n        for (const component of to.matched) {\n          const componentMiddleware = component.meta.middleware;\n          if (!componentMiddleware) {\n            continue;\n          }\n          for (const entry of toArray(componentMiddleware)) {\n            middlewareEntries.add(entry);\n          }\n        }\n        if (isAppManifestEnabled) {\n          const routeRules = await nuxtApp.runWithContext(() => getRouteRules(to.path));\n          if (routeRules.appMiddleware) {\n            for (const key in routeRules.appMiddleware) {\n              if (routeRules.appMiddleware[key]) {\n                middlewareEntries.add(key);\n              } else {\n                middlewareEntries.delete(key);\n              }\n            }\n          }\n        }\n        for (const entry of middlewareEntries) {\n          const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n          if (!middleware) {\n            if (import.meta.dev) {\n              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n            }\n            throw new Error(`Unknown route middleware: '${entry}'.`);\n          }\n          const result = await nuxtApp.runWithContext(() => middleware(to, from));\n          if (import.meta.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n            if (result === false || result instanceof Error) {\n              const error2 = result || createError({\n                statusCode: 404,\n                statusMessage: `Page Not Found: ${initialURL}`\n              });\n              await nuxtApp.runWithContext(() => showError(error2));\n              return false;\n            }\n          }\n          if (result === true) {\n            continue;\n          }\n          if (result || result === false) {\n            return result;\n          }\n        }\n      }\n    });\n    router.onError(async () => {\n      delete nuxtApp._processingMiddleware;\n      await nuxtApp.callHook(\"page:loading:end\");\n    });\n    router.afterEach(async (to, _from, failure) => {\n      delete nuxtApp._processingMiddleware;\n      if (import.meta.client && !nuxtApp.isHydrating && error.value) {\n        await nuxtApp.runWithContext(clearError);\n      }\n      if (failure) {\n        await nuxtApp.callHook(\"page:loading:end\");\n      }\n      if (import.meta.server && failure?.type === 4) {\n        return;\n      }\n      if (to.matched.length === 0) {\n        await nuxtApp.runWithContext(() => showError(createError({\n          statusCode: 404,\n          fatal: false,\n          statusMessage: `Page not found: ${to.fullPath}`,\n          data: {\n            path: to.fullPath\n          }\n        })));\n      } else if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {\n        await nuxtApp.runWithContext(() => navigateTo(to.fullPath || \"/\"));\n      }\n    });\n    nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n      try {\n        const to = router.resolve(initialURL);\n        if (\"name\" in to) {\n          to.name = void 0;\n        }\n        await router.replace({\n          ...to,\n          force: true\n        });\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n      } catch (error2) {\n        await nuxtApp.runWithContext(() => showError(error2));\n      }\n    });\n    return { provide: { router } };\n  }\n});\nexport default plugin;\n","import { hasProtocol, joinURL, withoutTrailingSlash } from \"ufo\";\nimport { parse } from \"devalue\";\nimport { useHead } from \"@unhead/vue\";\nimport { getCurrentInstance } from \"vue\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { useAppConfig } from \"../config.js\";\nimport { useRoute } from \"./router.js\";\nimport { getAppManifest, getRouteRules } from \"./manifest.js\";\nimport { appManifest, payloadExtraction, renderJsonPayloads } from \"#build/nuxt.config.mjs\";\nexport function loadPayload(url, opts = {}) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadURL = _getPayloadURL(url, opts);\n  const nuxtApp = useNuxtApp();\n  const cache = nuxtApp._payloadCache = nuxtApp._payloadCache || {};\n  if (payloadURL in cache) {\n    return cache[payloadURL];\n  }\n  cache[payloadURL] = isPrerendered(url).then((prerendered) => {\n    if (!prerendered) {\n      cache[payloadURL] = null;\n      return null;\n    }\n    return _importPayload(payloadURL).then((payload) => {\n      if (payload) {\n        return payload;\n      }\n      delete cache[payloadURL];\n      return null;\n    });\n  });\n  return cache[payloadURL];\n}\nexport function preloadPayload(url, opts = {}) {\n  const payloadURL = _getPayloadURL(url, opts);\n  useHead({\n    link: [\n      { rel: \"modulepreload\", href: payloadURL }\n    ]\n  });\n}\nconst filename = renderJsonPayloads ? \"_payload.json\" : \"_payload.js\";\nfunction _getPayloadURL(url, opts = {}) {\n  const u = new URL(url, \"http://localhost\");\n  if (u.host !== \"localhost\" || hasProtocol(u.pathname, { acceptRelative: true })) {\n    throw new Error(\"Payload URL must not include hostname: \" + url);\n  }\n  const hash = opts.hash || (opts.fresh ? Date.now() : useAppConfig().nuxt?.buildId);\n  return joinURL(useRuntimeConfig().app.baseURL, u.pathname, filename + (hash ? `?${hash}` : \"\"));\n}\nasync function _importPayload(payloadURL) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadPromise = renderJsonPayloads ? fetch(payloadURL).then((res) => res.text().then(parsePayload)) : import(\n    /* webpackIgnore: true */\n    /* @vite-ignore */\n    payloadURL\n  ).then((r) => r.default || r);\n  try {\n    return await payloadPromise;\n  } catch (err) {\n    console.warn(\"[nuxt] Cannot load payload \", payloadURL, err);\n  }\n  return null;\n}\nexport async function isPrerendered(url = useRoute().path) {\n  if (!appManifest) {\n    return !!useNuxtApp().payload.prerenderedAt;\n  }\n  url = withoutTrailingSlash(url);\n  const manifest = await getAppManifest();\n  if (manifest.prerendered.includes(url)) {\n    return true;\n  }\n  const rules = await getRouteRules(url);\n  return !!rules.prerender && !rules.redirect;\n}\nlet payloadCache = null;\nexport async function getNuxtClientPayload() {\n  if (import.meta.server) {\n    return;\n  }\n  if (payloadCache) {\n    return payloadCache;\n  }\n  const el = document.getElementById(\"__NUXT_DATA__\");\n  if (!el) {\n    return {};\n  }\n  const inlineData = await parsePayload(el.textContent || \"\");\n  const externalData = el.dataset.src ? await _importPayload(el.dataset.src) : void 0;\n  payloadCache = {\n    ...inlineData,\n    ...externalData,\n    ...window.__NUXT__\n  };\n  return payloadCache;\n}\nexport async function parsePayload(payload) {\n  return await parse(payload, useNuxtApp()._payloadRevivers);\n}\nexport function definePayloadReducer(name, reduce) {\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._payloadReducers[name] = reduce;\n  }\n}\nexport function definePayloadReviver(name, revive) {\n  if (import.meta.dev && getCurrentInstance()) {\n    console.warn(\"[nuxt] [definePayloadReviver] This function must be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.\");\n  }\n  if (import.meta.client) {\n    useNuxtApp()._payloadRevivers[name] = revive;\n  }\n}\n","import { isReactive, isRef, isShallow, toRaw } from \"vue\";\nimport { definePayloadReducer } from \"../composables/payload.js\";\nimport { isNuxtError } from \"../composables/error.js\";\nimport { defineNuxtPlugin } from \"../nuxt.js\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nconst reducers = {\n  NuxtError: (data) => isNuxtError(data) && data.toJSON(),\n  EmptyShallowRef: (data) => isRef(data) && isShallow(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\"),\n  EmptyRef: (data) => isRef(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\"),\n  ShallowRef: (data) => isRef(data) && isShallow(data) && data.value,\n  ShallowReactive: (data) => isReactive(data) && isShallow(data) && toRaw(data),\n  Ref: (data) => isRef(data) && data.value,\n  Reactive: (data) => isReactive(data) && toRaw(data)\n};\nif (componentIslands) {\n  reducers.Island = (data) => data && data?.__nuxt_island;\n}\nexport default defineNuxtPlugin({\n  name: \"nuxt:revive-payload:server\",\n  setup() {\n    for (const reducer in reducers) {\n      definePayloadReducer(reducer, reducers[reducer]);\n    }\n  }\n});\n","import { defineNuxtPlugin } from '#app/nuxt'\nimport { LazyIcon, LazyIconCSS } from '#components'\nconst lazyGlobalComponents = [\n  [\"Icon\", LazyIcon],\n[\"IconCSS\", LazyIconCSS],\n  \n]\n\nexport default defineNuxtPlugin({\n  name: 'nuxt:global-components',\n  setup (nuxtApp) {\n    for (const [name, component] of lazyGlobalComponents) {\n      nuxtApp.vueApp.component(name, component)\n      nuxtApp.vueApp.component('Lazy' + name, component)\n    }\n  }\n})\n","import { cloneVNode, createElementBlock, createStaticVNode, defineComponent, getCurrentInstance, h, onMounted, provide, ref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { getFragmentHTML } from \"./utils.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  // eslint-disable-next-line vue/require-prop-types\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  setup(_, { slots, attrs }) {\n    const mounted = ref(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    provide(clientOnlySymbol, true);\n    return (props) => {\n      if (mounted.value) {\n        return slots.default?.();\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return slot();\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      } else {\n        const fragment = getFragmentHTML(ctx._.vnode.el ?? null) ?? [\"<div></div>\"];\n        return import.meta.client ? createStaticVNode(fragment.join(\"\"), fragment.length) : h(\"div\", ctx.$attrs ?? ctx._.attrs);\n      }\n    };\n  } else if (clone.template) {\n    clone.template = `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else><div></div></template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const instance = getCurrentInstance();\n    const attrs = { ...instance.attrs };\n    const directives = extractDirectives(instance);\n    for (const key in attrs) {\n      delete instance.attrs[key];\n    }\n    const mounted$ = ref(false);\n    onMounted(() => {\n      Object.assign(instance.attrs, attrs);\n      instance.vnode.dirs = directives;\n      mounted$.value = true;\n    });\n    return Promise.resolve(component.setup?.(props, ctx) || {}).then((setupState) => {\n      if (typeof setupState !== \"function\") {\n        setupState = setupState || {};\n        setupState.mounted$ = mounted$;\n        return setupState;\n      }\n      return (...args) => {\n        if (mounted$.value) {\n          const res = setupState(...args);\n          return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n        } else {\n          const fragment = getFragmentHTML(instance?.vnode.el ?? null) ?? [\"<div></div>\"];\n          return import.meta.client ? createStaticVNode(fragment.join(\"\"), fragment.length) : h(\"div\", ctx.attrs);\n        }\n      };\n    });\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n","import { noop, makeDestructurable, camelize, toValue, isClient, isObject, tryOnScopeDispose, isIOS, tryOnMounted, objectOmit, promiseTimeout, until, increaseWithUnit, objectEntries, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, notNullish, computedWithControl, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, toRefs, useIntervalFn, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, tryOnBeforeUnmount, identity, isDef, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, isVue2, readonly, nextTick, reactive, markRaw, unref, getCurrentScope, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return noop;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n          handler(event);\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nconst DEFAULT_THRESHOLD = 10;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  let posStart;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n    posStart = void 0;\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    posStart = {\n      x: ev.x,\n      y: ev.y\n    };\n    timeout = setTimeout(\n      () => handler(ev),\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  function onMove(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    if (!posStart || (options == null ? void 0 : options.distanceThreshold) === false)\n      return;\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    const dx = ev.x - posStart.x;\n    const dy = ev.y - posStart.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance >= ((_d = options == null ? void 0 : options.distanceThreshold) != null ? _d : DEFAULT_THRESHOLD))\n      clear();\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, \"pointermove\", onMove, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], clear, listenerOptions)\n  ];\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = ref();\n  const trigger = () => {\n    activeElement.value = getDeepActiveElement();\n  };\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      trigger();\n    }, true);\n    useEventListener(window, \"focus\", trigger, true);\n  }\n  trigger();\n  return activeElement;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  const instance = getCurrentInstance();\n  if (instance) {\n    onMounted(() => {\n      isMounted.value = true;\n    }, isVue2 ? null : instance);\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    if (!previousFrameTimestamp)\n      previousFrameTimestamp = timestamp;\n    const delta = timestamp - previousFrameTimestamp;\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    previousFrameTimestamp = timestamp;\n    fn({ delta, timestamp });\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      previousFrameTimestamp = 0;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    if (!animate.value)\n      animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (commitStyles)\n      animate.value.commitStyles();\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator && typeof navigator.getBattery === \"function\");\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetifyV2 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1264,\n  xl: 1904\n};\nconst breakpointsVuetifyV3 = {\n  xs: 0,\n  sm: 600,\n  md: 960,\n  lg: 1280,\n  xl: 1920,\n  xxl: 2560\n};\nconst breakpointsVuetify = breakpointsVuetifyV2;\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 0,\n  sm: 600,\n  md: 1024,\n  lg: 1440,\n  xl: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = toValue(breakpoints[toValue(k)]);\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow, strategy = \"min-width\" } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(() => `(min-width: ${getValue(k)})`, options);\n  };\n  const smallerOrEqual = (k) => {\n    return useMediaQuery(() => `(max-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => strategy === \"min-width\" ? greaterOrEqual(k) : smallerOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  function current() {\n    const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n    return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n  }\n  return Object.assign(shortcutMethods, {\n    greaterOrEqual,\n    smallerOrEqual,\n    greater(k) {\n      return useMediaQuery(() => `(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    smaller(k) {\n      return useMediaQuery(() => `(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(() => `(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current,\n    active() {\n      const bps = current();\n      return computed(() => bps.value.length === 0 ? \"\" : bps.value.at(-1));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && isAllowed(permissionRead.value)) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && isAllowed(permissionWrite.value))\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  function isAllowed(status) {\n    return status === \"granted\" || status === \"prompt\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  function dispatchWriteEvent(oldValue, newValue) {\n    if (window) {\n      window.dispatchEvent(new CustomEvent(customStorageEventName, {\n        detail: {\n          key,\n          oldValue,\n          newValue,\n          storageArea: storage\n        }\n      }));\n    }\n  }\n  function write(v) {\n    try {\n      const oldValue = storage.getItem(key);\n      if (v == null) {\n        dispatchWriteEvent(oldValue, null);\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          dispatchWriteEvent(oldValue, serialized);\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit != null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  return data;\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => {\n    const value = toValue(target);\n    const items = (Array.isArray(value) ? value : [value]).map(unrefElement).filter(notNullish);\n    return new Set(items);\n  });\n  const stopWatch = watch(\n    () => targets.value,\n    (targets2) => {\n      cleanup();\n      if (isSupported.value && window && targets2.size) {\n        observer = new MutationObserver(callback);\n        targets2.forEach((el) => observer.observe(el, mutationOptions));\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement(rootComponent) {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => rootComponent ? unrefElement(rootComponent) : vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev,\n    go: set\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const system = computed(() => {\n    if (mode.system) {\n      return mode.system.value;\n    } else {\n      const preferredDark = usePreferredDark({ window });\n      return preferredDark.value ? \"dark\" : \"light\";\n    }\n  });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    tryOnScopeDispose(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left + container.scrollLeft : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top + container.scrollTop : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), container.scrollWidth - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), container.scrollHeight - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (toValue(options.disabled) || !filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  const isOverDropZone = ref(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isDataTypeIncluded = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const getFiles = (event) => {\n      var _a, _b;\n      const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      return files.value = list.length === 0 ? null : list;\n    };\n    useEventListener(target, \"dragenter\", (event) => {\n      var _a, _b;\n      const types = Array.from(((_a = event == null ? void 0 : event.dataTransfer) == null ? void 0 : _a.items) || []).map((i) => i.kind === \"file\" ? i.type : null).filter(notNullish);\n      if (_options.dataTypes && event.dataTransfer) {\n        const dataTypes = unref(_options.dataTypes);\n        isDataTypeIncluded = typeof dataTypes === \"function\" ? dataTypes(types) : dataTypes ? dataTypes.some((item) => types.includes(item)) : true;\n        if (!isDataTypeIncluded)\n          return;\n      }\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n      (_b = _options.onEnter) == null ? void 0 : _b.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  useMutationObserver(target, update, {\n    attributeFilter: [\"style\", \"class\"]\n  });\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const styles = window.getComputedStyle($elem);\n          width.value = Number.parseFloat(styles.width);\n          height.value = Number.parseFloat(styles.height);\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget, threshold = 0 } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    (intersectionObserverEntries) => {\n      let isIntersecting = elementIsVisible.value;\n      let latestTime = 0;\n      for (const entry of intersectionObserverEntries) {\n        if (entry.time >= latestTime) {\n          latestTime = entry.time;\n          isIntersecting = entry.isIntersecting;\n        }\n      }\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction resolveNestedOptions$1(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const urlRef = toRef(url);\n  let explicitlyClosed = false;\n  let retried = 0;\n  const {\n    withCredentials = false,\n    immediate = true\n  } = options;\n  const close = () => {\n    if (isClient && eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n      explicitlyClosed = true;\n    }\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const es = new EventSource(urlRef.value, { withCredentials });\n    status.value = \"CONNECTING\";\n    eventSource.value = es;\n    es.onopen = () => {\n      status.value = \"OPEN\";\n      error.value = null;\n    };\n    es.onerror = (e) => {\n      status.value = \"CLOSED\";\n      error.value = e;\n      if (es.readyState === 2 && !explicitlyClosed && options.autoReconnect) {\n        es.close();\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions$1(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    es.onmessage = (e) => {\n      event.value = null;\n      data.value = e.data;\n    };\n    for (const event_name of events) {\n      useEventListener(es, event_name, (e) => {\n        event.value = event_name;\n        data.value = e.data || null;\n      });\n    }\n  };\n  const open = () => {\n    if (!isClient)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  tryOnScopeDispose(close);\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    open,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries(headers.entries());\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2, _b;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = toValue(config.payload);\n      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return fetch(\n      context.url,\n      {\n        ...defaultFetchOptions,\n        ...context.options,\n        headers: {\n          ...headersToObject(defaultFetchOptions.headers),\n          ...headersToObject((_b = context.options) == null ? void 0 : _b.headers)\n        }\n      }\n    ).then(async (fetchResponse) => {\n      response.value = fetchResponse;\n      statusCode.value = fetchResponse.status;\n      responseData = await fetchResponse.clone()[config.type]();\n      if (!fetchResponse.ok) {\n        data.value = initialData || null;\n        throw new Error(fetchResponse.statusText);\n      }\n      if (options.afterFetch) {\n        ({ data: responseData } = await options.afterFetch({\n          data: responseData,\n          response: fetchResponse\n        }));\n      }\n      data.value = responseData;\n      responseEvent.trigger(fetchResponse);\n      return fetchResponse;\n    }).catch(async (fetchError) => {\n      let errorData = fetchError.message || fetchError.name;\n      if (options.onFetchError) {\n        ({ error: errorData, data: responseData } = await options.onFetchError({\n          data: responseData,\n          error: fetchError,\n          response: response.value\n        }));\n      }\n      error.value = errorData;\n      if (options.updateDataOnError)\n        data.value = responseData;\n      errorEvent.trigger(fetchError);\n      if (throwOnFailed)\n        throw fetchError;\n      return null;\n    }).finally(() => {\n      if (currentExecuteCounter === executeCounter)\n        loading(false);\n      if (timer)\n        timer.stop();\n      finallyEvent.trigger(null);\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished: readonly(isFinished),\n    isFetching: readonly(isFetching),\n    statusCode,\n    response,\n    error,\n    data,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input) {\n      input.value = \"\";\n      trigger(null);\n    }\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    await updateFile();\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      ...gamepad,\n      id: gamepad.id,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value })),\n      index: gamepad.index\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        gamepads.value[gamepad.index] = stateFromGamepad(gamepad);\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (const gamepad of _gamepads) {\n      if (gamepad && gamepads.value[gamepad.index])\n        onGamepadConnected(gamepad);\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = ((_a = target == null ? void 0 : target.document) == null ? void 0 : _a.documentElement) || (target == null ? void 0 : target.documentElement) || unrefElement(target);\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    try {\n      const _element = toValue(element);\n      if (!_element)\n        return;\n      setArrivedState(_element);\n    } catch (e) {\n      onError(e);\n    }\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100,\n    canLoadMore = () => true\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value || !canLoadMore(observedElement.value))\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = shallowReactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return shallowReactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return shallowReactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX;\n      y.value = pos[1] + window.scrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page)) {\n    syncRef(page, currentPage, {\n      direction: isReadonly(page) ? \"ltr\" : \"both\"\n    });\n  }\n  if (isRef(pageSize)) {\n    syncRef(pageSize, currentPageSize, {\n      direction: isReadonly(pageSize) ? \"ltr\" : \"both\"\n    });\n  }\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (isSupported.value && typeof screenOrientation.lock === \"function\")\n      return screenOrientation.lock(type);\n    return Promise.reject(new Error(\"Not supported\"));\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value && typeof screenOrientation.unlock === \"function\")\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const screenOrientation = reactive(useScreenOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        case \"portrait-primary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-secondary\":\n          value = orientation.beta / 90;\n          break;\n        default:\n          value = -orientation.beta / 90;\n      }\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      let value;\n      switch (screenOrientation.orientation) {\n        case \"landscape-primary\":\n          value = orientation.beta / 90;\n          break;\n        case \"landscape-secondary\":\n          value = -orientation.beta / 90;\n          break;\n        case \"portrait-primary\":\n          value = orientation.gamma / 90;\n          break;\n        case \"portrait-secondary\":\n          value = -orientation.gamma / 90;\n          break;\n        default:\n          value = orientation.gamma / 90;\n      }\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock();\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    disableTextSelect = false\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n    })\n  ];\n  tryOnMounted(() => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n    if (disableTextSelect) {\n      (_d = (_c = targetRef.value) == null ? void 0 : _c.style) == null ? void 0 : _d.setProperty(\"-webkit-user-select\", \"none\");\n      (_f = (_e = targetRef.value) == null ? void 0 : _e.style) == null ? void 0 : _f.setProperty(\"-ms-user-select\", \"none\");\n      (_h = (_g = targetRef.value) == null ? void 0 : _g.style) == null ? void 0 : _h.setProperty(\"user-select\", \"none\");\n    }\n  });\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, ele.style.overflow);\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    var _a;\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = (_a = elInitialOverflow.get(el)) != null ? _a : \"\";\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorageAsync\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else\n          data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  var _a;\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const styleProp = (_a = options == null ? void 0 : options.styleProp) != null ? _a : \"height\";\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a2, _b;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style[styleProp] = \"1px\";\n    textareaScrollHeight.value = (_a2 = textarea.value) == null ? void 0 : _a2.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style[styleProp] = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style[styleProp] = height;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval, { immediate: false });\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b, _c;\n  const {\n    document = defaultDocument,\n    restoreOnUnmount = (t) => t\n  } = options;\n  const originalTitle = (_a = document == null ? void 0 : document.title) != null ? _a : \"\";\n  const title = toRef((_b = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _b : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_c = document.head) == null ? void 0 : _c.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  tryOnBeforeUnmount(() => {\n    if (restoreOnUnmount) {\n      const restoredTitle = restoreOnUnmount(originalTitle, title.value || \"\");\n      if (restoredTitle != null && document)\n        document.title = restoredTitle;\n    }\n  });\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(() => {\n    stop();\n  });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const permissionGranted = ref(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n    wsRef.value = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    open();\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps) {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n}\n\nfunction createWorkerBlobUrl(fn, deps) {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const internalX = ref(window.scrollX);\n  const internalY = ref(window.scrollY);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, breakpointsVuetifyV2, breakpointsVuetifyV3, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","import { isArray, keys, startsWith, forOwn, isEmpty, set, pickBy, pick, has, camelCase, isString, isNumber, isBoolean } from \"lodash-es\";\nimport { breakpointsBootstrapV5 } from \"@vueuse/core\";\nexport {\n  isArray,\n  startsWith,\n  forOwn,\n  isEmpty,\n  set,\n  pickBy,\n  pick,\n  has,\n  camelCase,\n  isString,\n  isNumber,\n  isBoolean\n};\nexport {\n  objectPick,\n  isDef,\n  useTimeoutFn,\n  templateRef,\n  useCssVar,\n  useCycleList,\n  useScrollLock,\n  useMagicKeys,\n  whenever,\n  useResizeObserver,\n  useWindowSize,\n  throttledWatch,\n  useFocus,\n  useTimeout,\n  debouncedWatch,\n  pausableWatch,\n  throttleFilter,\n  useElementHover,\n  useEventListener,\n  unrefElement,\n  onClickOutside,\n  useIntersectionObserver,\n  useIntervalFn,\n  useElementVisibility,\n  useSwipe,\n  promiseTimeout,\n  useBreakpoints,\n  useDark,\n  useToggle,\n  useWindowScroll,\n  useDebounceFn,\n  watchDebounced,\n  breakpointsBootstrapV5,\n  defaultWindow,\n  defaultDocument\n} from \"@vueuse/core\";\nexport { onClickOutsideFixed } from \"./onClickOutsideFixed.mjs\";\nexport function startsWithBreakPoint(value) {\n  return keys(breakpointsBootstrapV5).findIndex(\n    (breakpoint) => value.startsWith(breakpoint)\n  ) >= 0;\n}\nexport function delay(ms) {\n  return new Promise(function(resolve) {\n    setTimeout(resolve, ms);\n  });\n}\n","import { unref } from \"vue\";\nimport {\n  set,\n  forOwn,\n  isEmpty,\n  pickBy,\n  isArray,\n  isBoolean,\n  startsWithBreakPoint,\n  isNumber,\n  isString\n} from \"./helpers.mjs\";\nexport function hProps(...items) {\n  const result = {\n    class: {},\n    style: {}\n  };\n  const events = /* @__PURE__ */ new Map();\n  items.forEach((item) => {\n    result.class && Object.assign(result.class, unref(item.class));\n    result.style && Object.assign(result.style, unref(item.style));\n    Object.assign(result, unref(item.attr));\n    if (item.ref) {\n      set(result, \"ref\", item.ref);\n    }\n    forOwn(item.event, (value, key) => {\n      if (events.has(key)) {\n        events.get(key)?.push(value);\n      } else {\n        const funcs = [value];\n        events.set(key, funcs);\n        const val = (payload) => {\n          events.get(key)?.forEach((func) => func(payload));\n        };\n        result[key] = val;\n      }\n    });\n  });\n  if (result.class && isEmpty(pickBy(result.class))) {\n    delete result.class;\n  }\n  if (result.style && isEmpty(pickBy(result.style))) {\n    delete result.style;\n  }\n  return result;\n}\nexport function hSlots(...slots) {\n  return slots.map((value) => {\n    return value ? value() : void 0;\n  });\n}\nexport function addClassNames(value, func) {\n  const classObject = {};\n  const values = toArray(value);\n  values.forEach((n) => {\n    classObject[func(n)] = true;\n  });\n  return classObject;\n}\nexport function addProp(test, name, value) {\n  return ((test || isNumber(test)) && value ? true : false) && { [name]: value };\n}\nexport function isPropUndefined(value) {\n  return !isString(value) && (value == void 0 || value == false);\n}\nexport function isPropDefined(value) {\n  return !isPropUndefined(value);\n}\nexport function isNumrable(value) {\n  return !isNaN(parseInt(value));\n}\nexport function hasValue(value) {\n  return isString(value) && value || isNumber(value) || isArray(value);\n}\nexport function isTrue(value) {\n  if (isBoolean(value)) {\n    return value;\n  }\n  if (isString(value)) {\n    if (value.toLowerCase() == \"true\" || value == \"\") {\n      return true;\n    }\n  }\n  return false;\n}\nexport function toNum(value) {\n  if (isNumber(value)) {\n    return value;\n  }\n  if (isNumrable(value)) {\n    return parseInt(value);\n  }\n  return 0;\n}\nexport function toArray(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  if (isString(value)) {\n    return value.split(\" \").filter((item) => item);\n  }\n  if (value == void 0 || value == false) {\n    return [];\n  }\n  return [value];\n}\nexport function exposeMethods(context, ...items) {\n  const result = {};\n  const methods = /* @__PURE__ */ new Map();\n  items.forEach((item) => {\n    forOwn(item.method, (value, key) => {\n      if (methods.has(key)) {\n        methods.get(key)?.push(value);\n      } else {\n        const funcs = [value];\n        methods.set(key, funcs);\n        const val = (...payloads) => {\n          methods.get(key)?.forEach((func) => func(payloads));\n        };\n        result[key] = val;\n      }\n    });\n  });\n  if (!isEmpty(result)) {\n    context.expose(result);\n  }\n}\nexport function spacing(val, tag) {\n  if (isNumrable(val)) {\n    return `${tag}-${val}`;\n  }\n  if (startsWithBreakPoint(val)) {\n    return `${tag}-${val}`;\n  }\n  if (val == \"auto\") {\n    return `${tag}-${val}`;\n  }\n  return `${tag}${val}`;\n}\n","import { spacing, toArray, hasValue } from \"../../utils/useProps.mjs\";\nexport function useDirective(element) {\n  if (element && element.attributes) {\n    for (const attr of element.attributes) {\n      switch (attr.name) {\n        case \"text-break\":\n          element.classList.add(\n            `text-break`\n          );\n          break;\n        case \"text-alignment\":\n          element.classList.add(\n            `text-${attr.value}`\n          );\n          break;\n        case \"text-wrap\":\n          element.classList.add(\n            `text-${attr.value}`\n          );\n          break;\n        case \"align-self\":\n          element.classList.add(\n            `align-self-${attr.value}`\n          );\n          break;\n        case \"align-items\":\n          element.classList.add(\n            `align-items-${attr.value}`\n          );\n          break;\n        case \"align-content\":\n          element.classList.add(\n            `align-content-${attr.value}`\n          );\n          break;\n        case \"flex\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `d${hasValue(attr.value) ? `-${n}` : \"\"}-flex`)\n          );\n          break;\n        case \"flex-direction\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `flex-${n}`)\n          );\n          break;\n        case \"flex-fill\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `flex${hasValue(attr.value) ? `-${n}` : \"\"}-fill`)\n          );\n          break;\n        case \"flex-grow\":\n          element.classList.add(\n            `flex-${attr.value}`\n          );\n          break;\n        case \"flex-wrap\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `flex-${n}`)\n          );\n          break;\n        case \"flex-order\":\n          element.classList.add(\n            `order-${attr.value}`\n          );\n          break;\n        case \"float\":\n          element.classList.add(\n            `float-${attr.value}`\n          );\n          break;\n        case \"shadow\":\n          element.classList.add(\n            `shadow${hasValue(attr.value) ? `-${attr.value}` : \"\"}`\n          );\n          break;\n        case \"ratio\":\n          element.classList.add(\n            `ratio-${attr.value}`\n          );\n          break;\n        case \"fixed\":\n          element.classList.add(\n            `fixed-${attr.value}`\n          );\n          break;\n        case \"sticky\":\n          element.classList.add(\n            `sticky-top`\n          );\n          break;\n        case \"overflow\":\n          element.classList.add(\n            `overflow-${attr.value}`\n          );\n          break;\n        case \"table-responsive\":\n          element.classList.add(\n            `table-responsive${hasValue(attr.value) ? `-${attr.value}` : \"\"}`\n          );\n          break;\n        case \"justify-content\":\n          element.classList.add(\n            `justify-content-${attr.value}`\n          );\n          break;\n        case \"align\":\n          element.classList.add(\n            `align-${attr.value}`\n          );\n          break;\n        case \"order\":\n          element.classList.add(\n            `order-${attr.value}`\n          );\n          break;\n        case \"offset\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `offset-${n}`)\n          );\n          break;\n        case \"object-fit\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `object-fit-${n}`)\n          );\n          break;\n        case \"z\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `z-${n}`)\n          );\n          break;\n        case \"font-size\":\n          element.classList.add(\n            `fs-${attr.value}`\n          );\n          break;\n        case \"font-weight\":\n          element.classList.add(\n            `fw-${attr.value}`\n          );\n          break;\n        case \"font-style\":\n          element.classList.add(\n            `fst-${attr.value}`\n          );\n          break;\n        case \"line-height\":\n          element.classList.add(\n            `lh-${attr.value}`\n          );\n          break;\n        case \"font-monospace\":\n          element.classList.add(\n            `font-monospace`\n          );\n          break;\n        case \"text-reset\":\n          element.classList.add(\n            `text-reset`\n          );\n          break;\n        case \"text-decoration\":\n          element.classList.add(\n            `text-decoration-${attr.value}`\n          );\n          break;\n        case \"text-truncate\":\n          element.classList.add(\n            `text-truncate`\n          );\n          break;\n        case \"text-transform\":\n          element.classList.add(\n            `text-${attr.value}`\n          );\n          break;\n        case \"text-background\":\n          element.classList.add(\n            `text-bg-${attr.value}`\n          );\n          break;\n        case \"headings\":\n          element.classList.add(\n            `h${attr.value}`\n          );\n          break;\n        case \"text-color\":\n          element.classList.add(\n            `text-${attr.value}`\n          );\n          break;\n        case \"padding\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => spacing(n, \"p\"))\n          );\n          break;\n        case \"margin\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => spacing(n, \"m\"))\n          );\n          break;\n        case \"gap\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `gap-${n}`)\n          );\n          break;\n        case \"visually-hidden\":\n          element.classList.add(\n            `visually-hidden${hasValue(attr.value) ? `-${attr.value}` : \"\"}`\n          );\n          break;\n        case \"vertical-Align\":\n          element.classList.add(\n            `align-${attr.value}`\n          );\n          break;\n        case \"user-select\":\n          element.classList.add(\n            `user-select-${attr.value}`\n          );\n          break;\n        case \"pointer-events\":\n          element.classList.add(\n            `pe-${attr.value}`\n          );\n          break;\n        case \"background-color\":\n          element.classList.add(\n            `bg-${attr.value}`\n          );\n          break;\n        case \"background-gradient\":\n          element.classList.add(\n            `bg-gradient`\n          );\n          break;\n        case \"background-opacity\":\n          element.classList.add(\n            `bg-opacity-${attr.value}`\n          );\n          break;\n        case \"relative-width\":\n          element.classList.add(\n            `w-${attr.value}`\n          );\n          break;\n        case \"relative-height\":\n          element.classList.add(\n            `h-${attr.value}`\n          );\n          break;\n        case \"max-width\":\n          element.classList.add(\n            `mw-100`\n          );\n          break;\n        case \"max-height\":\n          element.classList.add(\n            `mh-100`\n          );\n          break;\n        case \"viewport-width\":\n          element.classList.add(\n            `vw-100`\n          );\n          break;\n        case \"viewport-height\":\n          element.classList.add(\n            `vh-100`\n          );\n          break;\n        case \"min-viewport-width\":\n          element.classList.add(\n            `min-vw-100`\n          );\n          break;\n        case \"min-viewport-height\":\n          element.classList.add(\n            `min-vh-100`\n          );\n          break;\n        case \"display\":\n          element.classList.add(\n            ...addClassNames(attr.value, (n) => `d-${n}`)\n          );\n          break;\n        case \"opacity\":\n          element.classList.add(\n            `opacity-${attr.value}`\n          );\n          break;\n        case \"placeholder\":\n          element.classList.add(\n            `placeholder${hasValue(attr.value) ? `-${attr.value}` : \"\"}`\n          );\n          break;\n        case \"placeholder-size\":\n          element.classList.add(\n            `placeholder-${attr.value}`\n          );\n          break;\n        case \"col\":\n          element.classList.add(\n            ...addClassNames(hasValue(attr.value), (n) => `col-${n}`)\n          );\n          break;\n        case \"position\":\n          element.classList.add(\n            `position-${attr.value}`\n          );\n          break;\n        case \"top\":\n          element.classList.add(\n            `top-${attr.value}`\n          );\n          break;\n        case \"start\":\n          element.classList.add(\n            `start-${attr.value}`\n          );\n          break;\n        case \"end\":\n          element.classList.add(\n            `end-${attr.value}`\n          );\n          break;\n        case \"bottom\":\n          element.classList.add(\n            `bottom-${attr.value}`\n          );\n          break;\n        case \"translate\":\n          element.classList.add(\n            `translate-${attr.value}`\n          );\n          break;\n        case \"focus-ring\":\n          element.classList.add(\n            `focus-ring`\n          );\n          break;\n        case \"border\":\n          element.classList.add(\n            `border${hasValue(attr.value) ? `-${attr.value}` : \"\"}`\n          );\n          break;\n        case \"border-color\":\n          element.classList.add(\n            `border-${attr.value}`\n          );\n          break;\n        case \"border-width\":\n          element.classList.add(\n            `border-${attr.value}`\n          );\n          break;\n        case \"rounded\":\n          element.classList.add(\n            `rounded${hasValue(attr.value) ? `-${attr.value}` : \"\"}`\n          );\n          break;\n        case \"rounded-size\":\n          element.classList.add(\n            `rounded-${attr.value}`\n          );\n          break;\n        case \"link-opacity\":\n          element.classList.add(\n            `link-opacity-${attr.value}`\n          );\n          break;\n        case \"link-underline\":\n          element.classList.add(\n            `link-underline`\n          );\n          element.classList.add(\n            ...addClassNames(hasValue(attr.value), (n) => `link-underline-opacity-${n}`)\n          );\n          break;\n        case \"link-offset\":\n          element.classList.add(\n            ...addClassNames(hasValue(attr.value), (n) => `link-offset-${n}`)\n          );\n      }\n    }\n  }\n}\nfunction addClassNames(value, func) {\n  const classArray = [];\n  const values = toArray(value);\n  values.forEach((n) => {\n    classArray.push(func(n));\n  });\n  return classArray;\n}\n","import { defineNuxtPlugin } from \"#app\";\nimport { useDirective } from \"../composables/directive/useDirective.mjs\";\nexport default defineNuxtPlugin((nuxtApp) => {\n  nuxtApp.vueApp.directive(\n    \"bootstrap\",\n    {\n      mounted(el) {\n        useDirective(el);\n      }\n    }\n  );\n});\n","import { defineNuxtPlugin } from '#imports'\n\nexport default defineNuxtPlugin((nuxtApp) => {\n  nuxtApp.hook('app:rendered', (ctx) => {\n    if (ctx.ssrContext?.teleports) {\n      ctx.ssrContext.teleports = renderTeleports(ctx.ssrContext.teleports)\n    }\n  })\n})\n\nfunction renderTeleports (teleports) {\n  const body = Object.entries(teleports).reduce((all, [key, value]) => {\n    if (key.startsWith('#el-popper-container-') || [].includes(key)) {\n      return `${all}<div id=\"${key.slice(1)}\">${value}</div>`\n    }\n    return all\n  }, teleports.body || '')\n  return { ...teleports, body }\n}\n","import { getCurrentInstance, inject, computed, unref } from 'vue';\nimport '../../utils/index.mjs';\nimport { useGetDerivedNamespace } from '../use-namespace/index.mjs';\nimport { isClient } from '@vueuse/core';\nimport { debugWarn } from '../../utils/error.mjs';\n\nconst defaultIdInjection = {\n  prefix: Math.floor(Math.random() * 1e4),\n  current: 0\n};\nconst ID_INJECTION_KEY = Symbol(\"elIdInjection\");\nconst useIdInjection = () => {\n  return getCurrentInstance() ? inject(ID_INJECTION_KEY, defaultIdInjection) : defaultIdInjection;\n};\nconst useId = (deterministicId) => {\n  const idInjection = useIdInjection();\n  if (!isClient && idInjection === defaultIdInjection) {\n    debugWarn(\"IdInjection\", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed\nusage: app.provide(ID_INJECTION_KEY, {\n  prefix: number,\n  current: number,\n})`);\n  }\n  const namespace = useGetDerivedNamespace();\n  const idRef = computed(() => unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);\n  return idRef;\n};\n\nexport { ID_INJECTION_KEY, useId, useIdInjection };\n//# sourceMappingURL=index.mjs.map\n","import { ref, getCurrentInstance, inject, computed, unref } from 'vue';\nimport '../../utils/index.mjs';\nimport { isNumber } from '../../utils/types.mjs';\nimport { isClient } from '@vueuse/core';\nimport { debugWarn } from '../../utils/error.mjs';\n\nconst initial = {\n  current: 0\n};\nconst zIndex = ref(0);\nconst defaultInitialZIndex = 2e3;\nconst ZINDEX_INJECTION_KEY = Symbol(\"elZIndexContextKey\");\nconst zIndexContextKey = Symbol(\"zIndexContextKey\");\nconst useZIndex = (zIndexOverrides) => {\n  const increasingInjection = getCurrentInstance() ? inject(ZINDEX_INJECTION_KEY, initial) : initial;\n  const zIndexInjection = zIndexOverrides || (getCurrentInstance() ? inject(zIndexContextKey, void 0) : void 0);\n  const initialZIndex = computed(() => {\n    const zIndexFromInjection = unref(zIndexInjection);\n    return isNumber(zIndexFromInjection) ? zIndexFromInjection : defaultInitialZIndex;\n  });\n  const currentZIndex = computed(() => initialZIndex.value + zIndex.value);\n  const nextZIndex = () => {\n    increasingInjection.current++;\n    zIndex.value = increasingInjection.current;\n    return currentZIndex.value;\n  };\n  if (!isClient && !inject(ZINDEX_INJECTION_KEY)) {\n    debugWarn(\"ZIndexInjection\", `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed\nusage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`);\n  }\n  return {\n    initialZIndex,\n    currentZIndex,\n    nextZIndex\n  };\n};\n\nexport { ZINDEX_INJECTION_KEY, defaultInitialZIndex, useZIndex, zIndexContextKey };\n//# sourceMappingURL=index.mjs.map\n","import { defineNuxtPlugin } from '#imports';\nimport { ID_INJECTION_KEY, ZINDEX_INJECTION_KEY } from 'element-plus';\n\nexport default defineNuxtPlugin(nuxtApp => {\n  nuxtApp.vueApp\n    .provide(ID_INJECTION_KEY, {\"prefix\":1024,\"current\":0})\n    .provide(ZINDEX_INJECTION_KEY, {\"current\":0});\n})\n","import { VueDraggableNext } from 'vue-draggable-next'\r\nexport default defineNuxtPlugin((nuxtApp) => {\r\n    nuxtApp.vueApp.component('draggable', VueDraggableNext);\r\n})\r\n","\r\nimport https from '../service/Base/axiousInstance'\r\nlet apiFactory;\r\n// This plugin provides an object `apiFactory` which contains all the api classes (e.g. `ExampleApi`)\r\n// that can be used to make API requests to the server. This plugin is used to create these classes\r\n// and make them available to the rest of the application.\r\n\r\n// The function passed to `defineNuxtPlugin` is called by Nuxt when it creates the Nuxt context\r\n// (i.e. when the Nuxt app is being started or reloaded). This function has access to the Nuxt\r\n// context, which includes the `$axios` property, which is an instance of Axios that has\r\n// been configured to work with Nuxt. We use this instance to create instances of our API classes.\r\n\r\n// We create an Factory` with properties for each of our API classes, and assign it\r\n// to the exported `apiFactory` variable. We also export the `apiFactory` variable so that it can\r\n// be imported and used by other parts of the applobject `apiication.\r\n\r\n// The name `apiFactory` was chosen because it makes it clear what this plugin does, and\r\n// it's easy to understand how to use it. The name could be improved, but it's a start!\r\nexport default defineNuxtPlugin(() => {}) \r\n\r\n\r\n\r\n","import axios from 'axios';\r\nimport { useToast } from 'vue-toast-notification';\r\nimport 'vue-toast-notification/dist/theme-bootstrap.css';\r\nimport https from '~/service/Base/axiousInstance';\r\nimport { ErrorMessage } from '../.nuxt/components';\r\nimport {\r\n    formatTime,\r\n    formatDate,\r\n    getKeyByValue,\r\n    splitArrayByStatusCV,\r\n    capitalize,\r\n    getVietNameseText,\r\n    getAllowedUpdateStatus,\r\n    checkIfAllowedUpdateStatus,\r\n} from '~/assets/js/helper.js';\r\nexport default defineNuxtPlugin((nuxtApp) => {\r\n    const toast = useToast();\r\n\r\n\r\n    // //     Request interceptor\r\n    // https.interceptors.request.use(\r\n    //     (config) => {\r\n    //         //Do something before request is sent\r\n    //         config.headers.Authorization = `Bearer ${typeof localStorage !== 'undefined' ? localStorage.getItem('token') : ''}`;\r\n    //         return config;\r\n    //     },\r\n    //     (error) => {\r\n    //         const isAdminPage = nuxtApp.isAdminPage;\r\n    //         //Handle request error\r\n    //         if (isAdminPage) {\r\n    //             toast.error(error.message);\r\n    //         }\r\n    //         const status = error.response ? error.response.status : null;\r\n\r\n    //         if (status === 401 || status === 400) {\r\n    //             return axios(error.config);\r\n    //         } else if (status === 404) {\r\n    //         } else {\r\n    //         }\r\n    //         return Promise.reject(error);\r\n    //     },\r\n    // );\r\n\r\n    // //  Response interceptor\r\n    // https.interceptors.response.use(\r\n    //     (response) => {\r\n    //         const isAdminPage = nuxtApp.isAdminPage;\r\n    //         if (isAdminPage && response.config.method != 'get' && response.data.message) {\r\n    //             toast.success(response.data.message);\r\n    //         }\r\n    //         return response;\r\n    //     },\r\n    //     (error) => {\r\n    //         const isAdminPage = nuxtApp.isAdminPage;\r\n    //         var messageError = '';\r\n\r\n    //         //{field: 'Trng', message: 'Trng phi l bt buc!'} hoc {message: 'Trng phi l bt buc!'} hoc {status: 400,message: 'Trng phi l mt s hp l!'}\r\n    //         if (Array.isArray(error.response.data)) {\r\n    //             const errorMessageCombine = error.response.data.reduce(\r\n    //                 (accumulator: any, currentValue: any) => {\r\n    //                     return accumulator + currentValue.message;\r\n    //                 },\r\n    //                 messageError,\r\n    //             );\r\n    //             if (isAdminPage) {\r\n    //                 toast.error('Response error: <br/>' + errorMessageCombine);\r\n    //             }\r\n    //         } else if (error.response || error.response.data || error.response.data.message) {\r\n    //             if (isAdminPage) {\r\n    //                 toast.error(error.response.data);\r\n    //             }\r\n    //         }\r\n\r\n    //         return error.response;\r\n    //     },\r\n    // );\r\n\r\n    //Provide the toast instance to your Vue components\r\n    nuxtApp.provide('toast', toast);\r\n});\r\n\r\n\r\n","/**\n  * vee-validate v4.12.6\n  * (c) 2024 Abdelrahman Awad\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, warn as warn$1, computed, toValue, ref, watch, nextTick, unref, isRef, reactive, onUnmounted, onMounted, provide, onBeforeUnmount, defineComponent, toRef, resolveDynamicComponent, h, readonly, watchEffect, shallowRef } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nfunction isCallable(fn) {\n    return typeof fn === 'function';\n}\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nconst isObject = (obj) => obj !== null && !!obj && typeof obj === 'object' && !Array.isArray(obj);\nfunction isIndex(value) {\n    return Number(value) >= 0;\n}\nfunction toNumber(value) {\n    const n = parseFloat(value);\n    return isNaN(n) ? value : n;\n}\nfunction isObjectLike(value) {\n    return typeof value === 'object' && value !== null;\n}\nfunction getTag(value) {\n    if (value == null) {\n        return value === undefined ? '[object Undefined]' : '[object Null]';\n    }\n    return Object.prototype.toString.call(value);\n}\n// Reference: https://github.com/lodash/lodash/blob/master/isPlainObject.js\nfunction isPlainObject(value) {\n    if (!isObjectLike(value) || getTag(value) !== '[object Object]') {\n        return false;\n    }\n    if (Object.getPrototypeOf(value) === null) {\n        return true;\n    }\n    let proto = value;\n    while (Object.getPrototypeOf(proto) !== null) {\n        proto = Object.getPrototypeOf(proto);\n    }\n    return Object.getPrototypeOf(value) === proto;\n}\nfunction merge(target, source) {\n    Object.keys(source).forEach(key => {\n        if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n            if (!target[key]) {\n                target[key] = {};\n            }\n            merge(target[key], source[key]);\n            return;\n        }\n        target[key] = source[key];\n    });\n    return target;\n}\n/**\n * Constructs a path with dot paths for arrays to use brackets to be compatible with vee-validate path syntax\n */\nfunction normalizeFormPath(path) {\n    const pathArr = path.split('.');\n    if (!pathArr.length) {\n        return '';\n    }\n    let fullPath = String(pathArr[0]);\n    for (let i = 1; i < pathArr.length; i++) {\n        if (isIndex(pathArr[i])) {\n            fullPath += `[${pathArr[i]}]`;\n            continue;\n        }\n        fullPath += `.${pathArr[i]}`;\n    }\n    return fullPath;\n}\n\nconst RULES = {};\n/**\n * Adds a custom validator to the list of validation rules.\n */\nfunction defineRule(id, validator) {\n    // makes sure new rules are properly formatted.\n    guardExtend(id, validator);\n    RULES[id] = validator;\n}\n/**\n * Gets an already defined rule\n */\nfunction resolveRule(id) {\n    return RULES[id];\n}\n/**\n * Guards from extension violations.\n */\nfunction guardExtend(id, validator) {\n    if (isCallable(validator)) {\n        return;\n    }\n    throw new Error(`Extension Error: The validator '${id}' must be a function.`);\n}\n\nfunction set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nfunction klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n\nconst FormContextKey = Symbol('vee-validate-form');\nconst FieldContextKey = Symbol('vee-validate-field-instance');\nconst IS_ABSENT = Symbol('Default empty value');\n\nconst isClient = typeof window !== 'undefined';\nfunction isLocator(value) {\n    return isCallable(value) && !!value.__locatorRef;\n}\nfunction isTypedSchema(value) {\n    return !!value && isCallable(value.parse) && value.__type === 'VVTypedSchema';\n}\nfunction isYupValidator(value) {\n    return !!value && isCallable(value.validate);\n}\nfunction hasCheckedAttr(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nfunction isContainerValue(value) {\n    return isObject(value) || Array.isArray(value);\n}\n/**\n * True if the value is an empty object or array\n */\nfunction isEmptyContainer(value) {\n    if (Array.isArray(value)) {\n        return value.length === 0;\n    }\n    return isObject(value) && Object.keys(value).length === 0;\n}\n/**\n * Checks if the path opted out of nested fields using `[fieldName]` syntax\n */\nfunction isNotNestedPath(path) {\n    return /^\\[.+\\]$/i.test(path);\n}\n/**\n * Checks if an element is a native HTML5 multi-select input element\n */\nfunction isNativeMultiSelect(el) {\n    return isNativeSelect(el) && el.multiple;\n}\n/**\n * Checks if an element is a native HTML5 select input element\n */\nfunction isNativeSelect(el) {\n    return el.tagName === 'SELECT';\n}\n/**\n * Checks if a tag name with attrs object will render a native multi-select element\n */\nfunction isNativeMultiSelectNode(tag, attrs) {\n    // The falsy value array is the values that Vue won't add the `multiple` prop if it has one of these values\n    const hasTruthyBindingValue = ![false, null, undefined, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);\n    return tag === 'select' && 'multiple' in attrs && hasTruthyBindingValue;\n}\n/**\n * Checks if a node should have a `:value` binding or not\n *\n * These nodes should not have a value binding\n * For files, because they are not reactive\n * For multi-selects because the value binding will reset the value\n */\nfunction shouldHaveValueBinding(tag, attrs) {\n    return !isNativeMultiSelectNode(tag, attrs) && attrs.type !== 'file' && !hasCheckedAttr(attrs.type);\n}\nfunction isFormSubmitEvent(evt) {\n    return isEvent(evt) && evt.target && 'submit' in evt.target;\n}\nfunction isEvent(evt) {\n    if (!evt) {\n        return false;\n    }\n    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\n        return true;\n    }\n    // this is for IE and Cypress #3161\n    /* istanbul ignore next */\n    if (evt && evt.srcElement) {\n        return true;\n    }\n    return false;\n}\nfunction isPropPresent(obj, prop) {\n    return prop in obj && obj[prop] !== IS_ABSENT;\n}\n/**\n * Compares if two values are the same borrowed from:\n * https://github.com/epoberezkin/fast-deep-equal\n * We added a case for file matching since `Object.keys` doesn't work with Files.\n * */\nfunction isEqual(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n        if (a.constructor !== b.constructor)\n            return false;\n        // eslint-disable-next-line no-var\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            // eslint-disable-next-line eqeqeq\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!isEqual(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (a instanceof Map && b instanceof Map) {\n            if (a.size !== b.size)\n                return false;\n            for (i of a.entries())\n                if (!b.has(i[0]))\n                    return false;\n            for (i of a.entries())\n                if (!isEqual(i[1], b.get(i[0])))\n                    return false;\n            return true;\n        }\n        // We added this part for file comparison, arguably a little naive but should work for most cases.\n        // #3911\n        if (isFile(a) && isFile(b)) {\n            if (a.size !== b.size)\n                return false;\n            if (a.name !== b.name)\n                return false;\n            if (a.lastModified !== b.lastModified)\n                return false;\n            if (a.type !== b.type)\n                return false;\n            return true;\n        }\n        if (a instanceof Set && b instanceof Set) {\n            if (a.size !== b.size)\n                return false;\n            for (i of a.entries())\n                if (!b.has(i[0]))\n                    return false;\n            return true;\n        }\n        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n            length = a.length;\n            // eslint-disable-next-line eqeqeq\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (a[i] !== b[i])\n                    return false;\n            return true;\n        }\n        if (a.constructor === RegExp)\n            return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf)\n            return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString)\n            return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        for (i = length; i-- !== 0;) {\n            // eslint-disable-next-line no-var\n            var key = keys[i];\n            if (!isEqual(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    // eslint-disable-next-line no-self-compare\n    return a !== a && b !== b;\n}\nfunction isFile(a) {\n    if (!isClient) {\n        return false;\n    }\n    return a instanceof File;\n}\n\nfunction cleanupNonNestedPath(path) {\n    if (isNotNestedPath(path)) {\n        return path.replace(/\\[|\\]/gi, '');\n    }\n    return path;\n}\nfunction getFromPath(object, path, fallback) {\n    if (!object) {\n        return fallback;\n    }\n    if (isNotNestedPath(path)) {\n        return object[cleanupNonNestedPath(path)];\n    }\n    const resolvedValue = (path || '')\n        .split(/\\.|\\[(\\d+)\\]/)\n        .filter(Boolean)\n        .reduce((acc, propKey) => {\n        if (isContainerValue(acc) && propKey in acc) {\n            return acc[propKey];\n        }\n        return fallback;\n    }, object);\n    return resolvedValue;\n}\n/**\n * Sets a nested property value in a path, creates the path properties if it doesn't exist\n */\nfunction setInPath(object, path, value) {\n    if (isNotNestedPath(path)) {\n        object[cleanupNonNestedPath(path)] = value;\n        return;\n    }\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\n    let acc = object;\n    for (let i = 0; i < keys.length; i++) {\n        // Last key, set it\n        if (i === keys.length - 1) {\n            acc[keys[i]] = value;\n            return;\n        }\n        // Key does not exist, create a container for it\n        if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {\n            // container can be either an object or an array depending on the next key if it exists\n            acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};\n        }\n        acc = acc[keys[i]];\n    }\n}\nfunction unset(object, key) {\n    if (Array.isArray(object) && isIndex(key)) {\n        object.splice(Number(key), 1);\n        return;\n    }\n    if (isObject(object)) {\n        delete object[key];\n    }\n}\n/**\n * Removes a nested property from object\n */\nfunction unsetPath(object, path) {\n    if (isNotNestedPath(path)) {\n        delete object[cleanupNonNestedPath(path)];\n        return;\n    }\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\n    let acc = object;\n    for (let i = 0; i < keys.length; i++) {\n        // Last key, unset it\n        if (i === keys.length - 1) {\n            unset(acc, keys[i]);\n            break;\n        }\n        // Key does not exist, exit\n        if (!(keys[i] in acc) || isNullOrUndefined(acc[keys[i]])) {\n            break;\n        }\n        acc = acc[keys[i]];\n    }\n    const pathValues = keys.map((_, idx) => {\n        return getFromPath(object, keys.slice(0, idx).join('.'));\n    });\n    for (let i = pathValues.length - 1; i >= 0; i--) {\n        if (!isEmptyContainer(pathValues[i])) {\n            continue;\n        }\n        if (i === 0) {\n            unset(object, keys[0]);\n            continue;\n        }\n        unset(pathValues[i - 1], keys[i - 1]);\n    }\n}\n/**\n * A typed version of Object.keys\n */\nfunction keysOf(record) {\n    return Object.keys(record);\n}\n// Uses same component provide as its own injections\n// Due to changes in https://github.com/vuejs/vue-next/pull/2424\nfunction injectWithSelf(symbol, def = undefined) {\n    const vm = getCurrentInstance();\n    return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject(symbol, def);\n}\nfunction warn(message) {\n    warn$1(`[vee-validate]: ${message}`);\n}\nfunction resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {\n    if (Array.isArray(currentValue)) {\n        const newVal = [...currentValue];\n        // Use isEqual since checked object values can possibly fail the equality check #3883\n        const idx = newVal.findIndex(v => isEqual(v, checkedValue));\n        idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);\n        return newVal;\n    }\n    return isEqual(currentValue, checkedValue) ? uncheckedValue : checkedValue;\n}\n/**\n * Creates a throttled function that only invokes the provided function (`func`) at most once per within a given number of milliseconds\n * (`limit`)\n */\nfunction throttle(func, limit) {\n    let inThrottle;\n    let lastResult;\n    return function (...args) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const context = this;\n        if (!inThrottle) {\n            inThrottle = true;\n            setTimeout(() => (inThrottle = false), limit);\n            lastResult = func.apply(context, args);\n        }\n        return lastResult;\n    };\n}\nfunction debounceAsync(inner, ms = 0) {\n    let timer = null;\n    let resolves = [];\n    return function (...args) {\n        // Run the function after a certain amount of time\n        if (timer) {\n            clearTimeout(timer);\n        }\n        // @ts-expect-error timer is a number\n        timer = setTimeout(() => {\n            // Get the result of the inner function, then apply it to the resolve function of\n            // each promise that has been created since the last time the inner function was run\n            const result = inner(...args);\n            resolves.forEach(r => r(result));\n            resolves = [];\n        }, ms);\n        return new Promise(resolve => resolves.push(resolve));\n    };\n}\nfunction applyModelModifiers(value, modifiers) {\n    if (!isObject(modifiers)) {\n        return value;\n    }\n    if (modifiers.number) {\n        return toNumber(value);\n    }\n    return value;\n}\nfunction withLatest(fn, onDone) {\n    let latestRun;\n    return async function runLatest(...args) {\n        const pending = fn(...args);\n        latestRun = pending;\n        const result = await pending;\n        if (pending !== latestRun) {\n            return result;\n        }\n        latestRun = undefined;\n        return onDone(result, args);\n    };\n}\nfunction computedDeep({ get, set }) {\n    const baseRef = ref(klona(get()));\n    watch(get, newValue => {\n        if (isEqual(newValue, baseRef.value)) {\n            return;\n        }\n        baseRef.value = klona(newValue);\n    }, {\n        deep: true,\n    });\n    watch(baseRef, newValue => {\n        if (isEqual(newValue, get())) {\n            return;\n        }\n        set(klona(newValue));\n    }, {\n        deep: true,\n    });\n    return baseRef;\n}\nfunction normalizeErrorItem(message) {\n    return Array.isArray(message) ? message : message ? [message] : [];\n}\nfunction resolveFieldOrPathState(path) {\n    const form = injectWithSelf(FormContextKey);\n    const state = path ? computed(() => form === null || form === void 0 ? void 0 : form.getPathState(toValue(path))) : undefined;\n    const field = path ? undefined : inject(FieldContextKey);\n    if (!field && !(state === null || state === void 0 ? void 0 : state.value)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`field with name ${toValue(path)} was not found`);\n        }\n    }\n    return state || field;\n}\nfunction omit(obj, keys) {\n    const target = {};\n    for (const key in obj) {\n        if (!keys.includes(key)) {\n            target[key] = obj[key];\n        }\n    }\n    return target;\n}\nfunction debounceNextTick(inner) {\n    let lastTick = null;\n    let resolves = [];\n    return function (...args) {\n        // Run the function after a certain amount of time\n        const thisTick = nextTick(() => {\n            if (lastTick !== thisTick) {\n                return;\n            }\n            // Get the result of the inner function, then apply it to the resolve function of\n            // each promise that has been created since the last time the inner function was run\n            const result = inner(...args);\n            resolves.forEach(r => r(result));\n            resolves = [];\n            lastTick = null;\n        });\n        lastTick = thisTick;\n        return new Promise(resolve => resolves.push(resolve));\n    };\n}\n\nfunction normalizeChildren(tag, context, slotProps) {\n    if (!context.slots.default) {\n        return context.slots.default;\n    }\n    if (typeof tag === 'string' || !tag) {\n        return context.slots.default(slotProps());\n    }\n    return {\n        default: () => { var _a, _b; return (_b = (_a = context.slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, slotProps()); },\n    };\n}\n/**\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\n */\nfunction getBoundValue(el) {\n    if (hasValueBinding(el)) {\n        return el._value;\n    }\n    return undefined;\n}\n/**\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\n */\nfunction hasValueBinding(el) {\n    return '_value' in el;\n}\n\nfunction parseInputValue(el) {\n    if (el.type === 'number') {\n        return Number.isNaN(el.valueAsNumber) ? el.value : el.valueAsNumber;\n    }\n    if (el.type === 'range') {\n        return Number.isNaN(el.valueAsNumber) ? el.value : el.valueAsNumber;\n    }\n    return el.value;\n}\nfunction normalizeEventValue(value) {\n    if (!isEvent(value)) {\n        return value;\n    }\n    const input = value.target;\n    // Vue sets the current bound value on `_value` prop\n    // for checkboxes it it should fetch the value binding type as is (boolean instead of string)\n    if (hasCheckedAttr(input.type) && hasValueBinding(input)) {\n        return getBoundValue(input);\n    }\n    if (input.type === 'file' && input.files) {\n        const files = Array.from(input.files);\n        return input.multiple ? files : files[0];\n    }\n    if (isNativeMultiSelect(input)) {\n        return Array.from(input.options)\n            .filter(opt => opt.selected && !opt.disabled)\n            .map(getBoundValue);\n    }\n    // makes sure we get the actual `option` bound value\n    // #3440\n    if (isNativeSelect(input)) {\n        const selectedOption = Array.from(input.options).find(opt => opt.selected);\n        return selectedOption ? getBoundValue(selectedOption) : input.value;\n    }\n    return parseInputValue(input);\n}\n\n/**\n * Normalizes the given rules expression.\n */\nfunction normalizeRules(rules) {\n    const acc = {};\n    Object.defineProperty(acc, '_$$isNormalized', {\n        value: true,\n        writable: false,\n        enumerable: false,\n        configurable: false,\n    });\n    if (!rules) {\n        return acc;\n    }\n    // Object is already normalized, skip.\n    if (isObject(rules) && rules._$$isNormalized) {\n        return rules;\n    }\n    if (isObject(rules)) {\n        return Object.keys(rules).reduce((prev, curr) => {\n            const params = normalizeParams(rules[curr]);\n            if (rules[curr] !== false) {\n                prev[curr] = buildParams(params);\n            }\n            return prev;\n        }, acc);\n    }\n    /* istanbul ignore if */\n    if (typeof rules !== 'string') {\n        return acc;\n    }\n    return rules.split('|').reduce((prev, rule) => {\n        const parsedRule = parseRule(rule);\n        if (!parsedRule.name) {\n            return prev;\n        }\n        prev[parsedRule.name] = buildParams(parsedRule.params);\n        return prev;\n    }, acc);\n}\n/**\n * Normalizes a rule param.\n */\nfunction normalizeParams(params) {\n    if (params === true) {\n        return [];\n    }\n    if (Array.isArray(params)) {\n        return params;\n    }\n    if (isObject(params)) {\n        return params;\n    }\n    return [params];\n}\nfunction buildParams(provided) {\n    const mapValueToLocator = (value) => {\n        // A target param using interpolation\n        if (typeof value === 'string' && value[0] === '@') {\n            return createLocator(value.slice(1));\n        }\n        return value;\n    };\n    if (Array.isArray(provided)) {\n        return provided.map(mapValueToLocator);\n    }\n    // #3073\n    if (provided instanceof RegExp) {\n        return [provided];\n    }\n    return Object.keys(provided).reduce((prev, key) => {\n        prev[key] = mapValueToLocator(provided[key]);\n        return prev;\n    }, {});\n}\n/**\n * Parses a rule string expression.\n */\nconst parseRule = (rule) => {\n    let params = [];\n    const name = rule.split(':')[0];\n    if (rule.includes(':')) {\n        params = rule.split(':').slice(1).join(':').split(',');\n    }\n    return { name, params };\n};\nfunction createLocator(value) {\n    const locator = (crossTable) => {\n        const val = getFromPath(crossTable, value) || crossTable[value];\n        return val;\n    };\n    locator.__locatorRef = value;\n    return locator;\n}\nfunction extractLocators(params) {\n    if (Array.isArray(params)) {\n        return params.filter(isLocator);\n    }\n    return keysOf(params)\n        .filter(key => isLocator(params[key]))\n        .map(key => params[key]);\n}\n\nconst DEFAULT_CONFIG = {\n    generateMessage: ({ field }) => `${field} is not valid.`,\n    bails: true,\n    validateOnBlur: true,\n    validateOnChange: true,\n    validateOnInput: false,\n    validateOnModelUpdate: true,\n};\nlet currentConfig = Object.assign({}, DEFAULT_CONFIG);\nconst getConfig = () => currentConfig;\nconst setConfig = (newConf) => {\n    currentConfig = Object.assign(Object.assign({}, currentConfig), newConf);\n};\nconst configure = setConfig;\n\n/**\n * Validates a value against the rules.\n */\nasync function validate(value, rules, options = {}) {\n    const shouldBail = options === null || options === void 0 ? void 0 : options.bails;\n    const field = {\n        name: (options === null || options === void 0 ? void 0 : options.name) || '{field}',\n        rules,\n        label: options === null || options === void 0 ? void 0 : options.label,\n        bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,\n        formData: (options === null || options === void 0 ? void 0 : options.values) || {},\n    };\n    const result = await _validate(field, value);\n    const errors = result.errors;\n    return {\n        errors,\n        valid: !errors.length,\n    };\n}\n/**\n * Starts the validation process.\n */\nasync function _validate(field, value) {\n    if (isTypedSchema(field.rules) || isYupValidator(field.rules)) {\n        return validateFieldWithTypedSchema(value, field.rules);\n    }\n    // if a generic function or chain of generic functions\n    if (isCallable(field.rules) || Array.isArray(field.rules)) {\n        const ctx = {\n            field: field.label || field.name,\n            name: field.name,\n            label: field.label,\n            form: field.formData,\n            value,\n        };\n        // Normalize the pipeline\n        const pipeline = Array.isArray(field.rules) ? field.rules : [field.rules];\n        const length = pipeline.length;\n        const errors = [];\n        for (let i = 0; i < length; i++) {\n            const rule = pipeline[i];\n            const result = await rule(value, ctx);\n            const isValid = typeof result !== 'string' && !Array.isArray(result) && result;\n            if (isValid) {\n                continue;\n            }\n            if (Array.isArray(result)) {\n                errors.push(...result);\n            }\n            else {\n                const message = typeof result === 'string' ? result : _generateFieldError(ctx);\n                errors.push(message);\n            }\n            if (field.bails) {\n                return {\n                    errors,\n                };\n            }\n        }\n        return {\n            errors,\n        };\n    }\n    const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });\n    const errors = [];\n    const rulesKeys = Object.keys(normalizedContext.rules);\n    const length = rulesKeys.length;\n    for (let i = 0; i < length; i++) {\n        const rule = rulesKeys[i];\n        const result = await _test(normalizedContext, value, {\n            name: rule,\n            params: normalizedContext.rules[rule],\n        });\n        if (result.error) {\n            errors.push(result.error);\n            if (field.bails) {\n                return {\n                    errors,\n                };\n            }\n        }\n    }\n    return {\n        errors,\n    };\n}\nfunction isYupError(err) {\n    return !!err && err.name === 'ValidationError';\n}\nfunction yupToTypedSchema(yupSchema) {\n    const schema = {\n        __type: 'VVTypedSchema',\n        async parse(values) {\n            var _a;\n            try {\n                const output = await yupSchema.validate(values, { abortEarly: false });\n                return {\n                    output,\n                    errors: [],\n                };\n            }\n            catch (err) {\n                // Yup errors have a name prop one them.\n                // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\n                if (!isYupError(err)) {\n                    throw err;\n                }\n                if (!((_a = err.inner) === null || _a === void 0 ? void 0 : _a.length) && err.errors.length) {\n                    return { errors: [{ path: err.path, errors: err.errors }] };\n                }\n                const errors = err.inner.reduce((acc, curr) => {\n                    const path = curr.path || '';\n                    if (!acc[path]) {\n                        acc[path] = { errors: [], path };\n                    }\n                    acc[path].errors.push(...curr.errors);\n                    return acc;\n                }, {});\n                return { errors: Object.values(errors) };\n            }\n        },\n    };\n    return schema;\n}\n/**\n * Handles yup validation\n */\nasync function validateFieldWithTypedSchema(value, schema) {\n    const typedSchema = isTypedSchema(schema) ? schema : yupToTypedSchema(schema);\n    const result = await typedSchema.parse(value);\n    const messages = [];\n    for (const error of result.errors) {\n        if (error.errors.length) {\n            messages.push(...error.errors);\n        }\n    }\n    return {\n        errors: messages,\n    };\n}\n/**\n * Tests a single input value against a rule.\n */\nasync function _test(field, value, rule) {\n    const validator = resolveRule(rule.name);\n    if (!validator) {\n        throw new Error(`No such validator '${rule.name}' exists.`);\n    }\n    const params = fillTargetValues(rule.params, field.formData);\n    const ctx = {\n        field: field.label || field.name,\n        name: field.name,\n        label: field.label,\n        value,\n        form: field.formData,\n        rule: Object.assign(Object.assign({}, rule), { params }),\n    };\n    const result = await validator(value, params, ctx);\n    if (typeof result === 'string') {\n        return {\n            error: result,\n        };\n    }\n    return {\n        error: result ? undefined : _generateFieldError(ctx),\n    };\n}\n/**\n * Generates error messages.\n */\nfunction _generateFieldError(fieldCtx) {\n    const message = getConfig().generateMessage;\n    if (!message) {\n        return 'Field is invalid';\n    }\n    return message(fieldCtx);\n}\nfunction fillTargetValues(params, crossTable) {\n    const normalize = (value) => {\n        if (isLocator(value)) {\n            return value(crossTable);\n        }\n        return value;\n    };\n    if (Array.isArray(params)) {\n        return params.map(normalize);\n    }\n    return Object.keys(params).reduce((acc, param) => {\n        acc[param] = normalize(params[param]);\n        return acc;\n    }, {});\n}\nasync function validateTypedSchema(schema, values) {\n    const typedSchema = isTypedSchema(schema) ? schema : yupToTypedSchema(schema);\n    const validationResult = await typedSchema.parse(klona(values));\n    const results = {};\n    const errors = {};\n    for (const error of validationResult.errors) {\n        const messages = error.errors;\n        // Fixes issue with path mapping with Yup 1.0 including quotes around array indices\n        const path = (error.path || '').replace(/\\[\"(\\d+)\"\\]/g, (_, m) => {\n            return `[${m}]`;\n        });\n        results[path] = { valid: !messages.length, errors: messages };\n        if (messages.length) {\n            errors[path] = messages[0];\n        }\n    }\n    return {\n        valid: !validationResult.errors.length,\n        results,\n        errors,\n        values: validationResult.value,\n    };\n}\nasync function validateObjectSchema(schema, values, opts) {\n    const paths = keysOf(schema);\n    const validations = paths.map(async (path) => {\n        var _a, _b, _c;\n        const strings = (_a = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a === void 0 ? void 0 : _a[path];\n        const fieldResult = await validate(getFromPath(values, path), schema[path], {\n            name: (strings === null || strings === void 0 ? void 0 : strings.name) || path,\n            label: strings === null || strings === void 0 ? void 0 : strings.label,\n            values: values,\n            bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true,\n        });\n        return Object.assign(Object.assign({}, fieldResult), { path });\n    });\n    let isAllValid = true;\n    const validationResults = await Promise.all(validations);\n    const results = {};\n    const errors = {};\n    for (const result of validationResults) {\n        results[result.path] = {\n            valid: result.valid,\n            errors: result.errors,\n        };\n        if (!result.valid) {\n            isAllValid = false;\n            errors[result.path] = result.errors[0];\n        }\n    }\n    return {\n        valid: isAllValid,\n        results,\n        errors,\n    };\n}\n\nlet ID_COUNTER = 0;\nfunction useFieldState(path, init) {\n    const { value, initialValue, setInitialValue } = _useFieldValue(path, init.modelValue, init.form);\n    if (!init.form) {\n        const { errors, setErrors } = createFieldErrors();\n        const id = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;\n        const meta = createFieldMeta(value, initialValue, errors, init.schema);\n        function setState(state) {\n            var _a;\n            if ('value' in state) {\n                value.value = state.value;\n            }\n            if ('errors' in state) {\n                setErrors(state.errors);\n            }\n            if ('touched' in state) {\n                meta.touched = (_a = state.touched) !== null && _a !== void 0 ? _a : meta.touched;\n            }\n            if ('initialValue' in state) {\n                setInitialValue(state.initialValue);\n            }\n        }\n        return {\n            id,\n            path,\n            value,\n            initialValue,\n            meta,\n            flags: { pendingUnmount: { [id]: false }, pendingReset: false },\n            errors,\n            setState,\n        };\n    }\n    const state = init.form.createPathState(path, {\n        bails: init.bails,\n        label: init.label,\n        type: init.type,\n        validate: init.validate,\n        schema: init.schema,\n    });\n    const errors = computed(() => state.errors);\n    function setState(state) {\n        var _a, _b, _c;\n        if ('value' in state) {\n            value.value = state.value;\n        }\n        if ('errors' in state) {\n            (_a = init.form) === null || _a === void 0 ? void 0 : _a.setFieldError(unref(path), state.errors);\n        }\n        if ('touched' in state) {\n            (_b = init.form) === null || _b === void 0 ? void 0 : _b.setFieldTouched(unref(path), (_c = state.touched) !== null && _c !== void 0 ? _c : false);\n        }\n        if ('initialValue' in state) {\n            setInitialValue(state.initialValue);\n        }\n    }\n    return {\n        id: Array.isArray(state.id) ? state.id[state.id.length - 1] : state.id,\n        path,\n        value,\n        errors,\n        meta: state,\n        initialValue,\n        flags: state.__flags,\n        setState,\n    };\n}\n/**\n * Creates the field value and resolves the initial value\n */\nfunction _useFieldValue(path, modelValue, form) {\n    const modelRef = ref(unref(modelValue));\n    function resolveInitialValue() {\n        if (!form) {\n            return unref(modelRef);\n        }\n        return getFromPath(form.initialValues.value, unref(path), unref(modelRef));\n    }\n    function setInitialValue(value) {\n        if (!form) {\n            modelRef.value = value;\n            return;\n        }\n        form.setFieldInitialValue(unref(path), value, true);\n    }\n    const initialValue = computed(resolveInitialValue);\n    // if no form is associated, use a regular ref.\n    if (!form) {\n        const value = ref(resolveInitialValue());\n        return {\n            value,\n            initialValue,\n            setInitialValue,\n        };\n    }\n    // to set the initial value, first check if there is a current value, if there is then use it.\n    // otherwise use the configured initial value if it exists.\n    // prioritize model value over form values\n    // #3429\n    const currentValue = resolveModelValue(modelValue, form, initialValue, path);\n    form.stageInitialValue(unref(path), currentValue, true);\n    // otherwise use a computed setter that triggers the `setFieldValue`\n    const value = computed({\n        get() {\n            return getFromPath(form.values, unref(path));\n        },\n        set(newVal) {\n            form.setFieldValue(unref(path), newVal, false);\n        },\n    });\n    return {\n        value,\n        initialValue,\n        setInitialValue,\n    };\n}\n/*\n  to set the initial value, first check if there is a current value, if there is then use it.\n  otherwise use the configured initial value if it exists.\n  prioritize model value over form values\n  #3429\n*/\nfunction resolveModelValue(modelValue, form, initialValue, path) {\n    if (isRef(modelValue)) {\n        return unref(modelValue);\n    }\n    if (modelValue !== undefined) {\n        return modelValue;\n    }\n    return getFromPath(form.values, unref(path), unref(initialValue));\n}\n/**\n * Creates meta flags state and some associated effects with them\n */\nfunction createFieldMeta(currentValue, initialValue, errors, schema) {\n    var _a, _b;\n    const isRequired = (_b = (_a = schema === null || schema === void 0 ? void 0 : schema.describe) === null || _a === void 0 ? void 0 : _a.call(schema).required) !== null && _b !== void 0 ? _b : false;\n    const meta = reactive({\n        touched: false,\n        pending: false,\n        valid: true,\n        required: isRequired,\n        validated: !!unref(errors).length,\n        initialValue: computed(() => unref(initialValue)),\n        dirty: computed(() => {\n            return !isEqual(unref(currentValue), unref(initialValue));\n        }),\n    });\n    watch(errors, value => {\n        meta.valid = !value.length;\n    }, {\n        immediate: true,\n        flush: 'sync',\n    });\n    return meta;\n}\n/**\n * Creates the error message state for the field state\n */\nfunction createFieldErrors() {\n    const errors = ref([]);\n    return {\n        errors,\n        setErrors: (messages) => {\n            errors.value = normalizeErrorItem(messages);\n        },\n    };\n}\n\nfunction installDevtoolsPlugin(app) {\n    if ((process.env.NODE_ENV !== 'production')) {\n        setupDevtoolsPlugin({\n            id: 'vee-validate-devtools-plugin',\n            label: 'VeeValidate Plugin',\n            packageName: 'vee-validate',\n            homepage: 'https://vee-validate.logaretm.com/v4',\n            app,\n            logo: 'https://vee-validate.logaretm.com/v4/logo.png',\n        }, setupApiHooks);\n    }\n}\nconst DEVTOOLS_FORMS = {};\nconst DEVTOOLS_FIELDS = {};\nlet API;\nconst refreshInspector = throttle(() => {\n    setTimeout(async () => {\n        await nextTick();\n        API === null || API === void 0 ? void 0 : API.sendInspectorState(INSPECTOR_ID);\n        API === null || API === void 0 ? void 0 : API.sendInspectorTree(INSPECTOR_ID);\n    }, 100);\n}, 100);\nfunction registerFormWithDevTools(form) {\n    const vm = getCurrentInstance();\n    if (!API) {\n        const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;\n        if (!app) {\n            return;\n        }\n        installDevtoolsPlugin(app);\n    }\n    DEVTOOLS_FORMS[form.formId] = Object.assign({}, form);\n    DEVTOOLS_FORMS[form.formId]._vm = vm;\n    onUnmounted(() => {\n        delete DEVTOOLS_FORMS[form.formId];\n        refreshInspector();\n    });\n    refreshInspector();\n}\nfunction registerSingleFieldWithDevtools(field) {\n    const vm = getCurrentInstance();\n    if (!API) {\n        const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;\n        if (!app) {\n            return;\n        }\n        installDevtoolsPlugin(app);\n    }\n    DEVTOOLS_FIELDS[field.id] = Object.assign({}, field);\n    DEVTOOLS_FIELDS[field.id]._vm = vm;\n    onUnmounted(() => {\n        delete DEVTOOLS_FIELDS[field.id];\n        refreshInspector();\n    });\n    refreshInspector();\n}\nconst INSPECTOR_ID = 'vee-validate-inspector';\nconst COLORS = {\n    error: 0xbd4b4b,\n    success: 0x06d77b,\n    unknown: 0x54436b,\n    white: 0xffffff,\n    black: 0x000000,\n    blue: 0x035397,\n    purple: 0xb980f0,\n    orange: 0xf5a962,\n    gray: 0xbbbfca,\n};\nlet SELECTED_NODE = null;\nfunction setupApiHooks(api) {\n    API = api;\n    api.addInspector({\n        id: INSPECTOR_ID,\n        icon: 'rule',\n        label: 'vee-validate',\n        noSelectionText: 'Select a vee-validate node to inspect',\n        actions: [\n            {\n                icon: 'done_outline',\n                tooltip: 'Validate selected item',\n                action: async () => {\n                    if (!SELECTED_NODE) {\n                        console.error('There is not a valid selected vee-validate node or component');\n                        return;\n                    }\n                    if (SELECTED_NODE.type === 'field') {\n                        await SELECTED_NODE.field.validate();\n                        return;\n                    }\n                    if (SELECTED_NODE.type === 'form') {\n                        await SELECTED_NODE.form.validate();\n                        return;\n                    }\n                    if (SELECTED_NODE.type === 'pathState') {\n                        await SELECTED_NODE.form.validateField(SELECTED_NODE.state.path);\n                    }\n                },\n            },\n            {\n                icon: 'delete_sweep',\n                tooltip: 'Clear validation state of the selected item',\n                action: () => {\n                    if (!SELECTED_NODE) {\n                        console.error('There is not a valid selected vee-validate node or component');\n                        return;\n                    }\n                    if (SELECTED_NODE.type === 'field') {\n                        SELECTED_NODE.field.resetField();\n                        return;\n                    }\n                    if (SELECTED_NODE.type === 'form') {\n                        SELECTED_NODE.form.resetForm();\n                    }\n                    if (SELECTED_NODE.type === 'pathState') {\n                        SELECTED_NODE.form.resetField(SELECTED_NODE.state.path);\n                    }\n                },\n            },\n        ],\n    });\n    api.on.getInspectorTree(payload => {\n        if (payload.inspectorId !== INSPECTOR_ID) {\n            return;\n        }\n        const forms = Object.values(DEVTOOLS_FORMS);\n        const fields = Object.values(DEVTOOLS_FIELDS);\n        payload.rootNodes = [\n            ...forms.map(mapFormForDevtoolsInspector),\n            ...fields.map(field => mapFieldForDevtoolsInspector(field)),\n        ];\n    });\n    api.on.getInspectorState((payload, ctx) => {\n        if (payload.inspectorId !== INSPECTOR_ID || ctx.currentTab !== `custom-inspector:${INSPECTOR_ID}`) {\n            return;\n        }\n        const { form, field, state, type } = decodeNodeId(payload.nodeId);\n        if (form && type === 'form') {\n            payload.state = buildFormState(form);\n            SELECTED_NODE = { type: 'form', form };\n            return;\n        }\n        if (state && type === 'pathState' && form) {\n            payload.state = buildFieldState(state);\n            SELECTED_NODE = { type: 'pathState', state, form };\n            return;\n        }\n        if (field && type === 'field') {\n            payload.state = buildFieldState({\n                errors: field.errors.value,\n                dirty: field.meta.dirty,\n                valid: field.meta.valid,\n                touched: field.meta.touched,\n                value: field.value.value,\n                initialValue: field.meta.initialValue,\n            });\n            SELECTED_NODE = { field, type: 'field' };\n            return;\n        }\n        SELECTED_NODE = null;\n    });\n}\nfunction mapFormForDevtoolsInspector(form) {\n    const { textColor, bgColor } = getValidityColors(form.meta.value.valid);\n    const formTreeNodes = {};\n    Object.values(form.getAllPathStates()).forEach(state => {\n        setInPath(formTreeNodes, unref(state.path), mapPathForDevtoolsInspector(state, form));\n    });\n    function buildFormTree(tree, path = []) {\n        const key = [...path].pop();\n        if ('id' in tree) {\n            return Object.assign(Object.assign({}, tree), { label: key || tree.label });\n        }\n        if (isObject(tree)) {\n            return {\n                id: `${path.join('.')}`,\n                label: key || '',\n                children: Object.keys(tree).map(key => buildFormTree(tree[key], [...path, key])),\n            };\n        }\n        if (Array.isArray(tree)) {\n            return {\n                id: `${path.join('.')}`,\n                label: `${key}[]`,\n                children: tree.map((c, idx) => buildFormTree(c, [...path, String(idx)])),\n            };\n        }\n        return { id: '', label: '', children: [] };\n    }\n    const { children } = buildFormTree(formTreeNodes);\n    return {\n        id: encodeNodeId(form),\n        label: 'Form',\n        children,\n        tags: [\n            {\n                label: 'Form',\n                textColor,\n                backgroundColor: bgColor,\n            },\n            {\n                label: `${form.getAllPathStates().length} fields`,\n                textColor: COLORS.white,\n                backgroundColor: COLORS.unknown,\n            },\n        ],\n    };\n}\nfunction mapPathForDevtoolsInspector(state, form) {\n    return {\n        id: encodeNodeId(form, state),\n        label: unref(state.path),\n        tags: getFieldNodeTags(state.multiple, state.fieldsCount, state.type, state.valid, form),\n    };\n}\nfunction mapFieldForDevtoolsInspector(field, form) {\n    return {\n        id: encodeNodeId(form, field),\n        label: unref(field.name),\n        tags: getFieldNodeTags(false, 1, field.type, field.meta.valid, form),\n    };\n}\nfunction getFieldNodeTags(multiple, fieldsCount, type, valid, form) {\n    const { textColor, bgColor } = getValidityColors(valid);\n    return [\n        multiple\n            ? undefined\n            : {\n                label: 'Field',\n                textColor,\n                backgroundColor: bgColor,\n            },\n        !form\n            ? {\n                label: 'Standalone',\n                textColor: COLORS.black,\n                backgroundColor: COLORS.gray,\n            }\n            : undefined,\n        type === 'checkbox'\n            ? {\n                label: 'Checkbox',\n                textColor: COLORS.white,\n                backgroundColor: COLORS.blue,\n            }\n            : undefined,\n        type === 'radio'\n            ? {\n                label: 'Radio',\n                textColor: COLORS.white,\n                backgroundColor: COLORS.purple,\n            }\n            : undefined,\n        multiple\n            ? {\n                label: 'Multiple',\n                textColor: COLORS.black,\n                backgroundColor: COLORS.orange,\n            }\n            : undefined,\n    ].filter(Boolean);\n}\nfunction encodeNodeId(form, stateOrField) {\n    const type = stateOrField ? ('path' in stateOrField ? 'pathState' : 'field') : 'form';\n    const fieldPath = stateOrField ? ('path' in stateOrField ? stateOrField === null || stateOrField === void 0 ? void 0 : stateOrField.path : unref(stateOrField === null || stateOrField === void 0 ? void 0 : stateOrField.name)) : '';\n    const idObject = { f: form === null || form === void 0 ? void 0 : form.formId, ff: fieldPath, type };\n    return btoa(encodeURIComponent(JSON.stringify(idObject)));\n}\nfunction decodeNodeId(nodeId) {\n    try {\n        const idObject = JSON.parse(decodeURIComponent(atob(nodeId)));\n        const form = DEVTOOLS_FORMS[idObject.f];\n        if (!form && idObject.ff) {\n            const field = DEVTOOLS_FIELDS[idObject.ff];\n            if (!field) {\n                return {};\n            }\n            return {\n                type: idObject.type,\n                field,\n            };\n        }\n        if (!form) {\n            return {};\n        }\n        const state = form.getPathState(idObject.ff);\n        return {\n            type: idObject.type,\n            form,\n            state,\n        };\n    }\n    catch (err) {\n        // console.error(`Devtools: [vee-validate] Failed to parse node id ${nodeId}`);\n    }\n    return {};\n}\nfunction buildFieldState(state) {\n    return {\n        'Field state': [\n            { key: 'errors', value: state.errors },\n            {\n                key: 'initialValue',\n                value: state.initialValue,\n            },\n            {\n                key: 'currentValue',\n                value: state.value,\n            },\n            {\n                key: 'touched',\n                value: state.touched,\n            },\n            {\n                key: 'dirty',\n                value: state.dirty,\n            },\n            {\n                key: 'valid',\n                value: state.valid,\n            },\n        ],\n    };\n}\nfunction buildFormState(form) {\n    const { errorBag, meta, values, isSubmitting, isValidating, submitCount } = form;\n    return {\n        'Form state': [\n            {\n                key: 'submitCount',\n                value: submitCount.value,\n            },\n            {\n                key: 'isSubmitting',\n                value: isSubmitting.value,\n            },\n            {\n                key: 'isValidating',\n                value: isValidating.value,\n            },\n            {\n                key: 'touched',\n                value: meta.value.touched,\n            },\n            {\n                key: 'dirty',\n                value: meta.value.dirty,\n            },\n            {\n                key: 'valid',\n                value: meta.value.valid,\n            },\n            {\n                key: 'initialValues',\n                value: meta.value.initialValues,\n            },\n            {\n                key: 'currentValues',\n                value: values,\n            },\n            {\n                key: 'errors',\n                value: keysOf(errorBag.value).reduce((acc, key) => {\n                    var _a;\n                    const message = (_a = errorBag.value[key]) === null || _a === void 0 ? void 0 : _a[0];\n                    if (message) {\n                        acc[key] = message;\n                    }\n                    return acc;\n                }, {}),\n            },\n        ],\n    };\n}\n/**\n * Resolves the tag color based on the form state\n */\nfunction getValidityColors(valid) {\n    return {\n        bgColor: valid ? COLORS.success : COLORS.error,\n        textColor: valid ? COLORS.black : COLORS.white,\n    };\n}\n\n/**\n * Creates a field composite.\n */\nfunction useField(path, rules, opts) {\n    if (hasCheckedAttr(opts === null || opts === void 0 ? void 0 : opts.type)) {\n        return useFieldWithChecked(path, rules, opts);\n    }\n    return _useField(path, rules, opts);\n}\nfunction _useField(path, rules, opts) {\n    const { initialValue: modelValue, validateOnMount, bails, type, checkedValue, label, validateOnValueUpdate, uncheckedValue, controlled, keepValueOnUnmount, syncVModel, form: controlForm, } = normalizeOptions(opts);\n    const injectedForm = controlled ? injectWithSelf(FormContextKey) : undefined;\n    const form = controlForm || injectedForm;\n    const name = computed(() => normalizeFormPath(toValue(path)));\n    const validator = computed(() => {\n        const schema = toValue(form === null || form === void 0 ? void 0 : form.schema);\n        if (schema) {\n            return undefined;\n        }\n        const rulesValue = unref(rules);\n        if (isYupValidator(rulesValue) ||\n            isTypedSchema(rulesValue) ||\n            isCallable(rulesValue) ||\n            Array.isArray(rulesValue)) {\n            return rulesValue;\n        }\n        return normalizeRules(rulesValue);\n    });\n    const { id, value, initialValue, meta, setState, errors, flags } = useFieldState(name, {\n        modelValue,\n        form,\n        bails,\n        label,\n        type,\n        validate: validator.value ? validate$1 : undefined,\n        schema: isTypedSchema(rules) ? rules : undefined,\n    });\n    const errorMessage = computed(() => errors.value[0]);\n    if (syncVModel) {\n        useVModel({\n            value,\n            prop: syncVModel,\n            handleChange,\n            shouldValidate: () => validateOnValueUpdate && !flags.pendingReset,\n        });\n    }\n    /**\n     * Handles common onBlur meta update\n     */\n    const handleBlur = (evt, shouldValidate = false) => {\n        meta.touched = true;\n        if (shouldValidate) {\n            validateWithStateMutation();\n        }\n    };\n    async function validateCurrentValue(mode) {\n        var _a, _b;\n        if (form === null || form === void 0 ? void 0 : form.validateSchema) {\n            const { results } = await form.validateSchema(mode);\n            return (_a = results[toValue(name)]) !== null && _a !== void 0 ? _a : { valid: true, errors: [] };\n        }\n        if (validator.value) {\n            return validate(value.value, validator.value, {\n                name: toValue(name),\n                label: toValue(label),\n                values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},\n                bails,\n            });\n        }\n        return { valid: true, errors: [] };\n    }\n    const validateWithStateMutation = withLatest(async () => {\n        meta.pending = true;\n        meta.validated = true;\n        return validateCurrentValue('validated-only');\n    }, result => {\n        if (flags.pendingUnmount[field.id]) {\n            return result;\n        }\n        setState({ errors: result.errors });\n        meta.pending = false;\n        meta.valid = result.valid;\n        return result;\n    });\n    const validateValidStateOnly = withLatest(async () => {\n        return validateCurrentValue('silent');\n    }, result => {\n        meta.valid = result.valid;\n        return result;\n    });\n    function validate$1(opts) {\n        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'silent') {\n            return validateValidStateOnly();\n        }\n        return validateWithStateMutation();\n    }\n    // Common input/change event handler\n    function handleChange(e, shouldValidate = true) {\n        const newValue = normalizeEventValue(e);\n        setValue(newValue, shouldValidate);\n    }\n    // Runs the initial validation\n    onMounted(() => {\n        if (validateOnMount) {\n            return validateWithStateMutation();\n        }\n        // validate self initially if no form was handling this\n        // forms should have their own initial silent validation run to make things more efficient\n        if (!form || !form.validateSchema) {\n            validateValidStateOnly();\n        }\n    });\n    function setTouched(isTouched) {\n        meta.touched = isTouched;\n    }\n    function resetField(state) {\n        var _a;\n        const newValue = state && 'value' in state ? state.value : initialValue.value;\n        setState({\n            value: klona(newValue),\n            initialValue: klona(newValue),\n            touched: (_a = state === null || state === void 0 ? void 0 : state.touched) !== null && _a !== void 0 ? _a : false,\n            errors: (state === null || state === void 0 ? void 0 : state.errors) || [],\n        });\n        meta.pending = false;\n        meta.validated = false;\n        validateValidStateOnly();\n    }\n    const vm = getCurrentInstance();\n    function setValue(newValue, shouldValidate = true) {\n        value.value = vm && syncVModel ? applyModelModifiers(newValue, vm.props.modelModifiers) : newValue;\n        const validateFn = shouldValidate ? validateWithStateMutation : validateValidStateOnly;\n        validateFn();\n    }\n    function setErrors(errors) {\n        setState({ errors: Array.isArray(errors) ? errors : [errors] });\n    }\n    const valueProxy = computed({\n        get() {\n            return value.value;\n        },\n        set(newValue) {\n            setValue(newValue, validateOnValueUpdate);\n        },\n    });\n    const field = {\n        id,\n        name,\n        label,\n        value: valueProxy,\n        meta,\n        errors,\n        errorMessage,\n        type,\n        checkedValue,\n        uncheckedValue,\n        bails,\n        keepValueOnUnmount,\n        resetField,\n        handleReset: () => resetField(),\n        validate: validate$1,\n        handleChange,\n        handleBlur,\n        setState,\n        setTouched,\n        setErrors,\n        setValue,\n    };\n    provide(FieldContextKey, field);\n    if (isRef(rules) && typeof unref(rules) !== 'function') {\n        watch(rules, (value, oldValue) => {\n            if (isEqual(value, oldValue)) {\n                return;\n            }\n            meta.validated ? validateWithStateMutation() : validateValidStateOnly();\n        }, {\n            deep: true,\n        });\n    }\n    if ((process.env.NODE_ENV !== 'production')) {\n        field._vm = getCurrentInstance();\n        watch(() => (Object.assign(Object.assign({ errors: errors.value }, meta), { value: value.value })), refreshInspector, {\n            deep: true,\n        });\n        if (!form) {\n            registerSingleFieldWithDevtools(field);\n        }\n    }\n    // if no associated form return the field API immediately\n    if (!form) {\n        return field;\n    }\n    // associate the field with the given form\n    // extract cross-field dependencies in a computed prop\n    const dependencies = computed(() => {\n        const rulesVal = validator.value;\n        // is falsy, a function schema or a yup schema\n        if (!rulesVal ||\n            isCallable(rulesVal) ||\n            isYupValidator(rulesVal) ||\n            isTypedSchema(rulesVal) ||\n            Array.isArray(rulesVal)) {\n            return {};\n        }\n        return Object.keys(rulesVal).reduce((acc, rule) => {\n            const deps = extractLocators(rulesVal[rule])\n                .map((dep) => dep.__locatorRef)\n                .reduce((depAcc, depName) => {\n                const depValue = getFromPath(form.values, depName) || form.values[depName];\n                if (depValue !== undefined) {\n                    depAcc[depName] = depValue;\n                }\n                return depAcc;\n            }, {});\n            Object.assign(acc, deps);\n            return acc;\n        }, {});\n    });\n    // Adds a watcher that runs the validation whenever field dependencies change\n    watch(dependencies, (deps, oldDeps) => {\n        // Skip if no dependencies or if the field wasn't manipulated\n        if (!Object.keys(deps).length) {\n            return;\n        }\n        const shouldValidate = !isEqual(deps, oldDeps);\n        if (shouldValidate) {\n            meta.validated ? validateWithStateMutation() : validateValidStateOnly();\n        }\n    });\n    onBeforeUnmount(() => {\n        var _a;\n        const shouldKeepValue = (_a = toValue(field.keepValueOnUnmount)) !== null && _a !== void 0 ? _a : toValue(form.keepValuesOnUnmount);\n        const path = toValue(name);\n        if (shouldKeepValue || !form || flags.pendingUnmount[field.id]) {\n            form === null || form === void 0 ? void 0 : form.removePathState(path, id);\n            return;\n        }\n        flags.pendingUnmount[field.id] = true;\n        const pathState = form.getPathState(path);\n        const matchesId = Array.isArray(pathState === null || pathState === void 0 ? void 0 : pathState.id) && (pathState === null || pathState === void 0 ? void 0 : pathState.multiple)\n            ? pathState === null || pathState === void 0 ? void 0 : pathState.id.includes(field.id)\n            : (pathState === null || pathState === void 0 ? void 0 : pathState.id) === field.id;\n        if (!matchesId) {\n            return;\n        }\n        if ((pathState === null || pathState === void 0 ? void 0 : pathState.multiple) && Array.isArray(pathState.value)) {\n            const valueIdx = pathState.value.findIndex(i => isEqual(i, toValue(field.checkedValue)));\n            if (valueIdx > -1) {\n                const newVal = [...pathState.value];\n                newVal.splice(valueIdx, 1);\n                form.setFieldValue(path, newVal);\n            }\n            if (Array.isArray(pathState.id)) {\n                pathState.id.splice(pathState.id.indexOf(field.id), 1);\n            }\n        }\n        else {\n            form.unsetPathValue(toValue(name));\n        }\n        form.removePathState(path, id);\n    });\n    return field;\n}\n/**\n * Normalizes partial field options to include the full options\n */\nfunction normalizeOptions(opts) {\n    const defaults = () => ({\n        initialValue: undefined,\n        validateOnMount: false,\n        bails: true,\n        label: undefined,\n        validateOnValueUpdate: true,\n        keepValueOnUnmount: undefined,\n        syncVModel: false,\n        controlled: true,\n    });\n    const isVModelSynced = !!(opts === null || opts === void 0 ? void 0 : opts.syncVModel);\n    const modelPropName = typeof (opts === null || opts === void 0 ? void 0 : opts.syncVModel) === 'string' ? opts.syncVModel : (opts === null || opts === void 0 ? void 0 : opts.modelPropName) || 'modelValue';\n    const initialValue = isVModelSynced && !('initialValue' in (opts || {}))\n        ? getCurrentModelValue(getCurrentInstance(), modelPropName)\n        : opts === null || opts === void 0 ? void 0 : opts.initialValue;\n    if (!opts) {\n        return Object.assign(Object.assign({}, defaults()), { initialValue });\n    }\n    // TODO: Deprecate this in next major release\n    const checkedValue = 'valueProp' in opts ? opts.valueProp : opts.checkedValue;\n    const controlled = 'standalone' in opts ? !opts.standalone : opts.controlled;\n    const syncVModel = (opts === null || opts === void 0 ? void 0 : opts.modelPropName) || (opts === null || opts === void 0 ? void 0 : opts.syncVModel) || false;\n    return Object.assign(Object.assign(Object.assign({}, defaults()), (opts || {})), { initialValue, controlled: controlled !== null && controlled !== void 0 ? controlled : true, checkedValue,\n        syncVModel });\n}\nfunction useFieldWithChecked(name, rules, opts) {\n    const form = !(opts === null || opts === void 0 ? void 0 : opts.standalone) ? injectWithSelf(FormContextKey) : undefined;\n    const checkedValue = opts === null || opts === void 0 ? void 0 : opts.checkedValue;\n    const uncheckedValue = opts === null || opts === void 0 ? void 0 : opts.uncheckedValue;\n    function patchCheckedApi(field) {\n        const handleChange = field.handleChange;\n        const checked = computed(() => {\n            const currentValue = toValue(field.value);\n            const checkedVal = toValue(checkedValue);\n            return Array.isArray(currentValue)\n                ? currentValue.findIndex(v => isEqual(v, checkedVal)) >= 0\n                : isEqual(checkedVal, currentValue);\n        });\n        function handleCheckboxChange(e, shouldValidate = true) {\n            var _a, _b;\n            if (checked.value === ((_a = e === null || e === void 0 ? void 0 : e.target) === null || _a === void 0 ? void 0 : _a.checked)) {\n                if (shouldValidate) {\n                    field.validate();\n                }\n                return;\n            }\n            const path = toValue(name);\n            const pathState = form === null || form === void 0 ? void 0 : form.getPathState(path);\n            const value = normalizeEventValue(e);\n            let newValue = (_b = toValue(checkedValue)) !== null && _b !== void 0 ? _b : value;\n            if (form && (pathState === null || pathState === void 0 ? void 0 : pathState.multiple) && pathState.type === 'checkbox') {\n                newValue = resolveNextCheckboxValue(getFromPath(form.values, path) || [], newValue, undefined);\n            }\n            else if ((opts === null || opts === void 0 ? void 0 : opts.type) === 'checkbox') {\n                newValue = resolveNextCheckboxValue(toValue(field.value), newValue, toValue(uncheckedValue));\n            }\n            handleChange(newValue, shouldValidate);\n        }\n        return Object.assign(Object.assign({}, field), { checked,\n            checkedValue,\n            uncheckedValue, handleChange: handleCheckboxChange });\n    }\n    return patchCheckedApi(_useField(name, rules, opts));\n}\nfunction useVModel({ prop, value, handleChange, shouldValidate }) {\n    const vm = getCurrentInstance();\n    /* istanbul ignore next */\n    if (!vm || !prop) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn('Failed to setup model events because `useField` was not called in setup.');\n        }\n        return;\n    }\n    const propName = typeof prop === 'string' ? prop : 'modelValue';\n    const emitName = `update:${propName}`;\n    // Component doesn't have a model prop setup (must be defined on the props)\n    if (!(propName in vm.props)) {\n        return;\n    }\n    watch(value, newValue => {\n        if (isEqual(newValue, getCurrentModelValue(vm, propName))) {\n            return;\n        }\n        vm.emit(emitName, newValue);\n    });\n    watch(() => getCurrentModelValue(vm, propName), propValue => {\n        if (propValue === IS_ABSENT && value.value === undefined) {\n            return;\n        }\n        const newValue = propValue === IS_ABSENT ? undefined : propValue;\n        if (isEqual(newValue, value.value)) {\n            return;\n        }\n        handleChange(newValue, shouldValidate());\n    });\n}\nfunction getCurrentModelValue(vm, propName) {\n    if (!vm) {\n        return undefined;\n    }\n    return vm.props[propName];\n}\n\nconst FieldImpl = /** #__PURE__ */ defineComponent({\n    name: 'Field',\n    inheritAttrs: false,\n    props: {\n        as: {\n            type: [String, Object],\n            default: undefined,\n        },\n        name: {\n            type: String,\n            required: true,\n        },\n        rules: {\n            type: [Object, String, Function],\n            default: undefined,\n        },\n        validateOnMount: {\n            type: Boolean,\n            default: false,\n        },\n        validateOnBlur: {\n            type: Boolean,\n            default: undefined,\n        },\n        validateOnChange: {\n            type: Boolean,\n            default: undefined,\n        },\n        validateOnInput: {\n            type: Boolean,\n            default: undefined,\n        },\n        validateOnModelUpdate: {\n            type: Boolean,\n            default: undefined,\n        },\n        bails: {\n            type: Boolean,\n            default: () => getConfig().bails,\n        },\n        label: {\n            type: String,\n            default: undefined,\n        },\n        uncheckedValue: {\n            type: null,\n            default: undefined,\n        },\n        modelValue: {\n            type: null,\n            default: IS_ABSENT,\n        },\n        modelModifiers: {\n            type: null,\n            default: () => ({}),\n        },\n        'onUpdate:modelValue': {\n            type: null,\n            default: undefined,\n        },\n        standalone: {\n            type: Boolean,\n            default: false,\n        },\n        keepValue: {\n            type: Boolean,\n            default: undefined,\n        },\n    },\n    setup(props, ctx) {\n        const rules = toRef(props, 'rules');\n        const name = toRef(props, 'name');\n        const label = toRef(props, 'label');\n        const uncheckedValue = toRef(props, 'uncheckedValue');\n        const keepValue = toRef(props, 'keepValue');\n        const { errors, value, errorMessage, validate: validateField, handleChange, handleBlur, setTouched, resetField, handleReset, meta, checked, setErrors, } = useField(name, rules, {\n            validateOnMount: props.validateOnMount,\n            bails: props.bails,\n            standalone: props.standalone,\n            type: ctx.attrs.type,\n            initialValue: resolveInitialValue(props, ctx),\n            // Only for checkboxes and radio buttons\n            checkedValue: ctx.attrs.value,\n            uncheckedValue,\n            label,\n            validateOnValueUpdate: props.validateOnModelUpdate,\n            keepValueOnUnmount: keepValue,\n            syncVModel: true,\n        });\n        // If there is a v-model applied on the component we need to emit the `update:modelValue` whenever the value binding changes\n        const onChangeHandler = function handleChangeWithModel(e, shouldValidate = true) {\n            handleChange(e, shouldValidate);\n        };\n        const sharedProps = computed(() => {\n            const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = resolveValidationTriggers(props);\n            function baseOnBlur(e) {\n                handleBlur(e, validateOnBlur);\n                if (isCallable(ctx.attrs.onBlur)) {\n                    ctx.attrs.onBlur(e);\n                }\n            }\n            function baseOnInput(e) {\n                onChangeHandler(e, validateOnInput);\n                if (isCallable(ctx.attrs.onInput)) {\n                    ctx.attrs.onInput(e);\n                }\n            }\n            function baseOnChange(e) {\n                onChangeHandler(e, validateOnChange);\n                if (isCallable(ctx.attrs.onChange)) {\n                    ctx.attrs.onChange(e);\n                }\n            }\n            const attrs = {\n                name: props.name,\n                onBlur: baseOnBlur,\n                onInput: baseOnInput,\n                onChange: baseOnChange,\n            };\n            attrs['onUpdate:modelValue'] = e => onChangeHandler(e, validateOnModelUpdate);\n            return attrs;\n        });\n        const fieldProps = computed(() => {\n            const attrs = Object.assign({}, sharedProps.value);\n            if (hasCheckedAttr(ctx.attrs.type) && checked) {\n                attrs.checked = checked.value;\n            }\n            const tag = resolveTag(props, ctx);\n            if (shouldHaveValueBinding(tag, ctx.attrs)) {\n                attrs.value = value.value;\n            }\n            return attrs;\n        });\n        const componentProps = computed(() => {\n            return Object.assign(Object.assign({}, sharedProps.value), { modelValue: value.value });\n        });\n        function slotProps() {\n            return {\n                field: fieldProps.value,\n                componentField: componentProps.value,\n                value: value.value,\n                meta,\n                errors: errors.value,\n                errorMessage: errorMessage.value,\n                validate: validateField,\n                resetField,\n                handleChange: onChangeHandler,\n                handleInput: e => onChangeHandler(e, false),\n                handleReset,\n                handleBlur: sharedProps.value.onBlur,\n                setTouched,\n                setErrors,\n            };\n        }\n        ctx.expose({\n            value,\n            meta,\n            errors,\n            errorMessage,\n            setErrors,\n            setTouched,\n            reset: resetField,\n            validate: validateField,\n            handleChange,\n        });\n        return () => {\n            const tag = resolveDynamicComponent(resolveTag(props, ctx));\n            const children = normalizeChildren(tag, ctx, slotProps);\n            if (tag) {\n                return h(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);\n            }\n            return children;\n        };\n    },\n});\nfunction resolveTag(props, ctx) {\n    let tag = props.as || '';\n    if (!props.as && !ctx.slots.default) {\n        tag = 'input';\n    }\n    return tag;\n}\nfunction resolveValidationTriggers(props) {\n    var _a, _b, _c, _d;\n    const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();\n    return {\n        validateOnInput: (_a = props.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,\n        validateOnChange: (_b = props.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,\n        validateOnBlur: (_c = props.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,\n        validateOnModelUpdate: (_d = props.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate,\n    };\n}\nfunction resolveInitialValue(props, ctx) {\n    // Gets the initial value either from `value` prop/attr or `v-model` binding (modelValue)\n    // For checkboxes and radio buttons it will always be the model value not the `value` attribute\n    if (!hasCheckedAttr(ctx.attrs.type)) {\n        return isPropPresent(props, 'modelValue') ? props.modelValue : ctx.attrs.value;\n    }\n    return isPropPresent(props, 'modelValue') ? props.modelValue : undefined;\n}\nconst Field = FieldImpl;\n\nlet FORM_COUNTER = 0;\nconst PRIVATE_PATH_STATE_KEYS = ['bails', 'fieldsCount', 'id', 'multiple', 'type', 'validate'];\nfunction resolveInitialValues(opts) {\n    const providedValues = Object.assign({}, toValue((opts === null || opts === void 0 ? void 0 : opts.initialValues) || {}));\n    const schema = unref(opts === null || opts === void 0 ? void 0 : opts.validationSchema);\n    if (schema && isTypedSchema(schema) && isCallable(schema.cast)) {\n        return klona(schema.cast(providedValues) || {});\n    }\n    return klona(providedValues);\n}\nfunction useForm(opts) {\n    var _a;\n    const formId = FORM_COUNTER++;\n    // Prevents fields from double resetting their values, which causes checkboxes to toggle their initial value\n    let FIELD_ID_COUNTER = 0;\n    // If the form is currently submitting\n    const isSubmitting = ref(false);\n    // If the form is currently validating\n    const isValidating = ref(false);\n    // The number of times the user tried to submit the form\n    const submitCount = ref(0);\n    // field arrays managed by this form\n    const fieldArrays = [];\n    // a private ref for all form values\n    const formValues = reactive(resolveInitialValues(opts));\n    const pathStates = ref([]);\n    const extraErrorsBag = ref({});\n    const pathStateLookup = ref({});\n    const rebuildPathLookup = debounceNextTick(() => {\n        pathStateLookup.value = pathStates.value.reduce((names, state) => {\n            names[normalizeFormPath(toValue(state.path))] = state;\n            return names;\n        }, {});\n    });\n    /**\n     * Manually sets an error message on a specific field\n     */\n    function setFieldError(field, message) {\n        const state = findPathState(field);\n        if (!state) {\n            if (typeof field === 'string') {\n                extraErrorsBag.value[normalizeFormPath(field)] = normalizeErrorItem(message);\n            }\n            return;\n        }\n        // Move the error from the extras path if exists\n        if (typeof field === 'string') {\n            const normalizedPath = normalizeFormPath(field);\n            if (extraErrorsBag.value[normalizedPath]) {\n                delete extraErrorsBag.value[normalizedPath];\n            }\n        }\n        state.errors = normalizeErrorItem(message);\n        state.valid = !state.errors.length;\n    }\n    /**\n     * Sets errors for the fields specified in the object\n     */\n    function setErrors(paths) {\n        keysOf(paths).forEach(path => {\n            setFieldError(path, paths[path]);\n        });\n    }\n    if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {\n        setErrors(opts.initialErrors);\n    }\n    const errorBag = computed(() => {\n        const pathErrors = pathStates.value.reduce((acc, state) => {\n            if (state.errors.length) {\n                acc[state.path] = state.errors;\n            }\n            return acc;\n        }, {});\n        return Object.assign(Object.assign({}, extraErrorsBag.value), pathErrors);\n    });\n    // Gets the first error of each field\n    const errors = computed(() => {\n        return keysOf(errorBag.value).reduce((acc, key) => {\n            const errors = errorBag.value[key];\n            if (errors === null || errors === void 0 ? void 0 : errors.length) {\n                acc[key] = errors[0];\n            }\n            return acc;\n        }, {});\n    });\n    /**\n     * Holds a computed reference to all fields names and labels\n     */\n    const fieldNames = computed(() => {\n        return pathStates.value.reduce((names, state) => {\n            names[state.path] = { name: state.path || '', label: state.label || '' };\n            return names;\n        }, {});\n    });\n    const fieldBailsMap = computed(() => {\n        return pathStates.value.reduce((map, state) => {\n            var _a;\n            map[state.path] = (_a = state.bails) !== null && _a !== void 0 ? _a : true;\n            return map;\n        }, {});\n    });\n    // mutable non-reactive reference to initial errors\n    // we need this to process initial errors then unset them\n    const initialErrors = Object.assign({}, ((opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {}));\n    const keepValuesOnUnmount = (_a = opts === null || opts === void 0 ? void 0 : opts.keepValuesOnUnmount) !== null && _a !== void 0 ? _a : false;\n    // initial form values\n    const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(pathStates, formValues, opts);\n    // form meta aggregations\n    const meta = useFormMeta(pathStates, formValues, originalInitialValues, errors);\n    const controlledValues = computed(() => {\n        return pathStates.value.reduce((acc, state) => {\n            const value = getFromPath(formValues, state.path);\n            setInPath(acc, state.path, value);\n            return acc;\n        }, {});\n    });\n    const schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;\n    function createPathState(path, config) {\n        var _a, _b;\n        const initialValue = computed(() => getFromPath(initialValues.value, toValue(path)));\n        const pathStateExists = pathStateLookup.value[toValue(path)];\n        const isCheckboxOrRadio = (config === null || config === void 0 ? void 0 : config.type) === 'checkbox' || (config === null || config === void 0 ? void 0 : config.type) === 'radio';\n        if (pathStateExists && isCheckboxOrRadio) {\n            pathStateExists.multiple = true;\n            const id = FIELD_ID_COUNTER++;\n            if (Array.isArray(pathStateExists.id)) {\n                pathStateExists.id.push(id);\n            }\n            else {\n                pathStateExists.id = [pathStateExists.id, id];\n            }\n            pathStateExists.fieldsCount++;\n            pathStateExists.__flags.pendingUnmount[id] = false;\n            return pathStateExists;\n        }\n        const currentValue = computed(() => getFromPath(formValues, toValue(path)));\n        const pathValue = toValue(path);\n        const unsetBatchIndex = UNSET_BATCH.findIndex(_path => _path === pathValue);\n        if (unsetBatchIndex !== -1) {\n            UNSET_BATCH.splice(unsetBatchIndex, 1);\n        }\n        const isRequired = computed(() => {\n            var _a, _b, _c, _d, _e, _f;\n            if (isTypedSchema(schema)) {\n                return (_c = (_b = (_a = schema).describe) === null || _b === void 0 ? void 0 : _b.call(_a, toValue(path)).required) !== null && _c !== void 0 ? _c : false;\n            }\n            // Path own schema\n            if (isTypedSchema(config === null || config === void 0 ? void 0 : config.schema)) {\n                return (_f = (_e = (_d = (config === null || config === void 0 ? void 0 : config.schema)).describe) === null || _e === void 0 ? void 0 : _e.call(_d).required) !== null && _f !== void 0 ? _f : false;\n            }\n            return false;\n        });\n        const id = FIELD_ID_COUNTER++;\n        const state = reactive({\n            id,\n            path,\n            touched: false,\n            pending: false,\n            valid: true,\n            validated: !!((_a = initialErrors[pathValue]) === null || _a === void 0 ? void 0 : _a.length),\n            required: isRequired,\n            initialValue,\n            errors: shallowRef([]),\n            bails: (_b = config === null || config === void 0 ? void 0 : config.bails) !== null && _b !== void 0 ? _b : false,\n            label: config === null || config === void 0 ? void 0 : config.label,\n            type: (config === null || config === void 0 ? void 0 : config.type) || 'default',\n            value: currentValue,\n            multiple: false,\n            __flags: {\n                pendingUnmount: { [id]: false },\n                pendingReset: false,\n            },\n            fieldsCount: 1,\n            validate: config === null || config === void 0 ? void 0 : config.validate,\n            dirty: computed(() => {\n                return !isEqual(unref(currentValue), unref(initialValue));\n            }),\n        });\n        pathStates.value.push(state);\n        pathStateLookup.value[pathValue] = state;\n        rebuildPathLookup();\n        if (errors.value[pathValue] && !initialErrors[pathValue]) {\n            nextTick(() => {\n                validateField(pathValue, { mode: 'silent' });\n            });\n        }\n        // Handles when a path changes\n        if (isRef(path)) {\n            watch(path, newPath => {\n                rebuildPathLookup();\n                const nextValue = klona(currentValue.value);\n                pathStateLookup.value[newPath] = state;\n                nextTick(() => {\n                    setInPath(formValues, newPath, nextValue);\n                });\n            });\n        }\n        return state;\n    }\n    /**\n     * Batches validation runs in 5ms batches\n     * Must have two distinct batch queues to make sure they don't override each other settings #3783\n     */\n    const debouncedSilentValidation = debounceAsync(_validateSchema, 5);\n    const debouncedValidation = debounceAsync(_validateSchema, 5);\n    const validateSchema = withLatest(async (mode) => {\n        return (await (mode === 'silent'\n            ? debouncedSilentValidation()\n            : debouncedValidation()));\n    }, (formResult, [mode]) => {\n        // fields by id lookup\n        // errors fields names, we need it to also check if custom errors are updated\n        const currentErrorsPaths = keysOf(formCtx.errorBag.value);\n        // collect all the keys from the schema and all fields\n        // this ensures we have a complete key map of all the fields\n        const paths = [\n            ...new Set([...keysOf(formResult.results), ...pathStates.value.map(p => p.path), ...currentErrorsPaths]),\n        ].sort();\n        // aggregates the paths into a single result object while applying the results on the fields\n        const results = paths.reduce((validation, _path) => {\n            var _a;\n            const expectedPath = _path;\n            const pathState = findPathState(expectedPath) || findHoistedPath(expectedPath);\n            const messages = ((_a = formResult.results[expectedPath]) === null || _a === void 0 ? void 0 : _a.errors) || [];\n            // This is the real path of the field, because it might've been a hoisted field\n            const path = (toValue(pathState === null || pathState === void 0 ? void 0 : pathState.path) || expectedPath);\n            // It is possible that multiple paths are collected across loops\n            // We want to merge them to avoid overriding any iteration's results\n            const fieldResult = mergeValidationResults({ errors: messages, valid: !messages.length }, validation.results[path]);\n            validation.results[path] = fieldResult;\n            if (!fieldResult.valid) {\n                validation.errors[path] = fieldResult.errors[0];\n            }\n            // clean up extra errors if path state exists\n            if (pathState && extraErrorsBag.value[path]) {\n                delete extraErrorsBag.value[path];\n            }\n            // field not rendered\n            if (!pathState) {\n                setFieldError(path, messages);\n                return validation;\n            }\n            // always update the valid flag regardless of the mode\n            pathState.valid = fieldResult.valid;\n            if (mode === 'silent') {\n                return validation;\n            }\n            if (mode === 'validated-only' && !pathState.validated) {\n                return validation;\n            }\n            setFieldError(pathState, fieldResult.errors);\n            return validation;\n        }, { valid: formResult.valid, results: {}, errors: {} });\n        if (formResult.values) {\n            results.values = formResult.values;\n        }\n        keysOf(results.results).forEach(path => {\n            var _a;\n            const pathState = findPathState(path);\n            if (!pathState) {\n                return;\n            }\n            if (mode === 'silent') {\n                return;\n            }\n            if (mode === 'validated-only' && !pathState.validated) {\n                return;\n            }\n            setFieldError(pathState, (_a = results.results[path]) === null || _a === void 0 ? void 0 : _a.errors);\n        });\n        return results;\n    });\n    function mutateAllPathState(mutation) {\n        pathStates.value.forEach(mutation);\n    }\n    function findPathState(path) {\n        const normalizedPath = typeof path === 'string' ? normalizeFormPath(path) : path;\n        const pathState = typeof normalizedPath === 'string' ? pathStateLookup.value[normalizedPath] : normalizedPath;\n        return pathState;\n    }\n    function findHoistedPath(path) {\n        const candidates = pathStates.value.filter(state => path.startsWith(state.path));\n        return candidates.reduce((bestCandidate, candidate) => {\n            if (!bestCandidate) {\n                return candidate;\n            }\n            return (candidate.path.length > bestCandidate.path.length ? candidate : bestCandidate);\n        }, undefined);\n    }\n    let UNSET_BATCH = [];\n    let PENDING_UNSET;\n    function unsetPathValue(path) {\n        UNSET_BATCH.push(path);\n        if (!PENDING_UNSET) {\n            PENDING_UNSET = nextTick(() => {\n                const sortedPaths = [...UNSET_BATCH].sort().reverse();\n                sortedPaths.forEach(p => {\n                    unsetPath(formValues, p);\n                });\n                UNSET_BATCH = [];\n                PENDING_UNSET = null;\n            });\n        }\n        return PENDING_UNSET;\n    }\n    function makeSubmissionFactory(onlyControlled) {\n        return function submitHandlerFactory(fn, onValidationError) {\n            return function submissionHandler(e) {\n                if (e instanceof Event) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n                // Touch all fields\n                mutateAllPathState(s => (s.touched = true));\n                isSubmitting.value = true;\n                submitCount.value++;\n                return validate()\n                    .then(result => {\n                    const values = klona(formValues);\n                    if (result.valid && typeof fn === 'function') {\n                        const controlled = klona(controlledValues.value);\n                        let submittedValues = (onlyControlled ? controlled : values);\n                        if (result.values) {\n                            submittedValues = result.values;\n                        }\n                        return fn(submittedValues, {\n                            evt: e,\n                            controlledValues: controlled,\n                            setErrors,\n                            setFieldError,\n                            setTouched,\n                            setFieldTouched,\n                            setValues,\n                            setFieldValue,\n                            resetForm,\n                            resetField,\n                        });\n                    }\n                    if (!result.valid && typeof onValidationError === 'function') {\n                        onValidationError({\n                            values,\n                            evt: e,\n                            errors: result.errors,\n                            results: result.results,\n                        });\n                    }\n                })\n                    .then(returnVal => {\n                    isSubmitting.value = false;\n                    return returnVal;\n                }, err => {\n                    isSubmitting.value = false;\n                    // re-throw the err so it doesn't go silent\n                    throw err;\n                });\n            };\n        };\n    }\n    const handleSubmitImpl = makeSubmissionFactory(false);\n    const handleSubmit = handleSubmitImpl;\n    handleSubmit.withControlled = makeSubmissionFactory(true);\n    function removePathState(path, id) {\n        const idx = pathStates.value.findIndex(s => {\n            return s.path === path && (Array.isArray(s.id) ? s.id.includes(id) : s.id === id);\n        });\n        const pathState = pathStates.value[idx];\n        if (idx === -1 || !pathState) {\n            return;\n        }\n        nextTick(() => {\n            validateField(path, { mode: 'silent', warn: false });\n        });\n        if (pathState.multiple && pathState.fieldsCount) {\n            pathState.fieldsCount--;\n        }\n        if (Array.isArray(pathState.id)) {\n            const idIndex = pathState.id.indexOf(id);\n            if (idIndex >= 0) {\n                pathState.id.splice(idIndex, 1);\n            }\n            delete pathState.__flags.pendingUnmount[id];\n        }\n        if (!pathState.multiple || pathState.fieldsCount <= 0) {\n            pathStates.value.splice(idx, 1);\n            unsetInitialValue(path);\n            rebuildPathLookup();\n            delete pathStateLookup.value[path];\n        }\n    }\n    function destroyPath(path) {\n        keysOf(pathStateLookup.value).forEach(key => {\n            if (key.startsWith(path)) {\n                delete pathStateLookup.value[key];\n            }\n        });\n        pathStates.value = pathStates.value.filter(s => !s.path.startsWith(path));\n        nextTick(() => {\n            rebuildPathLookup();\n        });\n    }\n    const formCtx = {\n        formId,\n        values: formValues,\n        controlledValues,\n        errorBag,\n        errors,\n        schema,\n        submitCount,\n        meta,\n        isSubmitting,\n        isValidating,\n        fieldArrays,\n        keepValuesOnUnmount,\n        validateSchema: unref(schema) ? validateSchema : undefined,\n        validate,\n        setFieldError,\n        validateField,\n        setFieldValue,\n        setValues,\n        setErrors,\n        setFieldTouched,\n        setTouched,\n        resetForm,\n        resetField,\n        handleSubmit,\n        useFieldModel,\n        defineInputBinds,\n        defineComponentBinds: defineComponentBinds,\n        defineField,\n        stageInitialValue,\n        unsetInitialValue,\n        setFieldInitialValue,\n        createPathState,\n        getPathState: findPathState,\n        unsetPathValue,\n        removePathState,\n        initialValues: initialValues,\n        getAllPathStates: () => pathStates.value,\n        destroyPath,\n        isFieldTouched,\n        isFieldDirty,\n        isFieldValid,\n    };\n    /**\n     * Sets a single field value\n     */\n    function setFieldValue(field, value, shouldValidate = true) {\n        const clonedValue = klona(value);\n        const path = typeof field === 'string' ? field : field.path;\n        const pathState = findPathState(path);\n        if (!pathState) {\n            createPathState(path);\n        }\n        setInPath(formValues, path, clonedValue);\n        if (shouldValidate) {\n            validateField(path);\n        }\n    }\n    function forceSetValues(fields, shouldValidate = true) {\n        // clean up old values\n        keysOf(formValues).forEach(key => {\n            delete formValues[key];\n        });\n        // set up new values\n        keysOf(fields).forEach(path => {\n            setFieldValue(path, fields[path], false);\n        });\n        if (shouldValidate) {\n            validate();\n        }\n    }\n    /**\n     * Sets multiple fields values\n     */\n    function setValues(fields, shouldValidate = true) {\n        merge(formValues, fields);\n        // regenerate the arrays when the form values change\n        fieldArrays.forEach(f => f && f.reset());\n        if (shouldValidate) {\n            validate();\n        }\n    }\n    function createModel(path, shouldValidate) {\n        const pathState = findPathState(toValue(path)) || createPathState(path);\n        return computed({\n            get() {\n                return pathState.value;\n            },\n            set(value) {\n                var _a;\n                const pathValue = toValue(path);\n                setFieldValue(pathValue, value, (_a = toValue(shouldValidate)) !== null && _a !== void 0 ? _a : false);\n            },\n        });\n    }\n    /**\n     * Sets the touched meta state on a field\n     */\n    function setFieldTouched(field, isTouched) {\n        const pathState = findPathState(field);\n        if (pathState) {\n            pathState.touched = isTouched;\n        }\n    }\n    function isFieldTouched(field) {\n        const pathState = findPathState(field);\n        if (pathState) {\n            return pathState.touched;\n        }\n        // Find all nested paths and consider their touched state\n        return pathStates.value.filter(s => s.path.startsWith(field)).some(s => s.touched);\n    }\n    function isFieldDirty(field) {\n        const pathState = findPathState(field);\n        if (pathState) {\n            return pathState.dirty;\n        }\n        return pathStates.value.filter(s => s.path.startsWith(field)).some(s => s.dirty);\n    }\n    function isFieldValid(field) {\n        const pathState = findPathState(field);\n        if (pathState) {\n            return pathState.valid;\n        }\n        return pathStates.value.filter(s => s.path.startsWith(field)).every(s => s.valid);\n    }\n    /**\n     * Sets the touched meta state on multiple fields\n     */\n    function setTouched(fields) {\n        if (typeof fields === 'boolean') {\n            mutateAllPathState(state => {\n                state.touched = fields;\n            });\n            return;\n        }\n        keysOf(fields).forEach(field => {\n            setFieldTouched(field, !!fields[field]);\n        });\n    }\n    function resetField(field, state) {\n        var _a;\n        const newValue = state && 'value' in state ? state.value : getFromPath(initialValues.value, field);\n        const pathState = findPathState(field);\n        if (pathState) {\n            pathState.__flags.pendingReset = true;\n        }\n        setFieldInitialValue(field, klona(newValue), true);\n        setFieldValue(field, newValue, false);\n        setFieldTouched(field, (_a = state === null || state === void 0 ? void 0 : state.touched) !== null && _a !== void 0 ? _a : false);\n        setFieldError(field, (state === null || state === void 0 ? void 0 : state.errors) || []);\n        nextTick(() => {\n            if (pathState) {\n                pathState.__flags.pendingReset = false;\n            }\n        });\n    }\n    /**\n     * Resets all fields\n     */\n    function resetForm(resetState, opts) {\n        let newValues = klona((resetState === null || resetState === void 0 ? void 0 : resetState.values) ? resetState.values : originalInitialValues.value);\n        newValues = (opts === null || opts === void 0 ? void 0 : opts.force) ? newValues : merge(originalInitialValues.value, newValues);\n        newValues = isTypedSchema(schema) && isCallable(schema.cast) ? schema.cast(newValues) : newValues;\n        setInitialValues(newValues);\n        mutateAllPathState(state => {\n            var _a;\n            state.__flags.pendingReset = true;\n            state.validated = false;\n            state.touched = ((_a = resetState === null || resetState === void 0 ? void 0 : resetState.touched) === null || _a === void 0 ? void 0 : _a[state.path]) || false;\n            setFieldValue(state.path, getFromPath(newValues, state.path), false);\n            setFieldError(state.path, undefined);\n        });\n        (opts === null || opts === void 0 ? void 0 : opts.force) ? forceSetValues(newValues, false) : setValues(newValues, false);\n        setErrors((resetState === null || resetState === void 0 ? void 0 : resetState.errors) || {});\n        submitCount.value = (resetState === null || resetState === void 0 ? void 0 : resetState.submitCount) || 0;\n        nextTick(() => {\n            validate({ mode: 'silent' });\n            mutateAllPathState(state => {\n                state.__flags.pendingReset = false;\n            });\n        });\n    }\n    async function validate(opts) {\n        const mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'force';\n        if (mode === 'force') {\n            mutateAllPathState(f => (f.validated = true));\n        }\n        if (formCtx.validateSchema) {\n            return formCtx.validateSchema(mode);\n        }\n        isValidating.value = true;\n        // No schema, each field is responsible to validate itself\n        const validations = await Promise.all(pathStates.value.map(state => {\n            if (!state.validate) {\n                return Promise.resolve({\n                    key: state.path,\n                    valid: true,\n                    errors: [],\n                });\n            }\n            return state.validate(opts).then((result) => {\n                return {\n                    key: state.path,\n                    valid: result.valid,\n                    errors: result.errors,\n                };\n            });\n        }));\n        isValidating.value = false;\n        const results = {};\n        const errors = {};\n        for (const validation of validations) {\n            results[validation.key] = {\n                valid: validation.valid,\n                errors: validation.errors,\n            };\n            if (validation.errors.length) {\n                errors[validation.key] = validation.errors[0];\n            }\n        }\n        return {\n            valid: validations.every(r => r.valid),\n            results,\n            errors,\n        };\n    }\n    async function validateField(path, opts) {\n        var _a;\n        const state = findPathState(path);\n        if (state && (opts === null || opts === void 0 ? void 0 : opts.mode) !== 'silent') {\n            state.validated = true;\n        }\n        if (schema) {\n            const { results } = await validateSchema((opts === null || opts === void 0 ? void 0 : opts.mode) || 'validated-only');\n            return results[path] || { errors: [], valid: true };\n        }\n        if (state === null || state === void 0 ? void 0 : state.validate) {\n            return state.validate(opts);\n        }\n        const shouldWarn = !state && ((_a = opts === null || opts === void 0 ? void 0 : opts.warn) !== null && _a !== void 0 ? _a : true);\n        if (shouldWarn) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                warn$1(`field with path ${path} was not found`);\n            }\n        }\n        return Promise.resolve({ errors: [], valid: true });\n    }\n    function unsetInitialValue(path) {\n        unsetPath(initialValues.value, path);\n    }\n    /**\n     * Sneaky function to set initial field values\n     */\n    function stageInitialValue(path, value, updateOriginal = false) {\n        setFieldInitialValue(path, value);\n        setInPath(formValues, path, value);\n        if (updateOriginal && !(opts === null || opts === void 0 ? void 0 : opts.initialValues)) {\n            setInPath(originalInitialValues.value, path, klona(value));\n        }\n    }\n    function setFieldInitialValue(path, value, updateOriginal = false) {\n        setInPath(initialValues.value, path, klona(value));\n        if (updateOriginal) {\n            setInPath(originalInitialValues.value, path, klona(value));\n        }\n    }\n    async function _validateSchema() {\n        const schemaValue = unref(schema);\n        if (!schemaValue) {\n            return { valid: true, results: {}, errors: {} };\n        }\n        isValidating.value = true;\n        const formResult = isYupValidator(schemaValue) || isTypedSchema(schemaValue)\n            ? await validateTypedSchema(schemaValue, formValues)\n            : await validateObjectSchema(schemaValue, formValues, {\n                names: fieldNames.value,\n                bailsMap: fieldBailsMap.value,\n            });\n        isValidating.value = false;\n        return formResult;\n    }\n    const submitForm = handleSubmit((_, { evt }) => {\n        if (isFormSubmitEvent(evt)) {\n            evt.target.submit();\n        }\n    });\n    // Trigger initial validation\n    onMounted(() => {\n        if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {\n            setErrors(opts.initialErrors);\n        }\n        if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {\n            setTouched(opts.initialTouched);\n        }\n        // if validate on mount was enabled\n        if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {\n            validate();\n            return;\n        }\n        // otherwise run initial silent validation through schema if available\n        // the useField should skip their own silent validation if a yup schema is present\n        if (formCtx.validateSchema) {\n            formCtx.validateSchema('silent');\n        }\n    });\n    if (isRef(schema)) {\n        watch(schema, () => {\n            var _a;\n            (_a = formCtx.validateSchema) === null || _a === void 0 ? void 0 : _a.call(formCtx, 'validated-only');\n        });\n    }\n    // Provide injections\n    provide(FormContextKey, formCtx);\n    if ((process.env.NODE_ENV !== 'production')) {\n        registerFormWithDevTools(formCtx);\n        watch(() => (Object.assign(Object.assign({ errors: errorBag.value }, meta.value), { values: formValues, isSubmitting: isSubmitting.value, isValidating: isValidating.value, submitCount: submitCount.value })), refreshInspector, {\n            deep: true,\n        });\n    }\n    function defineField(path, config) {\n        const label = isCallable(config) ? undefined : config === null || config === void 0 ? void 0 : config.label;\n        const pathState = (findPathState(toValue(path)) || createPathState(path, { label }));\n        const evalConfig = () => (isCallable(config) ? config(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config || {});\n        function onBlur() {\n            var _a;\n            pathState.touched = true;\n            const validateOnBlur = (_a = evalConfig().validateOnBlur) !== null && _a !== void 0 ? _a : getConfig().validateOnBlur;\n            if (validateOnBlur) {\n                validateField(pathState.path);\n            }\n        }\n        function onInput() {\n            var _a;\n            const validateOnInput = (_a = evalConfig().validateOnInput) !== null && _a !== void 0 ? _a : getConfig().validateOnInput;\n            if (validateOnInput) {\n                nextTick(() => {\n                    validateField(pathState.path);\n                });\n            }\n        }\n        function onChange() {\n            var _a;\n            const validateOnChange = (_a = evalConfig().validateOnChange) !== null && _a !== void 0 ? _a : getConfig().validateOnChange;\n            if (validateOnChange) {\n                nextTick(() => {\n                    validateField(pathState.path);\n                });\n            }\n        }\n        const props = computed(() => {\n            const base = {\n                onChange,\n                onInput,\n                onBlur,\n            };\n            if (isCallable(config)) {\n                return Object.assign(Object.assign({}, base), (config(omit(pathState, PRIVATE_PATH_STATE_KEYS)).props || {}));\n            }\n            if (config === null || config === void 0 ? void 0 : config.props) {\n                return Object.assign(Object.assign({}, base), config.props(omit(pathState, PRIVATE_PATH_STATE_KEYS)));\n            }\n            return base;\n        });\n        const model = createModel(path, () => { var _a, _b, _c; return (_c = (_a = evalConfig().validateOnModelUpdate) !== null && _a !== void 0 ? _a : (_b = getConfig()) === null || _b === void 0 ? void 0 : _b.validateOnModelUpdate) !== null && _c !== void 0 ? _c : true; });\n        return [model, props];\n    }\n    function useFieldModel(pathOrPaths) {\n        if (!Array.isArray(pathOrPaths)) {\n            return createModel(pathOrPaths);\n        }\n        return pathOrPaths.map(p => createModel(p, true));\n    }\n    /**\n     * @deprecated use defineField instead\n     */\n    function defineInputBinds(path, config) {\n        const [model, props] = defineField(path, config);\n        function onBlur() {\n            props.value.onBlur();\n        }\n        function onInput(e) {\n            const value = normalizeEventValue(e);\n            setFieldValue(toValue(path), value, false);\n            props.value.onInput();\n        }\n        function onChange(e) {\n            const value = normalizeEventValue(e);\n            setFieldValue(toValue(path), value, false);\n            props.value.onChange();\n        }\n        return computed(() => {\n            return Object.assign(Object.assign({}, props.value), { onBlur,\n                onInput,\n                onChange, value: model.value });\n        });\n    }\n    /**\n     * @deprecated use defineField instead\n     */\n    function defineComponentBinds(path, config) {\n        const [model, props] = defineField(path, config);\n        const pathState = findPathState(toValue(path));\n        function onUpdateModelValue(value) {\n            model.value = value;\n        }\n        return computed(() => {\n            const conf = isCallable(config) ? config(omit(pathState, PRIVATE_PATH_STATE_KEYS)) : config || {};\n            return Object.assign({ [conf.model || 'modelValue']: model.value, [`onUpdate:${conf.model || 'modelValue'}`]: onUpdateModelValue }, props.value);\n        });\n    }\n    return Object.assign(Object.assign({}, formCtx), { values: readonly(formValues), handleReset: () => resetForm(), submitForm });\n}\n/**\n * Manages form meta aggregation\n */\nfunction useFormMeta(pathsState, currentValues, initialValues, errors) {\n    const MERGE_STRATEGIES = {\n        touched: 'some',\n        pending: 'some',\n        valid: 'every',\n    };\n    const isDirty = computed(() => {\n        return !isEqual(currentValues, unref(initialValues));\n    });\n    function calculateFlags() {\n        const states = pathsState.value;\n        return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {\n            const mergeMethod = MERGE_STRATEGIES[flag];\n            acc[flag] = states[mergeMethod](s => s[flag]);\n            return acc;\n        }, {});\n    }\n    const flags = reactive(calculateFlags());\n    watchEffect(() => {\n        const value = calculateFlags();\n        flags.touched = value.touched;\n        flags.valid = value.valid;\n        flags.pending = value.pending;\n    });\n    return computed(() => {\n        return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { valid: flags.valid && !keysOf(errors.value).length, dirty: isDirty.value });\n    });\n}\n/**\n * Manages the initial values prop\n */\nfunction useFormInitialValues(pathsState, formValues, opts) {\n    const values = resolveInitialValues(opts);\n    // these are the mutable initial values as the fields are mounted/unmounted\n    const initialValues = ref(values);\n    // these are the original initial value as provided by the user initially, they don't keep track of conditional fields\n    // this is important because some conditional fields will overwrite the initial values for other fields who had the same name\n    // like array fields, any push/insert operation will overwrite the initial values because they \"create new fields\"\n    // so these are the values that the reset function should use\n    // these only change when the user explicitly changes the initial values or when the user resets them with new values.\n    const originalInitialValues = ref(klona(values));\n    function setInitialValues(values, updateFields = false) {\n        initialValues.value = merge(klona(initialValues.value) || {}, klona(values));\n        originalInitialValues.value = merge(klona(originalInitialValues.value) || {}, klona(values));\n        if (!updateFields) {\n            return;\n        }\n        // update the pristine non-touched fields\n        // those are excluded because it's unlikely you want to change the form values using initial values\n        // we mostly watch them for API population or newly inserted fields\n        // if the user API is taking too much time before user interaction they should consider disabling or hiding their inputs until the values are ready\n        pathsState.value.forEach(state => {\n            const wasTouched = state.touched;\n            if (wasTouched) {\n                return;\n            }\n            const newValue = getFromPath(initialValues.value, state.path);\n            setInPath(formValues, state.path, klona(newValue));\n        });\n    }\n    return {\n        initialValues,\n        originalInitialValues,\n        setInitialValues,\n    };\n}\nfunction mergeValidationResults(a, b) {\n    if (!b) {\n        return a;\n    }\n    return {\n        valid: a.valid && b.valid,\n        errors: [...a.errors, ...b.errors],\n    };\n}\n\nconst FormImpl = /** #__PURE__ */ defineComponent({\n    name: 'Form',\n    inheritAttrs: false,\n    props: {\n        as: {\n            type: null,\n            default: 'form',\n        },\n        validationSchema: {\n            type: Object,\n            default: undefined,\n        },\n        initialValues: {\n            type: Object,\n            default: undefined,\n        },\n        initialErrors: {\n            type: Object,\n            default: undefined,\n        },\n        initialTouched: {\n            type: Object,\n            default: undefined,\n        },\n        validateOnMount: {\n            type: Boolean,\n            default: false,\n        },\n        onSubmit: {\n            type: Function,\n            default: undefined,\n        },\n        onInvalidSubmit: {\n            type: Function,\n            default: undefined,\n        },\n        keepValues: {\n            type: Boolean,\n            default: false,\n        },\n    },\n    setup(props, ctx) {\n        const validationSchema = toRef(props, 'validationSchema');\n        const keepValues = toRef(props, 'keepValues');\n        const { errors, errorBag, values, meta, isSubmitting, isValidating, submitCount, controlledValues, validate, validateField, handleReset, resetForm, handleSubmit, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched, resetField, } = useForm({\n            validationSchema: validationSchema.value ? validationSchema : undefined,\n            initialValues: props.initialValues,\n            initialErrors: props.initialErrors,\n            initialTouched: props.initialTouched,\n            validateOnMount: props.validateOnMount,\n            keepValuesOnUnmount: keepValues,\n        });\n        const submitForm = handleSubmit((_, { evt }) => {\n            if (isFormSubmitEvent(evt)) {\n                evt.target.submit();\n            }\n        }, props.onInvalidSubmit);\n        const onSubmit = props.onSubmit ? handleSubmit(props.onSubmit, props.onInvalidSubmit) : submitForm;\n        function handleFormReset(e) {\n            if (isEvent(e)) {\n                // Prevent default form reset behavior\n                e.preventDefault();\n            }\n            handleReset();\n            if (typeof ctx.attrs.onReset === 'function') {\n                ctx.attrs.onReset();\n            }\n        }\n        function handleScopedSlotSubmit(evt, onSubmit) {\n            const onSuccess = typeof evt === 'function' && !onSubmit ? evt : onSubmit;\n            return handleSubmit(onSuccess, props.onInvalidSubmit)(evt);\n        }\n        function getValues() {\n            return klona(values);\n        }\n        function getMeta() {\n            return klona(meta.value);\n        }\n        function getErrors() {\n            return klona(errors.value);\n        }\n        function slotProps() {\n            return {\n                meta: meta.value,\n                errors: errors.value,\n                errorBag: errorBag.value,\n                values,\n                isSubmitting: isSubmitting.value,\n                isValidating: isValidating.value,\n                submitCount: submitCount.value,\n                controlledValues: controlledValues.value,\n                validate,\n                validateField,\n                handleSubmit: handleScopedSlotSubmit,\n                handleReset,\n                submitForm,\n                setErrors,\n                setFieldError,\n                setFieldValue,\n                setValues,\n                setFieldTouched,\n                setTouched,\n                resetForm,\n                resetField,\n                getValues,\n                getMeta,\n                getErrors,\n            };\n        }\n        // expose these functions and methods as part of public API\n        ctx.expose({\n            setFieldError,\n            setErrors,\n            setFieldValue,\n            setValues,\n            setFieldTouched,\n            setTouched,\n            resetForm,\n            validate,\n            validateField,\n            resetField,\n            getValues,\n            getMeta,\n            getErrors,\n            values,\n            meta,\n            errors,\n        });\n        return function renderForm() {\n            // avoid resolving the form component as itself\n            const tag = props.as === 'form' ? props.as : !props.as ? null : resolveDynamicComponent(props.as);\n            const children = normalizeChildren(tag, ctx, slotProps);\n            if (!tag) {\n                return children;\n            }\n            // Attributes to add on a native `form` tag\n            const formAttrs = tag === 'form'\n                ? {\n                    // Disables native validation as vee-validate will handle it.\n                    novalidate: true,\n                }\n                : {};\n            return h(tag, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);\n        };\n    },\n});\nconst Form = FormImpl;\n\nfunction useFieldArray(arrayPath) {\n    const form = injectWithSelf(FormContextKey, undefined);\n    const fields = ref([]);\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const noOp = () => { };\n    const noOpApi = {\n        fields,\n        remove: noOp,\n        push: noOp,\n        swap: noOp,\n        insert: noOp,\n        update: noOp,\n        replace: noOp,\n        prepend: noOp,\n        move: noOp,\n    };\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly');\n        }\n        return noOpApi;\n    }\n    if (!unref(arrayPath)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('FieldArray requires a field path to be provided, did you forget to pass the `name` prop?');\n        }\n        return noOpApi;\n    }\n    const alreadyExists = form.fieldArrays.find(a => unref(a.path) === unref(arrayPath));\n    if (alreadyExists) {\n        return alreadyExists;\n    }\n    let entryCounter = 0;\n    function getCurrentValues() {\n        return getFromPath(form === null || form === void 0 ? void 0 : form.values, toValue(arrayPath), []) || [];\n    }\n    function initFields() {\n        const currentValues = getCurrentValues();\n        if (!Array.isArray(currentValues)) {\n            return;\n        }\n        fields.value = currentValues.map((v, idx) => createEntry(v, idx, fields.value));\n        updateEntryFlags();\n    }\n    initFields();\n    function updateEntryFlags() {\n        const fieldsLength = fields.value.length;\n        for (let i = 0; i < fieldsLength; i++) {\n            const entry = fields.value[i];\n            entry.isFirst = i === 0;\n            entry.isLast = i === fieldsLength - 1;\n        }\n    }\n    function createEntry(value, idx, currentFields) {\n        // Skips the work by returning the current entry if it already exists\n        // This should make the `key` prop stable and doesn't cause more re-renders than needed\n        // The value is computed and should update anyways\n        if (currentFields && !isNullOrUndefined(idx) && currentFields[idx]) {\n            return currentFields[idx];\n        }\n        const key = entryCounter++;\n        const entry = {\n            key,\n            value: computedDeep({\n                get() {\n                    const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, toValue(arrayPath), []) || [];\n                    const idx = fields.value.findIndex(e => e.key === key);\n                    return idx === -1 ? value : currentValues[idx];\n                },\n                set(value) {\n                    const idx = fields.value.findIndex(e => e.key === key);\n                    if (idx === -1) {\n                        if ((process.env.NODE_ENV !== 'production')) {\n                            warn(`Attempting to update a non-existent array item`);\n                        }\n                        return;\n                    }\n                    update(idx, value);\n                },\n            }), // will be auto unwrapped\n            isFirst: false,\n            isLast: false,\n        };\n        return entry;\n    }\n    function afterMutation() {\n        updateEntryFlags();\n        // Should trigger a silent validation since a field may not do that #4096\n        form === null || form === void 0 ? void 0 : form.validate({ mode: 'silent' });\n    }\n    function remove(idx) {\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        if (!pathValue || !Array.isArray(pathValue)) {\n            return;\n        }\n        const newValue = [...pathValue];\n        newValue.splice(idx, 1);\n        const fieldPath = pathName + `[${idx}]`;\n        form.destroyPath(fieldPath);\n        form.unsetInitialValue(fieldPath);\n        setInPath(form.values, pathName, newValue);\n        fields.value.splice(idx, 1);\n        afterMutation();\n    }\n    function push(initialValue) {\n        const value = klona(initialValue);\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;\n        if (!Array.isArray(normalizedPathValue)) {\n            return;\n        }\n        const newValue = [...normalizedPathValue];\n        newValue.push(value);\n        form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value);\n        setInPath(form.values, pathName, newValue);\n        fields.value.push(createEntry(value));\n        afterMutation();\n    }\n    function swap(indexA, indexB) {\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        if (!Array.isArray(pathValue) || !(indexA in pathValue) || !(indexB in pathValue)) {\n            return;\n        }\n        const newValue = [...pathValue];\n        const newFields = [...fields.value];\n        // the old switcheroo\n        const temp = newValue[indexA];\n        newValue[indexA] = newValue[indexB];\n        newValue[indexB] = temp;\n        const tempEntry = newFields[indexA];\n        newFields[indexA] = newFields[indexB];\n        newFields[indexB] = tempEntry;\n        setInPath(form.values, pathName, newValue);\n        fields.value = newFields;\n        updateEntryFlags();\n    }\n    function insert(idx, initialValue) {\n        const value = klona(initialValue);\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        if (!Array.isArray(pathValue) || pathValue.length < idx) {\n            return;\n        }\n        const newValue = [...pathValue];\n        const newFields = [...fields.value];\n        newValue.splice(idx, 0, value);\n        newFields.splice(idx, 0, createEntry(value));\n        setInPath(form.values, pathName, newValue);\n        fields.value = newFields;\n        afterMutation();\n    }\n    function replace(arr) {\n        const pathName = toValue(arrayPath);\n        form.stageInitialValue(pathName, arr);\n        setInPath(form.values, pathName, arr);\n        initFields();\n        afterMutation();\n    }\n    function update(idx, value) {\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        if (!Array.isArray(pathValue) || pathValue.length - 1 < idx) {\n            return;\n        }\n        setInPath(form.values, `${pathName}[${idx}]`, value);\n        form === null || form === void 0 ? void 0 : form.validate({ mode: 'validated-only' });\n    }\n    function prepend(initialValue) {\n        const value = klona(initialValue);\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;\n        if (!Array.isArray(normalizedPathValue)) {\n            return;\n        }\n        const newValue = [value, ...normalizedPathValue];\n        setInPath(form.values, pathName, newValue);\n        form.stageInitialValue(pathName + `[0]`, value);\n        fields.value.unshift(createEntry(value));\n        afterMutation();\n    }\n    function move(oldIdx, newIdx) {\n        const pathName = toValue(arrayPath);\n        const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);\n        const newValue = isNullOrUndefined(pathValue) ? [] : [...pathValue];\n        if (!Array.isArray(pathValue) || !(oldIdx in pathValue) || !(newIdx in pathValue)) {\n            return;\n        }\n        const newFields = [...fields.value];\n        const movedItem = newFields[oldIdx];\n        newFields.splice(oldIdx, 1);\n        newFields.splice(newIdx, 0, movedItem);\n        const movedValue = newValue[oldIdx];\n        newValue.splice(oldIdx, 1);\n        newValue.splice(newIdx, 0, movedValue);\n        setInPath(form.values, pathName, newValue);\n        fields.value = newFields;\n        afterMutation();\n    }\n    const fieldArrayCtx = {\n        fields,\n        remove,\n        push,\n        swap,\n        insert,\n        update,\n        replace,\n        prepend,\n        move,\n    };\n    form.fieldArrays.push(Object.assign({ path: arrayPath, reset: initFields }, fieldArrayCtx));\n    onBeforeUnmount(() => {\n        const idx = form.fieldArrays.findIndex(i => toValue(i.path) === toValue(arrayPath));\n        if (idx >= 0) {\n            form.fieldArrays.splice(idx, 1);\n        }\n    });\n    // Makes sure to sync the form values with the array value if they go out of sync\n    // #4153\n    watch(getCurrentValues, formValues => {\n        const fieldsValues = fields.value.map(f => f.value);\n        // If form values are not the same as the current values then something overrode them.\n        if (!isEqual(formValues, fieldsValues)) {\n            initFields();\n        }\n    });\n    return fieldArrayCtx;\n}\n\nconst FieldArrayImpl = /** #__PURE__ */ defineComponent({\n    name: 'FieldArray',\n    inheritAttrs: false,\n    props: {\n        name: {\n            type: String,\n            required: true,\n        },\n    },\n    setup(props, ctx) {\n        const { push, remove, swap, insert, replace, update, prepend, move, fields } = useFieldArray(() => props.name);\n        function slotProps() {\n            return {\n                fields: fields.value,\n                push,\n                remove,\n                swap,\n                insert,\n                update,\n                replace,\n                prepend,\n                move,\n            };\n        }\n        ctx.expose({\n            push,\n            remove,\n            swap,\n            insert,\n            update,\n            replace,\n            prepend,\n            move,\n        });\n        return () => {\n            const children = normalizeChildren(undefined, ctx, slotProps);\n            return children;\n        };\n    },\n});\nconst FieldArray = FieldArrayImpl;\n\nconst ErrorMessageImpl = /** #__PURE__ */ defineComponent({\n    name: 'ErrorMessage',\n    props: {\n        as: {\n            type: String,\n            default: undefined,\n        },\n        name: {\n            type: String,\n            required: true,\n        },\n    },\n    setup(props, ctx) {\n        const form = inject(FormContextKey, undefined);\n        const message = computed(() => {\n            return form === null || form === void 0 ? void 0 : form.errors.value[props.name];\n        });\n        function slotProps() {\n            return {\n                message: message.value,\n            };\n        }\n        return () => {\n            // Renders nothing if there are no messages\n            if (!message.value) {\n                return undefined;\n            }\n            const tag = (props.as ? resolveDynamicComponent(props.as) : props.as);\n            const children = normalizeChildren(tag, ctx, slotProps);\n            const attrs = Object.assign({ role: 'alert' }, ctx.attrs);\n            // If no tag was specified and there are children\n            // render the slot as is without wrapping it\n            if (!tag && (Array.isArray(children) || !children) && (children === null || children === void 0 ? void 0 : children.length)) {\n                return children;\n            }\n            // If no children in slot\n            // render whatever specified and fallback to a <span> with the message in it's contents\n            if ((Array.isArray(children) || !children) && !(children === null || children === void 0 ? void 0 : children.length)) {\n                return h(tag || 'span', attrs, message.value);\n            }\n            return h(tag, attrs, children);\n        };\n    },\n});\nconst ErrorMessage = ErrorMessageImpl;\n\nfunction useResetForm() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return function resetForm(state) {\n        if (!form) {\n            return;\n        }\n        return form.resetForm(state);\n    };\n}\n\n/**\n * If a field is dirty or not\n */\nfunction useIsFieldDirty(path) {\n    const fieldOrPath = resolveFieldOrPathState(path);\n    return computed(() => {\n        var _a, _b;\n        if (!fieldOrPath) {\n            return false;\n        }\n        return (_b = ('meta' in fieldOrPath ? fieldOrPath.meta.dirty : (_a = fieldOrPath === null || fieldOrPath === void 0 ? void 0 : fieldOrPath.value) === null || _a === void 0 ? void 0 : _a.dirty)) !== null && _b !== void 0 ? _b : false;\n    });\n}\n\n/**\n * If a field is touched or not\n */\nfunction useIsFieldTouched(path) {\n    const fieldOrPath = resolveFieldOrPathState(path);\n    return computed(() => {\n        var _a, _b;\n        if (!fieldOrPath) {\n            return false;\n        }\n        return (_b = ('meta' in fieldOrPath ? fieldOrPath.meta.touched : (_a = fieldOrPath === null || fieldOrPath === void 0 ? void 0 : fieldOrPath.value) === null || _a === void 0 ? void 0 : _a.touched)) !== null && _b !== void 0 ? _b : false;\n    });\n}\n\n/**\n * If a field is validated and is valid\n */\nfunction useIsFieldValid(path) {\n    const fieldOrPath = resolveFieldOrPathState(path);\n    return computed(() => {\n        var _a, _b;\n        if (!fieldOrPath) {\n            return false;\n        }\n        return (_b = ('meta' in fieldOrPath ? fieldOrPath.meta.valid : (_a = fieldOrPath === null || fieldOrPath === void 0 ? void 0 : fieldOrPath.value) === null || _a === void 0 ? void 0 : _a.valid)) !== null && _b !== void 0 ? _b : false;\n    });\n}\n\n/**\n * If the form is submitting or not\n */\nfunction useIsSubmitting() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        var _a;\n        return (_a = form === null || form === void 0 ? void 0 : form.isSubmitting.value) !== null && _a !== void 0 ? _a : false;\n    });\n}\n\n/**\n * If the form is validating or not\n */\nfunction useIsValidating() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        var _a;\n        return (_a = form === null || form === void 0 ? void 0 : form.isValidating.value) !== null && _a !== void 0 ? _a : false;\n    });\n}\n\n/**\n * Validates a single field\n */\nfunction useValidateField(path) {\n    const form = injectWithSelf(FormContextKey);\n    const field = path ? undefined : inject(FieldContextKey);\n    return function validateField() {\n        if (field) {\n            return field.validate();\n        }\n        if (form && path) {\n            return form === null || form === void 0 ? void 0 : form.validateField(toValue(path));\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`field with name ${unref(path)} was not found`);\n        }\n        return Promise.resolve({\n            errors: [],\n            valid: true,\n        });\n    };\n}\n\n/**\n * If the form is dirty or not\n */\nfunction useIsFormDirty() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        var _a;\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.dirty) !== null && _a !== void 0 ? _a : false;\n    });\n}\n\n/**\n * If the form is touched or not\n */\nfunction useIsFormTouched() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        var _a;\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.touched) !== null && _a !== void 0 ? _a : false;\n    });\n}\n\n/**\n * If the form has been validated and is valid\n */\nfunction useIsFormValid() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        var _a;\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.valid) !== null && _a !== void 0 ? _a : false;\n    });\n}\n\n/**\n * Validate multiple fields\n */\nfunction useValidateForm() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return function validateField() {\n        if (!form) {\n            return Promise.resolve({ results: {}, errors: {}, valid: true });\n        }\n        return form.validate();\n    };\n}\n\n/**\n * The number of form's submission count\n */\nfunction useSubmitCount() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        var _a;\n        return (_a = form === null || form === void 0 ? void 0 : form.submitCount.value) !== null && _a !== void 0 ? _a : 0;\n    });\n}\n\n/**\n * Gives access to a field's current value\n */\nfunction useFieldValue(path) {\n    const form = injectWithSelf(FormContextKey);\n    // We don't want to use self injected context as it doesn't make sense\n    const field = path ? undefined : inject(FieldContextKey);\n    return computed(() => {\n        if (path) {\n            return getFromPath(form === null || form === void 0 ? void 0 : form.values, toValue(path));\n        }\n        return toValue(field === null || field === void 0 ? void 0 : field.value);\n    });\n}\n\n/**\n * Gives access to a form's values\n */\nfunction useFormValues() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        return (form === null || form === void 0 ? void 0 : form.values) || {};\n    });\n}\n\n/**\n * Gives access to all form errors\n */\nfunction useFormErrors() {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    return computed(() => {\n        return ((form === null || form === void 0 ? void 0 : form.errors.value) || {});\n    });\n}\n\n/**\n * Gives access to a single field error\n */\nfunction useFieldError(path) {\n    const form = injectWithSelf(FormContextKey);\n    // We don't want to use self injected context as it doesn't make sense\n    const field = path ? undefined : inject(FieldContextKey);\n    return computed(() => {\n        if (path) {\n            return form === null || form === void 0 ? void 0 : form.errors.value[toValue(path)];\n        }\n        return field === null || field === void 0 ? void 0 : field.errorMessage.value;\n    });\n}\n\nfunction useSubmitForm(cb) {\n    const form = injectWithSelf(FormContextKey);\n    if (!form) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\n        }\n    }\n    const onSubmit = form ? form.handleSubmit(cb) : undefined;\n    return function submitForm(e) {\n        if (!onSubmit) {\n            return;\n        }\n        return onSubmit(e);\n    };\n}\n\n/**\n * Sets a field's error message\n */\nfunction useSetFieldError(path) {\n    const form = injectWithSelf(FormContextKey);\n    // We don't want to use self injected context as it doesn't make sense\n    const field = path ? undefined : inject(FieldContextKey);\n    return function setFieldError(message) {\n        if (path && form) {\n            form.setFieldError(toValue(path), message);\n            return;\n        }\n        if (field) {\n            field.setErrors(message || []);\n            return;\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Could not set error message since there is no form context or a field named \"${toValue(path)}\", did you forget to call \"useField\" or \"useForm\"?`);\n        }\n    };\n}\n\n/**\n * Sets a field's touched meta state\n */\nfunction useSetFieldTouched(path) {\n    const form = injectWithSelf(FormContextKey);\n    // We don't want to use self injected context as it doesn't make sense\n    const field = path ? undefined : inject(FieldContextKey);\n    return function setFieldTouched(touched) {\n        if (path && form) {\n            form.setFieldTouched(toValue(path), touched);\n            return;\n        }\n        if (field) {\n            field.setTouched(touched);\n            return;\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Could not set touched state since there is no form context or a field named \"${toValue(path)}\", did you forget to call \"useField\" or \"useForm\"?`);\n        }\n    };\n}\n\n/**\n * Sets a field's value\n */\nfunction useSetFieldValue(path) {\n    const form = injectWithSelf(FormContextKey);\n    // We don't want to use self injected context as it doesn't make sense\n    const field = path ? undefined : inject(FieldContextKey);\n    return function setFieldValue(value, shouldValidate = true) {\n        if (path && form) {\n            form.setFieldValue(toValue(path), value, shouldValidate);\n            return;\n        }\n        if (field) {\n            field.setValue(value, shouldValidate);\n            return;\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Could not set value since there is no form context or a field named \"${toValue(path)}\", did you forget to call \"useField\" or \"useForm\"?`);\n        }\n    };\n}\n\n/**\n * Sets multiple fields errors\n */\nfunction useSetFormErrors() {\n    const form = injectWithSelf(FormContextKey);\n    function setFormErrors(fields) {\n        if (form) {\n            form.setErrors(fields);\n            return;\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Could not set errors because a form was not detected, did you forget to use \"useForm\" in a parent component?`);\n        }\n    }\n    return setFormErrors;\n}\n\n/**\n * Sets multiple fields touched or all fields in the form\n */\nfunction useSetFormTouched() {\n    const form = injectWithSelf(FormContextKey);\n    function setFormTouched(fields) {\n        if (form) {\n            form.setTouched(fields);\n            return;\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Could not set touched state because a form was not detected, did you forget to use \"useForm\" in a parent component?`);\n        }\n    }\n    return setFormTouched;\n}\n\n/**\n * Sets multiple fields values\n */\nfunction useSetFormValues() {\n    const form = injectWithSelf(FormContextKey);\n    function setFormValues(fields, shouldValidate = true) {\n        if (form) {\n            form.setValues(fields, shouldValidate);\n            return;\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Could not set form values because a form was not detected, did you forget to use \"useForm\" in a parent component?`);\n        }\n    }\n    return setFormValues;\n}\n\nexport { ErrorMessage, Field, FieldArray, FieldContextKey, Form, FormContextKey, IS_ABSENT, cleanupNonNestedPath, configure, defineRule, isNotNestedPath, normalizeRules, useField, useFieldArray, useFieldError, useFieldValue, useForm, useFormErrors, useFormValues, useIsFieldDirty, useIsFieldTouched, useIsFieldValid, useIsFormDirty, useIsFormTouched, useIsFormValid, useIsSubmitting, useIsValidating, useResetForm, useSetFieldError, useSetFieldTouched, useSetFieldValue, useSetFormErrors, useSetFormTouched, useSetFormValues, useSubmitCount, useSubmitForm, useValidateField, useValidateForm, validate, validateObjectSchema as validateObject };\n","/**\n  * vee-validate v4.12.6\n  * (c) 2024 Abdelrahman Awad\n  * @license MIT\n  */\nimport 'vue';\nimport { validate, validateObject } from 'vee-validate';\n\n/* eslint-disable no-misleading-character-class */\n/**\n * Some Alpha Regex helpers.\n * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js\n */\nconst alpha = {\n    en: /^[A-Z]*$/i,\n    cs: /^[A-Z]*$/i,\n    da: /^[A-Z]*$/i,\n    de: /^[A-Z]*$/i,\n    es: /^[A-Z]*$/i,\n    fr: /^[A-Z]*$/i,\n    it: /^[A-Z\\xC0-\\xFF]*$/i,\n    lt: /^[A-Z]*$/i,\n    nl: /^[A-Z]*$/i,\n    hu: /^[A-Z]*$/i,\n    pl: /^[A-Z]*$/i,\n    pt: /^[A-Z]*$/i,\n    ru: /^[-]*$/i,\n    kz: /^[-\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA]*$/i,\n    sk: /^[A-Z]*$/i,\n    sr: /^[A-Z]*$/i,\n    sv: /^[A-Z]*$/i,\n    tr: /^[A-Z]*$/i,\n    uk: /^[-]*$/i,\n    ar: /^[]*$/,\n    az: /^[A-Z]*$/i,\n    ug: /^[A-Z]*$/i,\n};\nconst alphaSpaces = {\n    en: /^[A-Z\\s]*$/i,\n    cs: /^[A-Z\\s]*$/i,\n    da: /^[A-Z\\s]*$/i,\n    de: /^[A-Z\\s]*$/i,\n    es: /^[A-Z\\s]*$/i,\n    fr: /^[A-Z\\s]*$/i,\n    it: /^[A-Z\\xC0-\\xFF\\s]*$/i,\n    lt: /^[A-Z\\s]*$/i,\n    nl: /^[A-Z\\s]*$/i,\n    hu: /^[A-Z\\s]*$/i,\n    pl: /^[A-Z\\s]*$/i,\n    pt: /^[A-Z\\s]*$/i,\n    ru: /^[-\\s]*$/i,\n    kz: /^[-\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA\\s]*$/i,\n    sk: /^[A-Z\\s]*$/i,\n    sr: /^[A-Z\\s]*$/i,\n    sv: /^[A-Z\\s]*$/i,\n    tr: /^[A-Z\\s]*$/i,\n    uk: /^[-\\s]*$/i,\n    ar: /^[\\s]*$/,\n    az: /^[A-Z\\s]*$/i,\n    ug: /^[A-Z\\s]*$/i,\n};\nconst alphanumeric = {\n    en: /^[0-9A-Z]*$/i,\n    cs: /^[0-9A-Z]*$/i,\n    da: /^[0-9A-Z]$/i,\n    de: /^[0-9A-Z]*$/i,\n    es: /^[0-9A-Z]*$/i,\n    fr: /^[0-9A-Z]*$/i,\n    it: /^[0-9A-Z\\xC0-\\xFF]*$/i,\n    lt: /^[0-9A-Z]*$/i,\n    hu: /^[0-9A-Z]*$/i,\n    nl: /^[0-9A-Z]*$/i,\n    pl: /^[0-9A-Z]*$/i,\n    pt: /^[0-9A-Z]*$/i,\n    ru: /^[0-9-]*$/i,\n    kz: /^[0-9-\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA]*$/i,\n    sk: /^[0-9A-Z]*$/i,\n    sr: /^[0-9A-Z]*$/i,\n    sv: /^[0-9A-Z]*$/i,\n    tr: /^[0-9A-Z]*$/i,\n    uk: /^[0-9-]*$/i,\n    ar: /^[0-9]*$/,\n    az: /^[0-9A-Z]*$/i,\n    ug: /^[0-9A-Z]*$/i,\n};\nconst alphaDash = {\n    en: /^[0-9A-Z_-]*$/i,\n    cs: /^[0-9A-Z_-]*$/i,\n    da: /^[0-9A-Z_-]*$/i,\n    de: /^[0-9A-Z_-]*$/i,\n    es: /^[0-9A-Z_-]*$/i,\n    fr: /^[0-9A-Z_-]*$/i,\n    it: /^[0-9A-Z\\xC0-\\xFF_-]*$/i,\n    lt: /^[0-9A-Z_-]*$/i,\n    nl: /^[0-9A-Z_-]*$/i,\n    hu: /^[0-9A-Z_-]*$/i,\n    pl: /^[0-9A-Z_-]*$/i,\n    pt: /^[0-9A-Z_-]*$/i,\n    ru: /^[0-9-_-]*$/i,\n    kz: /^[0-9-\\u04D8\\u04B0\\u0406\\u04A2\\u0492\\u04AE\\u049A\\u04E8\\u04BA_-]*$/i,\n    sk: /^[0-9A-Z_-]*$/i,\n    sr: /^[0-9A-Z_-]*$/i,\n    sv: /^[0-9A-Z_-]*$/i,\n    tr: /^[0-9A-Z_-]*$/i,\n    uk: /^[0-9-_-]*$/i,\n    ar: /^[0-9_-]*$/,\n    az: /^[0-9A-Z_-]*$/i,\n    ug: /^[0-9A-Z_-]*$/i,\n};\nconst getLocale = (params) => {\n    if (!params) {\n        return undefined;\n    }\n    return Array.isArray(params) ? params[0] : params.locale;\n};\n\nfunction getSingleParam(params, paramName) {\n    return Array.isArray(params) ? params[0] : params[paramName];\n}\nfunction isEmpty(value) {\n    if (value === null || value === undefined || value === '') {\n        return true;\n    }\n    if (Array.isArray(value) && value.length === 0) {\n        return true;\n    }\n    return false;\n}\n\nconst alphaValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const locale = getLocale(params);\n    if (Array.isArray(value)) {\n        return value.every(val => alphaValidator(val, { locale }));\n    }\n    const valueAsString = String(value);\n    // Match at least one locale.\n    if (!locale) {\n        return Object.keys(alpha).some(loc => alpha[loc].test(valueAsString));\n    }\n    return (alpha[locale] || alpha.en).test(valueAsString);\n};\n\nconst alphaDashValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const locale = getLocale(params);\n    if (Array.isArray(value)) {\n        return value.every(val => alphaDashValidator(val, { locale }));\n    }\n    const valueAsString = String(value);\n    // Match at least one locale.\n    if (!locale) {\n        return Object.keys(alphaDash).some(loc => alphaDash[loc].test(valueAsString));\n    }\n    return (alphaDash[locale] || alphaDash.en).test(valueAsString);\n};\n\nconst alphaNumValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const locale = getLocale(params);\n    if (Array.isArray(value)) {\n        return value.every(val => alphaNumValidator(val, { locale }));\n    }\n    const valueAsString = String(value);\n    // Match at least one locale.\n    if (!locale) {\n        return Object.keys(alphanumeric).some(loc => alphanumeric[loc].test(valueAsString));\n    }\n    return (alphanumeric[locale] || alphanumeric.en).test(valueAsString);\n};\n\nconst alphaSpacesValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const locale = getLocale(params);\n    if (Array.isArray(value)) {\n        return value.every(val => alphaSpacesValidator(val, { locale }));\n    }\n    const valueAsString = String(value);\n    // Match at least one locale.\n    if (!locale) {\n        return Object.keys(alphaSpaces).some(loc => alphaSpaces[loc].test(valueAsString));\n    }\n    return (alphaSpaces[locale] || alphaSpaces.en).test(valueAsString);\n};\n\nfunction getParams$1(params) {\n    if (Array.isArray(params)) {\n        return { min: params[0], max: params[1] };\n    }\n    return params;\n}\nconst betweenValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const { min, max } = getParams$1(params);\n    if (Array.isArray(value)) {\n        return value.every(val => betweenValidator(val, { min, max }));\n    }\n    const valueAsNumber = Number(value);\n    return Number(min) <= valueAsNumber && Number(max) >= valueAsNumber;\n};\n\nconst confirmedValidator = (value, params) => {\n    const target = getSingleParam(params, 'target');\n    return String(value) === String(target);\n};\n\nconst digitsValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const length = getSingleParam(params, 'length');\n    if (Array.isArray(value)) {\n        return value.every(val => digitsValidator(val, { length }));\n    }\n    const strVal = String(value);\n    return /^[0-9]*$/.test(strVal) && strVal.length === Number(length);\n};\n\nconst validateImage = (file, width, height) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const URL = window.URL || window.webkitURL;\n    return new Promise(resolve => {\n        const image = new Image();\n        image.onerror = () => resolve(false);\n        image.onload = () => resolve(image.width === width && image.height === height);\n        image.src = URL.createObjectURL(file);\n    });\n};\nfunction getParams(params) {\n    if (!params) {\n        return { width: 0, height: 0 };\n    }\n    if (Array.isArray(params)) {\n        return { width: Number(params[0]), height: Number(params[1]) };\n    }\n    return {\n        width: Number(params.width),\n        height: Number(params.height),\n    };\n}\nconst dimensionsValidator = (files, params) => {\n    if (isEmpty(files)) {\n        return true;\n    }\n    const { width, height } = getParams(params);\n    const list = [];\n    const fileList = Array.isArray(files) ? files : [files];\n    for (let i = 0; i < fileList.length; i++) {\n        // if file is not an image, reject.\n        if (!/\\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(fileList[i].name)) {\n            return Promise.resolve(false);\n        }\n        list.push(fileList[i]);\n    }\n    return Promise.all(list.map(file => validateImage(file, width, height))).then(values => {\n        return values.every(v => v);\n    });\n};\n\n/* eslint-disable no-useless-escape */\n// https://github.com/colinhacks/zod/blob/master/src/types.ts#L567\nconst emailRE = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_+-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nconst emailValidator = (value) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(val => emailRE.test(String(val)));\n    }\n    return emailRE.test(String(value));\n};\n\nconst extValidator = (files, extensions) => {\n    if (isEmpty(files)) {\n        return true;\n    }\n    const regex = new RegExp(`\\\\.(${extensions.join('|')})$`, 'i');\n    if (Array.isArray(files)) {\n        return files.every(file => regex.test(file.name));\n    }\n    return regex.test(files.name);\n};\n\nconst imageValidator = (files) => {\n    if (isEmpty(files)) {\n        return true;\n    }\n    const regex = /\\.(jpg|svg|jpeg|png|bmp|gif|webp)$/i;\n    if (Array.isArray(files)) {\n        return files.every(file => regex.test(file.name));\n    }\n    return regex.test(files.name);\n};\n\nconst integerValidator = (value) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(val => /^-?[0-9]+$/.test(String(val)));\n    }\n    return /^-?[0-9]+$/.test(String(value));\n};\n\nconst isValidator = (value, params) => {\n    const other = getSingleParam(params, 'other');\n    return value === other;\n};\n\nconst isNotValidator = (value, params) => {\n    const other = getSingleParam(params, 'other');\n    return value !== other;\n};\n\nconst lengthValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    // Normalize the length value\n    const length = getSingleParam(params, 'length');\n    if (typeof value === 'number') {\n        value = String(value);\n    }\n    if (!value.length) {\n        value = Array.from(value);\n    }\n    return value.length === Number(length);\n};\n\nconst maxLengthValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const length = getSingleParam(params, 'length');\n    if (Array.isArray(value)) {\n        return value.every(val => maxLengthValidator(val, { length }));\n    }\n    return [...String(value)].length <= Number(length);\n};\n\nconst maxValueValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const max = getSingleParam(params, 'max');\n    if (Array.isArray(value)) {\n        return value.length > 0 && value.every(val => maxValueValidator(val, { max }));\n    }\n    return Number(value) <= Number(max);\n};\n\nconst ADDED_MIME_RE = /\\+(.+)?/;\nfunction buildRegExp(mime) {\n    let strPattern = mime;\n    if (ADDED_MIME_RE.test(mime)) {\n        strPattern = mime.replace(ADDED_MIME_RE, '(\\\\+$1)?');\n    }\n    return new RegExp(strPattern.replace('*', '.+'), 'i');\n}\nconst mimesValidator = (files, mimes) => {\n    if (isEmpty(files)) {\n        return true;\n    }\n    if (!mimes) {\n        mimes = [];\n    }\n    const patterns = mimes.map(buildRegExp);\n    if (Array.isArray(files)) {\n        return files.every(file => patterns.some(p => p.test(file.type)));\n    }\n    return patterns.some(p => p.test(files.type));\n};\n\nconst minValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const length = getSingleParam(params, 'length');\n    if (Array.isArray(value)) {\n        return value.every(val => minValidator(val, { length }));\n    }\n    return [...String(value)].length >= Number(length);\n};\n\nconst minValueValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const min = getSingleParam(params, 'min');\n    if (Array.isArray(value)) {\n        return value.length > 0 && value.every(val => minValueValidator(val, { min }));\n    }\n    return Number(value) >= Number(min);\n};\n\nconst oneOfValidator = (value, list) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(val => oneOfValidator(val, list));\n    }\n    return Array.from(list).some(item => {\n        // eslint-disable-next-line\n        return item == value;\n    });\n};\n\nconst notOneOfValidator = (value, list) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    return !oneOfValidator(value, list);\n};\n\nconst ar = /^[]+$/;\nconst en = /^[0-9]+$/;\nconst numericValidator = (value) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    const testValue = (val) => {\n        const strValue = String(val);\n        return en.test(strValue) || ar.test(strValue);\n    };\n    if (Array.isArray(value)) {\n        return value.every(testValue);\n    }\n    return testValue(value);\n};\n\nconst regexValidator = (value, params) => {\n    if (isEmpty(value)) {\n        return true;\n    }\n    let regex = getSingleParam(params, 'regex');\n    if (typeof regex === 'string') {\n        regex = new RegExp(regex);\n    }\n    if (Array.isArray(value)) {\n        return value.every(val => regexValidator(val, { regex }));\n    }\n    return regex.test(String(value));\n};\n\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\nfunction isEmptyArray(arr) {\n    return Array.isArray(arr) && arr.length === 0;\n}\nconst isObject = (obj) => obj !== null && !!obj && typeof obj === 'object' && !Array.isArray(obj);\n\nconst requiredValidator = (value) => {\n    if (isNullOrUndefined(value) || isEmptyArray(value) || value === false) {\n        return false;\n    }\n    return !!String(value).trim().length;\n};\n\nconst sizeValidator = (files, params) => {\n    if (isEmpty(files)) {\n        return true;\n    }\n    let size = getSingleParam(params, 'size');\n    size = Number(size);\n    if (isNaN(size)) {\n        return false;\n    }\n    const nSize = size * 1024;\n    if (!Array.isArray(files)) {\n        return files.size <= nSize;\n    }\n    for (let i = 0; i < files.length; i++) {\n        if (files[i].size > nSize) {\n            return false;\n        }\n    }\n    return true;\n};\n\nconst urlValidator = (value, params) => {\n    var _a;\n    if (isEmpty(value)) {\n        return true;\n    }\n    let pattern = getSingleParam(params, 'pattern');\n    if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n    }\n    try {\n        // eslint-disable-next-line no-new\n        new URL(value);\n    }\n    catch (_b) {\n        return false;\n    }\n    return (_a = pattern === null || pattern === void 0 ? void 0 : pattern.test(value)) !== null && _a !== void 0 ? _a : true;\n};\n\n/**\n * A typed version of Object.keys\n */\nfunction keysOf(record) {\n    return Object.keys(record);\n}\n\nfunction toTypedSchema(rawSchema) {\n    const schema = {\n        __type: 'VVTypedSchema',\n        async parse(values) {\n            // single field\n            if (typeof rawSchema === 'string') {\n                const result = await validate(values, rawSchema);\n                return {\n                    errors: [\n                        {\n                            errors: result.errors,\n                        },\n                    ],\n                };\n            }\n            const result = await validateObject(rawSchema, values);\n            return {\n                errors: keysOf(result.errors).map(path => {\n                    var _a;\n                    const error = {\n                        path: path,\n                        errors: ((_a = result.results[path]) === null || _a === void 0 ? void 0 : _a.errors) || [],\n                    };\n                    return error;\n                }),\n            };\n        },\n        describe(path) {\n            if (!path) {\n                return getDescriptionFromExpression(rawSchema);\n            }\n            if (isObject(rawSchema) && path in rawSchema) {\n                return getDescriptionFromExpression(rawSchema[path]);\n            }\n            return {\n                required: false,\n                exists: false,\n            };\n        },\n    };\n    return schema;\n}\nfunction getDescriptionFromExpression(rules) {\n    if (typeof rules === 'string') {\n        return {\n            exists: true,\n            required: rules.includes('required'),\n        };\n    }\n    if (isObject(rules)) {\n        return {\n            exists: true,\n            required: !!rules.required,\n        };\n    }\n    return {\n        required: false,\n        exists: true,\n    };\n}\n\nexport { alphaValidator as alpha, alphaDashValidator as alpha_dash, alphaNumValidator as alpha_num, alphaSpacesValidator as alpha_spaces, betweenValidator as between, confirmedValidator as confirmed, digitsValidator as digits, dimensionsValidator as dimensions, emailValidator as email, extValidator as ext, imageValidator as image, integerValidator as integer, isValidator as is, isNotValidator as is_not, lengthValidator as length, maxLengthValidator as max, maxValueValidator as max_value, mimesValidator as mimes, minValidator as min, minValueValidator as min_value, notOneOfValidator as not_one_of, numericValidator as numeric, oneOfValidator as one_of, regexValidator as regex, requiredValidator as required, sizeValidator as size, toTypedSchema, urlValidator as url };\n","import { defineRule, configure } from 'vee-validate';\r\nimport { min, required } from '@vee-validate/rules';\r\n\r\nexport default defineNuxtPlugin(() => {\r\n    configure({\r\n        generateMessage: (ctx: any) => {\r\n            const messages: any = {\r\n                required: `Thng tin ny khng c  trng!`,\r\n                min: `Trng ${ctx.field} phi c t nht ${ctx.rule.params[0]} k t!`,\r\n                numeric: `Trng ${ctx.field} phi l mt s hp l!`,\r\n            };\r\n\r\n            return messages[ctx.rule.name];\r\n        },\r\n    });\r\n    defineRule('required', required);\r\n    defineRule('min', min);\r\n    defineRule('email', (value: string) => {\r\n        if (!value || !value.length) {\r\n            return true;\r\n        }\r\n        if (!/^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test(value)\r\n        ) {\r\n            return 'Vui lng nhp mt email hp l.';\r\n        }\r\n        return true;\r\n    });\r\n    defineRule('minLength', (value: string, [limit = 0]) => {\r\n        // The field is empty so it should pass\r\n        if (!value || !value.length) {\r\n            return true;\r\n        }\r\n        if (value.length < limit) {\r\n            return `This field must be at least ${limit} characters`;\r\n        }\r\n        return true;\r\n    });\r\n    defineRule('password', (value: string) => {\r\n        // Password must have at least one uppercase letter, one lowercase letter, one number, and one special character\r\n        const pattern = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).{5,}$/;\r\n        return pattern.test(value) || 'Mt khu phi c t nht 5 k t bao gm ch hoa, ch thng v s.';\r\n    });\r\n    defineRule('phone', (value: string) => {\r\n        // Vietnamese phone number pattern\r\n        const pattern = /((03|05|07|08|09|01[2|6|8|9])+([0-9]{8})|((\\+84)+([0-9]{9})))\\b/; //\\d{8}: Theo sau m u s l 8 ch s (iu ny m bo s in thoi c  10 ch s)\r\n        return pattern.test(value) || 'S in thoi khng ng.';\r\n    });\r\n    defineRule('onlyCharacters', (value: string) => {\r\n        // Regex pattern allows only letters (both uppercase and lowercase)\r\n        const pattern = /^[A-Za-z-\\s]+$/;\r\n        return pattern.test(value) || 'H tn ch c cha k t ch ci.';\r\n    });\r\n\r\n    defineRule('point', (value: string) => {\r\n        const number = parseFloat(value);\r\n        if (isNaN(number) && value != null) {\r\n            return 'Trng ny phi l mt s.';\r\n        }\r\n        if (number < 1 || number > 5) {\r\n            return 'S phi nm trong khong t 1 n 5.';\r\n        }\r\n        return true;\r\n    });\r\n    defineRule('naturalNumber', (value: string) => {\r\n        // Th chuyn i gi tr thnh s nguyn\r\n        const number = parseInt(value, 10);\r\n\r\n        // Kim tra nu gi tr khng phi l mt s hp l, khng phi s nguyn, hoc nh hn 1\r\n        if (isNaN(number) || number < 1) {\r\n            return 'Phi l s t nhin v phi ln hn hoc bng 1.';\r\n        }\r\n        return true;\r\n    });\r\n    defineRule('cost', (value: string) => {\r\n        const number = parseInt(value, 10);\r\n        // Kim tra nu gi tr khng phi l s nguyn hp l, nh hn hoc bng 0 hoc c du thp phn\r\n        if (isNaN(number) || number < 0 || value.includes('.')) {\r\n            return 'Gi tin l s nguyn dng ln hn 0, c du phy phn cch hng nghn.';\r\n        }\r\n        return true;\r\n    });\r\n    defineRule('discount', (value: string) => {\r\n        const number = parseFloat(value);\r\n        // Kim tra nu gi tr khng phi l s hp l hoc nm ngoi phm vi 0-100\r\n        if (isNaN(number) || number < 0 || number > 100) {\r\n            return 'Gim gi phi l mt s v nm trong khong t 0 n 100.';\r\n        }\r\n        return true;\r\n    });\r\n    // Quy tc \"Ngy kt thc phi ln hn ngy bt u\"\r\n    defineRule('endDateGreaterThanStart', (value: string, [startDate]: any) => {\r\n        if (!value || !startDate) return true;\r\n        const start = new Date(startDate);\r\n        const end = new Date(value);\r\n        return end > start || 'Ngy kt thc phi ln hn ngy bt u';\r\n    });\r\n    defineRule('paymentedLimit', (value: number, [totalBill]: [number]) => {\r\n        // Nu trng thi l \"Khch hng hy\", kim tra nu gi tr paymented > totalBill\r\n        if (value > totalBill) {\r\n            return 'S tin thanh ton khng c ln hn tng tin';\r\n        }\r\n        return true;\r\n    });\r\n\r\n\r\n\r\n\r\n\r\n});\r\n","import unhead_KgADcZ0jPj from \"C:/Users/doan1/Desktop/FeTour/node_modules/nuxt/dist/head/runtime/plugins/unhead.js\";\nimport router_jmwsqit4Rs from \"C:/Users/doan1/Desktop/FeTour/node_modules/nuxt/dist/pages/runtime/plugins/router.js\";\nimport revive_payload_server_eJ33V7gbc6 from \"C:/Users/doan1/Desktop/FeTour/node_modules/nuxt/dist/app/plugins/revive-payload.server.js\";\nimport components_plugin_KR1HBZs4kY from \"C:/Users/doan1/Desktop/FeTour/.nuxt/components.plugin.mjs\";\nimport bootstrap_PT9DIEO8vo from \"C:/Users/doan1/Desktop/FeTour/node_modules/usebootstrap/dist/runtime/plugins/bootstrap.mjs\";\nimport element_plus_teleports_plugin_h4Dmekbj62 from \"C:/Users/doan1/Desktop/FeTour/.nuxt/element-plus-teleports.plugin.mjs\";\nimport element_plus_injection_plugin_1RNPi6ogby from \"C:/Users/doan1/Desktop/FeTour/.nuxt/element-plus-injection.plugin.mjs\";\nimport vue_draggable_UPVdqOrVyH from \"C:/Users/doan1/Desktop/FeTour/plugins/vue-draggable.js\";\nimport api_GFfDXud5Cr from \"C:/Users/doan1/Desktop/FeTour/plugins/api.ts\";\nimport axious_tw6KwSywaj from \"C:/Users/doan1/Desktop/FeTour/plugins/axious.ts\";\nimport vee_validate_KcKlKmvCrJ from \"C:/Users/doan1/Desktop/FeTour/plugins/vee-validate.ts\";\nexport default [\n  unhead_KgADcZ0jPj,\n  router_jmwsqit4Rs,\n  revive_payload_server_eJ33V7gbc6,\n  components_plugin_KR1HBZs4kY,\n  bootstrap_PT9DIEO8vo,\n  element_plus_teleports_plugin_h4Dmekbj62,\n  element_plus_injection_plugin_1RNPi6ogby,\n  vue_draggable_UPVdqOrVyH,\n  api_GFfDXud5Cr,\n  axious_tw6KwSywaj,\n  vee_validate_KcKlKmvCrJ\n]","export default {\n  default: () => import(\"C:/Users/doan1/Desktop/FeTour/layouts/default.vue\").then(m => m.default || m)\n}","import { Suspense, Transition, computed, defineComponent, h, inject, mergeProps, nextTick, onMounted, provide, ref, unref } from \"vue\";\nimport { useRoute, useRouter } from \"../composables/router.js\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { _wrapIf } from \"./utils.js\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"./injections.js\";\nimport { useRoute as useVueRouterRoute } from \"#build/pages\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nconst LayoutLoader = defineComponent({\n  name: \"LayoutLoader\",\n  inheritAttrs: false,\n  props: {\n    name: String,\n    layoutProps: Object\n  },\n  async setup(props, context) {\n    const LayoutComponent = await layouts[props.name]().then((r) => r.default || r);\n    return () => h(LayoutComponent, props.layoutProps, context.slots);\n  }\n});\nexport default defineComponent({\n  name: \"NuxtLayout\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean, Object],\n      default: null\n    },\n    fallback: {\n      type: [String, Object],\n      default: null\n    }\n  },\n  setup(props, context) {\n    const nuxtApp = useNuxtApp();\n    const injectedRoute = inject(PageRouteSymbol);\n    const route = injectedRoute === useRoute() ? useVueRouterRoute() : injectedRoute;\n    const layout = computed(() => {\n      let layout2 = unref(props.name) ?? route.meta.layout ?? \"default\";\n      if (layout2 && !(layout2 in layouts)) {\n        if (import.meta.dev && layout2 !== \"default\") {\n          console.warn(`Invalid layout \\`${layout2}\\` selected.`);\n        }\n        if (props.fallback) {\n          layout2 = unref(props.fallback);\n        }\n      }\n      return layout2;\n    });\n    const layoutRef = ref();\n    context.expose({ layoutRef });\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    return () => {\n      const hasLayout = layout.value && layout.value in layouts;\n      const transitionProps = route.meta.layoutTransition ?? defaultLayoutTransition;\n      return _wrapIf(Transition, hasLayout && transitionProps, {\n        default: () => h(Suspense, { suspensible: true, onResolve: () => {\n          nextTick(done);\n        } }, {\n          default: () => h(\n            LayoutProvider,\n            {\n              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),\n              key: layout.value || void 0,\n              name: layout.value,\n              shouldProvide: !props.name,\n              hasTransition: !!transitionProps\n            },\n            context.slots\n          )\n        })\n      }).default();\n    };\n  }\n});\nconst LayoutProvider = defineComponent({\n  name: \"NuxtLayoutProvider\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean]\n    },\n    layoutProps: {\n      type: Object\n    },\n    hasTransition: {\n      type: Boolean\n    },\n    shouldProvide: {\n      type: Boolean\n    }\n  },\n  setup(props, context) {\n    const name = props.name;\n    if (props.shouldProvide) {\n      provide(LayoutMetaSymbol, {\n        isCurrent: (route) => name === (route.meta.layout ?? \"default\")\n      });\n    }\n    let vnode;\n    if (import.meta.dev && import.meta.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            if (name) {\n              console.warn(`[nuxt] \\`${name}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n            } else {\n              console.warn(\"[nuxt] `<NuxtLayout>` needs to be passed a single root node in its default slot.\");\n            }\n          }\n        });\n      });\n    }\n    return () => {\n      if (!name || typeof name === \"string\" && !(name in layouts)) {\n        if (import.meta.dev && import.meta.client && props.hasTransition) {\n          vnode = context.slots.default?.();\n          return vnode;\n        }\n        return context.slots.default?.();\n      }\n      if (import.meta.dev && import.meta.client && props.hasTransition) {\n        vnode = h(\n          LayoutLoader,\n          { key: name, layoutProps: props.layoutProps, name },\n          context.slots\n        );\n        return vnode;\n      }\n      return h(\n        LayoutLoader,\n        { key: name, layoutProps: props.layoutProps, name },\n        context.slots\n      );\n    };\n  }\n});\n","import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from \"vue\";\nimport { PageRouteSymbol } from \"./injections.js\";\nexport const RouteProvider = defineComponent({\n  props: {\n    vnode: {\n      type: Object,\n      required: true\n    },\n    route: {\n      type: Object,\n      required: true\n    },\n    vnodeRef: Object,\n    renderKey: String,\n    trackRootNodes: Boolean\n  },\n  setup(props) {\n    const previousKey = props.renderKey;\n    const previousRoute = props.route;\n    const route = {};\n    for (const key in props.route) {\n      Object.defineProperty(route, key, {\n        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key]\n      });\n    }\n    provide(PageRouteSymbol, shallowReactive(route));\n    let vnode;\n    if (import.meta.dev && import.meta.client && props.trackRootNodes) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = (vnode?.type).__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (import.meta.dev && import.meta.client) {\n        vnode = h(props.vnode, { ref: props.vnodeRef });\n        return vnode;\n      }\n      return h(props.vnode, { ref: props.vnodeRef });\n    };\n  }\n});\n","import { Suspense, Transition, defineComponent, h, inject, nextTick, ref, watch } from \"vue\";\nimport { RouterView } from \"#vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, toArray, wrapInKeepAlive } from \"./utils.js\";\nimport { RouteProvider } from \"#app/components/route-provider\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { useRouter } from \"#app/composables/router\";\nimport { _wrapIf } from \"#app/components/utils\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"#app/components/injections\";\nimport { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs, expose }) {\n    const nuxtApp = useNuxtApp();\n    const pageRef = ref();\n    const forkRoute = inject(PageRouteSymbol, null);\n    let previousPageKey;\n    expose({ pageRef });\n    const _layoutMeta = inject(LayoutMetaSymbol, null);\n    let vnode;\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (props.pageKey) {\n      watch(() => props.pageKey, (next, prev) => {\n        if (next !== prev) {\n          nuxtApp.callHook(\"page:loading:start\");\n        }\n      });\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtPageUsed = true;\n    }\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: (routeProps) => {\n          const isRenderingNewRouteInOldFork = import.meta.client && haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);\n          const hasSameChildren = import.meta.client && forkRoute && forkRoute.matched.length === routeProps.route.matched.length;\n          if (!routeProps.Component) {\n            if (import.meta.client && vnode && !hasSameChildren) {\n              return vnode;\n            }\n            done();\n            return;\n          }\n          if (import.meta.client && vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {\n            return vnode;\n          }\n          if (import.meta.client && isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {\n            if (hasSameChildren) {\n              return vnode;\n            }\n            return null;\n          }\n          const key = generateRouteKey(routeProps, props.pageKey);\n          if (!nuxtApp.isHydrating && !hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component) && previousPageKey === key) {\n            nuxtApp.callHook(\"page:loading:end\");\n          }\n          previousPageKey = key;\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            { onAfterLeave: () => {\n              nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n            } }\n          ].filter(Boolean));\n          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig;\n          vnode = _wrapIf(\n            Transition,\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              keepaliveConfig,\n              h(Suspense, {\n                suspensible: true,\n                onPending: () => nuxtApp.callHook(\"page:start\", routeProps.Component),\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).then(() => nuxtApp.callHook(\"page:loading:end\")).finally(done));\n                }\n              }, {\n                default: () => {\n                  const providerVNode = h(RouteProvider, {\n                    key: key || void 0,\n                    vnode: routeProps.Component,\n                    route: routeProps.route,\n                    renderKey: key || void 0,\n                    trackRootNodes: hasTransition,\n                    vnodeRef: pageRef\n                  });\n                  if (import.meta.client && keepaliveConfig) {\n                    providerVNode.type.name = routeProps.Component.type.name || routeProps.Component.type.__name || \"RouteProvider\";\n                  }\n                  return providerVNode;\n                }\n              })\n            )\n          ).default();\n          return vnode;\n        }\n      });\n    };\n  }\n});\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.map((prop) => ({\n    ...prop,\n    onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : void 0\n  }));\n  return defu(..._props);\n}\nfunction haveParentRoutesRendered(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  if (!index || index === -1) {\n    return false;\n  }\n  return newRoute.matched.slice(0, index).some(\n    (c, i) => c.components?.default !== fork.matched[i]?.components?.default\n  ) || Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component });\n}\nfunction hasChildrenRoutes(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  return index < newRoute.matched.length - 1;\n}\n","<template>\r\n    <div>\r\n        <NuxtLayout>\r\n            <NuxtPage />\r\n        </NuxtLayout>\r\n    </div>\r\n</template>\r\n<script setup>\r\n\r\n</script>\r\n","<template>\n  <ErrorTemplate v-bind=\"{ statusCode, statusMessage, description, stack }\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from 'vue'\n\nconst props = defineProps({\n  error: Object\n})\n\n// Deliberately prevent reactive update when error is cleared\nconst _error = props.error\n\n// TODO: extract to a separate utility\nconst stacktrace = _error.stack\n  ? _error.stack\n    .split('\\n')\n    .splice(1)\n    .map((line) => {\n      const text = line\n        .replace('webpack:/', '')\n        .replace('.vue', '.js') // TODO: Support sourcemap\n        .trim()\n      return {\n        text,\n        internal: (line.includes('node_modules') && !line.includes('.cache')) ||\n          line.includes('internal') ||\n          line.includes('new Promise')\n      }\n    }).map(i => `<span class=\"stack${i.internal ? ' internal' : ''}\">${i.text}</span>`).join('\\n')\n  : ''\n\n// Error page props\nconst statusCode = Number(_error.statusCode || 500)\nconst is404 = statusCode === 404\n\nconst statusMessage = _error.statusMessage ?? (is404 ? 'Page Not Found' : 'Internal Server Error')\nconst description = _error.message || _error.toString()\nconst stack = import.meta.dev && !is404 ? _error.description || `<pre>${stacktrace}</pre>` : undefined\n\n// TODO: Investigate side-effect issue with imports\nconst _Error404 = defineAsyncComponent(() => import('@nuxt/ui-templates/templates/error-404.vue').then(r => r.default || r))\nconst _Error = import.meta.dev\n  ? defineAsyncComponent(() => import('@nuxt/ui-templates/templates/error-dev.vue').then(r => r.default || r))\n  : defineAsyncComponent(() => import('@nuxt/ui-templates/templates/error-500.vue').then(r => r.default || r))\n\nconst ErrorTemplate = is404 ? _Error404 : _Error\n</script>\n","<template>\n  <Suspense @resolve=\"onResolve\">\n    <ErrorComponent\n      v-if=\"error\"\n      :error=\"error\"\n    />\n    <IslandRenderer\n      v-else-if=\"islandContext\"\n      :context=\"islandContext\"\n    />\n    <component\n      :is=\"SingleRenderer\"\n      v-else-if=\"SingleRenderer\"\n    />\n    <AppComponent v-else />\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent, onErrorCaptured, onServerPrefetch, provide } from 'vue'\nimport { useNuxtApp } from '../nuxt'\nimport { isNuxtError, showError, useError } from '../composables/error'\nimport { useRoute, useRouter } from '../composables/router'\nimport { PageRouteSymbol } from '../components/injections'\nimport AppComponent from '#build/app-component.mjs'\nimport ErrorComponent from '#build/error-component.mjs'\n// @ts-expect-error virtual file\nimport { componentIslands } from '#build/nuxt.config.mjs'\n\nconst IslandRenderer = import.meta.server && componentIslands\n  ? defineAsyncComponent(() => import('./island-renderer').then(r => r.default || r))\n  : () => null\n\nconst nuxtApp = useNuxtApp()\nconst onResolve = nuxtApp.deferHydration()\nif (import.meta.client && nuxtApp.isHydrating) {\n  const removeErrorHook = nuxtApp.hooks.hookOnce('app:error', onResolve)\n  useRouter().beforeEach(removeErrorHook)\n}\n\nconst url = import.meta.server ? nuxtApp.ssrContext.url : window.location.pathname\nconst SingleRenderer = import.meta.test && import.meta.dev && import.meta.server && url.startsWith('/__nuxt_component_test__/') && defineAsyncComponent(() => import('#build/test-component-wrapper.mjs')\n  .then(r => r.default(import.meta.server ? url : window.location.href)))\n\n// Inject default route (outside of pages) as active route\nprovide(PageRouteSymbol, useRoute())\n\n// vue:setup hook\nconst results = nuxtApp.hooks.callHookWith(hooks => hooks.map(hook => hook()), 'vue:setup')\nif (import.meta.dev && results && results.some(i => i && 'then' in i)) {\n  console.error('[nuxt] Error in `vue:setup`. Callbacks must be synchronous.')\n}\n\n// error handling\nconst error = useError()\nonErrorCaptured((err, target, info) => {\n  nuxtApp.hooks.callHook('vue:error', err, target, info).catch(hookError => console.error('[nuxt] Error in `vue:error` hook', hookError))\n  if (import.meta.server || (isNuxtError(err) && (err.fatal || err.unhandled))) {\n    const p = nuxtApp.runWithContext(() => showError(err))\n    onServerPrefetch(() => p)\n    return false // suppress error from breaking render\n  }\n})\n\n// Component islands context\nconst islandContext = import.meta.server && nuxtApp.ssrContext.islandContext\n</script>\n","import { createApp, createSSRApp, nextTick } from \"vue\";\nimport \"#build/paths.mjs\";\nimport \"#build/fetch.mjs\";\nimport { applyPlugins, createNuxtApp } from \"./nuxt.js\";\nimport { createError } from \"./composables/error.js\";\nimport \"#build/css\";\nimport plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { vueAppRootContainer } from \"#build/nuxt.config.mjs\";\nlet entry;\nif (import.meta.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (error) {\n      await nuxt.hooks.callHook(\"app:error\", error);\n      nuxt.payload.error = nuxt.payload.error || createError(error);\n    }\n    if (ssrContext?._renderResponse) {\n      throw new Error(\"skipping render\");\n    }\n    return vueApp;\n  };\n}\nif (import.meta.client) {\n  if (import.meta.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  let vueAppPromise;\n  entry = async function initApp() {\n    if (vueAppPromise) {\n      return vueAppPromise;\n    }\n    const isSSR = Boolean(\n      window.__NUXT__?.serverRendered || document.getElementById(\"__NUXT_DATA__\")?.dataset.ssr === \"true\"\n    );\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    async function handleVueError(error) {\n      await nuxt.callHook(\"app:error\", error);\n      nuxt.payload.error = nuxt.payload.error || createError(error);\n    }\n    vueApp.config.errorHandler = handleVueError;\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      handleVueError(err);\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(vueAppRootContainer);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      handleVueError(err);\n    }\n    if (vueApp.config.errorHandler === handleVueError) {\n      vueApp.config.errorHandler = void 0;\n    }\n    return vueApp;\n  };\n  vueAppPromise = entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n    throw error;\n  });\n}\nexport default (ssrContext) => entry(ssrContext);\n"],"names":["useRuntimeConfig","plugin","provide","plugins","_a","createH3Error","ref","entry","globalKey","generateRouteKey","toArray","createRadixRouter","indexzc5bUCA1PZMeta","indexk0KrxXnq23Meta","index66DuR8OpPIMeta","indexwJXpYU1uE2Meta","index4twE8aghL4Meta","indexPwtMYXqADvMeta","indexDKRhpt2WUqMeta","DashboardMQtclcGVyYMeta","index3doNfbYmFAMeta","indexQFS8UuDefUMeta","LoginnA5DhZTgawMeta","indexLlkwI5GDNsMeta","indexT2RRD80e9XMeta","_91id_93YPi7dvCebxMeta","indexn3uAJjZTH5Meta","indexcarUxwjvFJMeta","indexM0sA6R6T0uMeta","defaultPageTransition","__executeAsync","validate","createRouter","_b","_c","createError","isNullOrUndefined","keys","length","errors","setState","state","resolveInitialValue","value","key","validate$1","opts","id","warn$1","values","onSubmit","required","min","router_jmwsqit4Rs","useVueRouterRoute","defaultLayoutTransition","defaultKeepaliveConfig","_ssrRenderAttrs","_ssrRenderComponent","_withCtx","_push","_parent"],"mappings":";;;;;;;;;;;;;;;;;;;;AAEA,MAAM,YAAYA,mBAAgB,EAAG;AAC9B,MAAM,UAAU,MAAM,UAAU;ACDvC,IAAI,CAAC,WAAW,QAAQ;AACtB,aAAW,SAAS,OAAO,OAAO;AAAA,IAChC,SAAS,QAAS;AAAA,EACtB,CAAG;AACH;ACHA,MAAM,wCAAwC,YAAY;AAAA,EACxD,cAAc;AAChB,CAAC;AACM,MAAM,sBAAsB;AAC5B,SAAS,cAAc,SAAS;AACrC,MAAI,iBAAiB;AACrB,QAAM,UAAU;AAAA,IACd,QAAQ,YAAY;AAAA,IACpB,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,UAAU;AAAA,MACR,IAAI,OAAO;AACF,eAAA;AAAA,MACT;AAAA,MACA,IAAI,MAAM;AACR,eAAO,QAAQ,OAAO;AAAA,MACxB;AAAA,IACF;AAAA,IACA,SAAS,SAAS;AAAA,MAChB,MAAM,CAAC;AAAA,MACP,OAAO,CAAC;AAAA,MACR,0BAA0B,IAAI;AAAA,MAC9B,SAAS,CAAC;AAAA,MACV,GAAgD,EAAE,gBAAgB,KAAK;AAAA,IAAA,CACxE;AAAA,IACD,QAAQ;AAAA,MACN,MAAM,CAAC;AAAA,IACT;AAAA,IACA,gBAAgB,CAAC,OAAO,QAAQ,OAAO,IAAI,MAAM,aAAa,SAAS,EAAE,CAAC;AAAA,IAC1E,aAAa;AAAA,IACb,iBAAiB;AACX,UAAA,CAAC,QAAQ,aAAa;AACxB,eAAO,MAAM;AAAA,QAAA;AAAA,MAEf;AACA;AACA,UAAI,SAAS;AACb,aAAO,MAAM;AACX,YAAI,QAAQ;AACV;AAAA,QACF;AACS,iBAAA;AACT;AACA,YAAI,mBAAmB,GAAG;AACxB,kBAAQ,cAAc;AACf,iBAAA,QAAQ,SAAS,sBAAsB;AAAA,QAChD;AAAA,MAAA;AAAA,IAEJ;AAAA,IACA,oBAAoB,CAAC;AAAA,IACrB,YAAY,CAAC;AAAA,IACb,kBAAkB,CAAC;AAAA,IACnB,GAAG;AAAA,EAAA;AAEL,UAAQ,QAAQ;AACR,UAAA,OAAO,QAAQ,MAAM;AACL;AAChB,UAAA,gBAAgB,eAAe,OAAO,MAAM;AAChD,iBAAW,QAAQ,OAAO;AACxB,cAAM,QAAQ,eAAe,MAAM,KAAK,GAAG,IAAI,CAAC;AAAA,MAClD;AAAA,IAAA;AAEM,YAAA,MAAM,WAAW,CAAC,SAAS,SAAS,QAAQ,MAAM,aAAa,eAAe,MAAM,GAAG,IAAI;AAAA,EACrG;AACQ,UAAA,WAAW,QAAQ,MAAM;AACzB,UAAA,UAAU,CAAC,MAAM,UAAU;AACjC,UAAM,QAAQ,MAAM;AACP,iBAAA,SAAS,OAAO,KAAK;AAClC,iBAAa,QAAQ,OAAO,OAAO,kBAAkB,OAAO,KAAK;AAAA,EAAA;AAEtD,eAAA,QAAQ,QAAQ,SAAS,OAAO;AAC7C,eAAa,QAAQ,OAAO,OAAO,kBAAkB,SAAS,OAAO;AAC7C;AACtB,QAAI,QAAQ,YAAY;AACtB,cAAQ,WAAW,OAAO;AAClB,cAAA,WAAW,mBAAmB;AAC9B,cAAA,QAAQ,OAAO,QAAQ,WAAW;AAAA,IAC5C;AACQ,YAAA,aAAa,QAAQ,cAAc,CAAA;AACvC,QAAA,QAAQ,WAAW,SAAS;AAC9B,aAAO,OAAO,QAAQ,SAAS,QAAQ,WAAW,OAAO;AAAA,IAC3D;AACQ,YAAA,WAAW,UAAU,QAAQ;AACrC,YAAQ,WAAW,SAAS;AAAA,MAC1B,QAAQ,QAAQ,WAAW,cAAc;AAAA,MACzC,KAAK,QAAQ,WAAW,cAAc;AAAA,IAAA;AAAA,EAE1C;AAWM,QAAA,gBAAqC,QAAQ,WAAW;AACtD,UAAA,QAAQ,UAAU,aAAa;AAChC,SAAA;AACT;AACsB,eAAA,YAAY,SAASC,SAAQ;AACjD,MAAIA,QAAO,OAAO;AACR,YAAA,MAAM,SAASA,QAAO,KAAK;AAAA,EACrC;AACI,MAAA,OAAOA,YAAW,YAAY;AAC1B,UAAA,EAAE,SAAAC,aAAY,MAAM,QAAQ,eAAe,MAAMD,QAAO,OAAO,CAAC,KAAK;AACvE,QAAAC,YAAW,OAAOA,aAAY,UAAU;AAC1C,iBAAW,OAAOA,UAAS;AACzB,gBAAQ,QAAQ,KAAKA,SAAQ,GAAG,CAAC;AAAA,MACnC;AAAA,IACF;AAAA,EACF;AACF;AACsB,eAAA,aAAa,SAASC,UAAS;;AACnD,QAAM,kBAAkB,CAAA;AACxB,QAAM,oBAAoB,CAAA;AAC1B,QAAM,YAAY,CAAA;AAClB,QAAM,SAAS,CAAA;AACf,MAAI,eAAe;AACnB,iBAAe,cAAcF,SAAQ;;AAC7B,UAAA,mCAAiCG,MAAAH,QAAO,cAAP,gBAAAG,IAAkB,OAAO,CAAC,SAASD,SAAQ,KAAK,CAAC,MAAM,EAAE,UAAU,IAAI,KAAK,CAAC,gBAAgB,SAAS,IAAI,OAAM;AACnJ,QAAA,+BAA+B,SAAS,GAAG;AAC7C,wBAAkB,KAAK,CAAC,IAAI,IAAI,8BAA8B,GAAGF,OAAM,CAAC;AAAA,IAAA,OACnE;AACL,YAAM,UAAU,YAAY,SAASA,OAAM,EAAE,KAAK,YAAY;AAC5D,YAAIA,QAAO,OAAO;AACA,0BAAA,KAAKA,QAAO,KAAK;AAC3B,gBAAA,QAAQ,IAAI,kBAAkB,IAAI,OAAO,CAAC,WAAW,gBAAgB,MAAM;AAC/E,gBAAI,UAAU,IAAIA,QAAO,KAAK,GAAG;AACrB,wBAAA,OAAOA,QAAO,KAAK;AACzB,kBAAA,UAAU,SAAS,GAAG;AACxB;AACA,sBAAM,cAAc,gBAAgB;AAAA,cACtC;AAAA,YACF;AAAA,UACD,CAAA,CAAC;AAAA,QACJ;AAAA,MAAA,CACD;AACD,UAAIA,QAAO,UAAU;AACT,kBAAA,KAAK,QAAQ,MAAM,CAAC,MAAM,OAAO,KAAK,CAAC,CAAC,CAAC;AAAA,MAAA,OAC9C;AACC,cAAA;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,aAAWA,WAAUE,UAAS;AAC5B,UAA0B,aAAQ,eAAR,mBAAoB,oBAAiB,KAAAF,QAAO,QAAP,mBAAY,aAAY,OAAO;AAC5F;AAAA,IACF;AACA,UAAM,cAAcA,OAAM;AAAA,EAC5B;AACM,QAAA,QAAQ,IAAI,SAAS;AAC3B,MAAI,cAAc;AAChB,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AAC/B,YAAA,QAAQ,IAAI,SAAS;AAAA,IAC7B;AAAA,EACF;AACA,MAAI,OAAO,QAAQ;AACjB,UAAM,OAAO,CAAC;AAAA,EAChB;AACF;AAAA;AAEO,SAAS,iBAAiBA,SAAQ;AACnC,MAAA,OAAOA,YAAW,YAAY;AACzB,WAAAA;AAAA,EACT;AACM,QAAA,QAAQA,QAAO,SAASA,QAAO;AACrC,SAAOA,QAAO;AACd,SAAO,OAAO,OAAOA,QAAO,UAAU,MAAM;AAAA,EAAA,IACxCA,SAAQ,EAAE,CAAC,mBAAmB,GAAG,MAAM,OAAO;AACpD;AAKgB,SAAA,aAAa,MAAM,OAAO,MAAM;AAC9C,QAAM,KAAK,MAAM,OAAO,MAAM,GAAG,IAAI,IAAI;AACjB;AACf,WAAA,KAAK,OAAO,eAAe,MAAM,WAAW,UAAU,MAAM,EAAE,CAAC;AAAA,EAIxE;AACF;AAAA;AAEO,SAAS,gBAAgB;;AAC1B,MAAA;AACJ,MAAI,uBAAuB;AACP,uBAAA,wBAAsB,MAAtB,mBAAsB,WAAW,IAAI;AAAA,EACzD;AACkB,oBAAA,mBAAmB,WAAW;AAChD,SAAO,mBAAmB;AAC5B;AAAA;AAEO,SAAS,aAAa;AAC3B,QAAM,kBAAgD;AACtD,MAAI,CAAC,iBAAiB;AAGb;AACC,YAAA,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AAAA,EACF;AACO,SAAA;AACT;AAAA;AAEO,SAAS,iBAAiB,QAAQ;AACvC,qCAAsC,GAAA;AACxC;AACA,SAAS,aAAa,KAAK,KAAK,KAAK;AACnC,SAAO,eAAe,KAAK,KAAK,EAAE,KAAK,MAAM,KAAK;AACpD;ACxNO,MAAM,mBAAmB,OAAO,aAAa;AAC7C,MAAM,kBAAkB,OAAO,OAAO;ACKtC,MAAM,YAAY,MAAM;;AAC7B,UAAO,gCAAc,MAAd,mBAAc;AACvB;AACO,MAAM,WAAW,MAAM;AAI5B,MAAI,uBAAuB;AACzB,WAAO,OAAO,kBAAiB,2BAAW,GAAE,MAAM;AAAA,EACpD;AACA,UAAO,2BAAa,GAAA;AACtB;AAAA;AAeO,SAAS,0BAA0B,YAAY;AAC7C,SAAA;AACT;AAeA,MAAM,yBAAyB,MAAM;AAC/B,MAAA;AACE,SAAA,8BAAa,uBAAuB;AAC/B,aAAA;AAAA,IACT;AAAA,EAAA,QACM;AACC,WAAA;AAAA,EACT;AACO,SAAA;AACT;AACa,MAAA,aAAa,CAAC,IAAI,YAAY;AACzC,MAAI,CAAC,IAAI;AACF,SAAA;AAAA,EACP;AACA,QAAM,SAAS,OAAO,OAAO,WAAW,KAAK,UAAU,GAAG,QAAQ,KAAK,GAAG,SAAS,CAAE,CAAA,KAAK,GAAG,QAAQ;AACrG,MAAI,mCAAS,MAAM;AAMjB,WAAO,QAAQ;EACjB;AACM,QAAA,cAAa,mCAAS,aAAY,YAAY,QAAQ,EAAE,gBAAgB,MAAM;AACpF,MAAI,YAAY;AACV,QAAA,EAAC,mCAAS,WAAU;AAChB,YAAA,IAAI,MAAM,qGAAqG;AAAA,IACvH;AACM,UAAA,WAAW,SAAS,MAAM,EAAE;AAC9B,QAAA,YAAY,iBAAiB,QAAQ,GAAG;AAC1C,YAAM,IAAI,MAAM,kCAAkC,QAAQ,aAAa;AAAA,IACzE;AAAA,EACF;AACA,QAAM,eAAe;AAIrB,QAAM,SAAS;AACf,QAAM,UAAU;AACQ;AACtB,QAAI,QAAQ,YAAY;AAChB,YAAA,WAAW,OAAO,OAAO,YAAY,aAAa,SAAS,OAAO,QAAQ,EAAE,EAAE,YAAY;AAC1F,YAAA,YAAY,aAAa,SAAS,SAAQ,oCAAmB,IAAI,SAAS,QAAQ;AAClF,YAAA,WAAW,eAAe,UAAU;AAClC,cAAA,QAAQ,SAAS,gBAAgB;AACvC,cAAM,aAAa,UAAU,QAAQ,MAAM,KAAK;AAChD,gBAAQ,WAAW,kBAAkB;AAAA,UACnC,YAAY,oBAAmB,mCAAS,iBAAgB,KAAK,GAAG;AAAA,UAChE,MAAM,yEAAyE,UAAU;AAAA,UACzF,SAAS,EAAE,UAAU,UAAU;AAAA,QAAA;AAE1B,eAAA;AAAA,MAAA;AAEL,UAAA,CAAC,cAAc,cAAc;AACxB,eAAA,UAAU,CAAC,UAAU,MAAM,aAAa,WAAW,SAAS,KAAK,IAAI,MAAM;AAC3E,eAAA;AAAA,MACT;AACO,aAAA,SAAS,CAAC,eAAe;AAAA;AAAA,QAE9B;AAAA,OACD;AAAA,IACH;AAAA,EACF;AACA,MAAI,YAAY;AACd,YAAQ,OAAO;AACf,QAAI,mCAAS,SAAS;AACpB,MAAA,SAAS,QAAQ,MAAM;AAAA,IAAA,OAClB;AACL,MAAA,SAAS,OAAO;AAAA,IAClB;AACA,QAAI,cAAc;AACZ,UAAA,CAAC,QAAQ,aAAa;AACjB,eAAA;AAAA,MACT;AACO,aAAA,IAAI,QAAQ,MAAM;AAAA,MAAA,CACxB;AAAA,IACH;AACA,WAAO,QAAQ;EACjB;AACO,UAAA,mCAAS,WAAU,OAAO,QAAQ,EAAE,IAAI,OAAO,KAAK,EAAE;AAC/D;AC7HO,MAAM,uBAAuB;AAC7B,MAAM,WAAW,MAAM,OAAM,2BAAY,GAAC,SAAS,OAAO;AAC1D,MAAM,YAAY,CAAC,UAAU;AAClC,QAAM,YAAY,YAAY,KAAK;AACnC,MAAI;AACF,UAAM,UAAU;AAChB,UAAM,SAAS;AACf,QAAI;AAAoB;AAGxB,WAAO,QAAQ,OAAO,SAAS;AAAA,EACnC,QAAU;AACN,UAAM;AAAA,EACP;AACD,SAAO;AACT;AAUO,MAAM,cAAc,CAAC,UAAU,CAAC,CAAC,SAAS,OAAO,UAAU,YAAY,wBAAwB;AAC/F,MAAM,cAAc,CAAC,UAAU;AACpC,QAAM,YAAYI,cAAc,KAAK;AACrC,SAAO,eAAe,WAAW,sBAAsB;AAAA,IACrD,OAAO;AAAA,IACP,cAAc;AAAA,IACd,UAAU;AAAA,EACd,CAAG;AACD,SAAO;AACT;AClCa,QAAQ,WAAW,GAAG;AAEnC,SAAS,aAAa,GAAG;AACvB,SAAO,OAAO,MAAM,aAAa,EAAE,IAAI,MAAM,CAAC;AAChD;AACA,SAAS,sBAAsBC,MAAK,UAAU,IAAI;AAChD,MAAIA,gBAAe;AACV,WAAAA;AACH,QAAA,OAAO,aAAaA,IAAG;AACzB,MAAA,CAACA,QAAO,CAAC;AACJ,WAAA;AACL,MAAA,MAAM,QAAQ,IAAI;AACpB,WAAO,KAAK,IAAI,CAAC,MAAM,sBAAsB,GAAG,OAAO,CAAC;AACtD,MAAA,OAAO,SAAS,UAAU;AAC5B,WAAO,OAAO;AAAA,MACZ,OAAO,QAAQ,IAAI,EAAE,IAAI,CAAC,CAAC,GAAG,CAAC,MAAM;AACnC,YAAI,MAAM,mBAAmB,EAAE,WAAW,IAAI;AAC5C,iBAAO,CAAC,GAAG,MAAM,CAAC,CAAC;AACrB,eAAO,CAAC,GAAG,sBAAsB,GAAG,CAAC,CAAC;AAAA,MAAA,CACvC;AAAA,IAAA;AAAA,EAEL;AACO,SAAA;AACT;AAE4B,iBAAiB;AAAA,EAC3C,OAAO;AAAA,IACL,mBAAmB,SAAS,KAAK;AAC/B,iBAAWC,UAAS,IAAI;AAChB,QAAAA,OAAA,gBAAgB,sBAAsBA,OAAM,KAAK;AAAA,IAC3D;AAAA,EACF;AACF,CAAC;AAED,MAAM,aAAa;AA2BnB,MAAM,UAAU,OAAO,eAAe,cAAc,aAAsD,OAAO,WAAW,cAAc,SAAS,OAAO,SAAS,cAAc,OAAO,CAAA;AACxL,MAAMC,cAAY;AAClB,SAAS,wBAAwB,SAAS;AACxC,UAAQA,WAAS,IAAI;AACvB;AACA,SAAS,aAAa;AACpB,MAAIA,eAAa,SAAS;AACjB,WAAA,QAAQA,WAAS;EAC1B;AACM,QAAA,OAAO,OAAO,UAAU;AAC9B,MAAI,CAAC,QAAQ,QAAQ,IAAI,aAAa;AACpC,YAAQ,KAAK,kGAAkG;AACjH,SAAO,QAAQ;AACjB;AC1EA,MAAA,oBAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,SAAS;AAAA,EACT,MAAM,SAAS;AACb,UAAM,OAA4B,QAAQ,WAAW;AAGrD;AAAA;AAAA,MAEE,OAAM,2BAAU,GAAG,OAAO,SAAS,SAAS;AAAA,IAClD;AACI,YAAQ,OAAO,IAAI,IAAI;AAAA,EAqBxB;AACH,CAAC;ACrCD,SAAS,cAAc,OAAO,IAAI;AAC5B,MAAA;AACJ,MAAI,cAAc;AACZ,QAAA,gBAAgB,CAAC,aAAa;AAC9B,QAAA,mBAAmB,oBAAoB,UAAU;AAC7C,YAAA,IAAI,MAAM,kBAAkB;AAAA,IACpC;AAAA,EAAA;AAEE,MAAA;AACJ,MAAI,KAAK,cAAc;AACf,UAAA,qBAAqB,KAAK,qBAAqB,WAAW;AAChE,QAAI,oBAAoB;AACtB,YAAM,IAAI;IAAmB,OACxB;AACL,cAAQ,KAAK,8CAA8C;AAAA,IAC7D;AAAA,EACF;AACA,QAAM,sBAAsB,MAAM;AAC5B,QAAA,OAAO,oBAAoB,QAAQ;AAC/B,YAAA,WAAW,IAAI;AACrB,UAAI,aAAa,QAAQ;AAChB,eAAA;AAAA,MACT;AAAA,IACF;AACO,WAAA;AAAA,EAAA;AAEF,SAAA;AAAA,IACL,KAAK,MAAM;AACT,YAAM,YAAY;AAClB,UAAI,cAAc,QAAQ;AAClB,cAAA,IAAI,MAAM,0BAA0B;AAAA,MAC5C;AACO,aAAA;AAAA,IACT;AAAA,IACA,QAAQ,MAAM;AACZ,aAAO,oBAAoB;AAAA,IAC7B;AAAA,IACA,KAAK,CAAC,UAAU,YAAY;AAC1B,UAAI,CAAC,SAAS;AACZ,sBAAc,QAAQ;AAAA,MACxB;AACkB,wBAAA;AACJ,oBAAA;AAAA,IAChB;AAAA,IACA,OAAO,MAAM;AACO,wBAAA;AACJ,oBAAA;AAAA,IAChB;AAAA,IACA,MAAM,CAAC,UAAU,aAAa;AAC5B,oBAAc,QAAQ;AACJ,wBAAA;AACd,UAAA;AACF,eAAO,MAAM,IAAI,IAAI,UAAU,QAAQ,IAAI;MAAS,UACpD;AACA,YAAI,CAAC,aAAa;AACE,4BAAA;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AAAA,IACA,MAAM,UAAU,UAAU,UAAU;AAChB,wBAAA;AAClB,YAAM,YAAY,MAAM;AACJ,0BAAA;AAAA,MAAA;AAEpB,YAAM,UAAU,MAAM,oBAAoB,WAAW,YAAY;AACjE,oBAAc,IAAI,OAAO;AACrB,UAAA;AACF,cAAM,IAAI,MAAM,IAAI,IAAI,UAAU,QAAQ,IAAI;AAC9C,YAAI,CAAC,aAAa;AACE,4BAAA;AAAA,QACpB;AACA,eAAO,MAAM;AAAA,MAAA,UACb;AACA,sBAAc,OAAO,OAAO;AAAA,MAC9B;AAAA,IACF;AAAA,EAAA;AAEJ;AACA,SAAS,gBAAgB,cAAc,IAAI;AACzC,QAAM,WAAW,CAAA;AACV,SAAA;AAAA,IACL,IAAI,KAAK,OAAO,IAAI;AACd,UAAA,CAAC,SAAS,GAAG,GAAG;AACT,iBAAA,GAAG,IAAI,cAAc,EAAE,GAAG,aAAa,GAAG,MAAM;AAAA,MAC3D;AACA,eAAS,GAAG;AACZ,aAAO,SAAS,GAAG;AAAA,IACrB;AAAA,EAAA;AAEJ;AACA,MAAM,cAAc,OAAO,eAAe,cAAc,aAAa,OAAO,SAAS,cAAc,OAAO,OAAO,WAAW,cAAc,SAAkD,CAAA;AAC5L,MAAM,YAAY;AACO,YAAY,SAAS,MAAM,YAAY,SAAS,IAAI,gBAAgB;AAG7F,MAAM,mBAAmB;AACzB,MAAM,gBAAgB,YAAY,gBAAgB,MAAM,YAAY,gBAAgB,wBAAwB,IAAI;AAChH,SAAS,aAAa,WAAW;AAC/B,QAAM,WAAW,CAAA;AACjB,aAAW,gBAAgB,eAAe;AACxC,UAAM,WAAW;AACjB,QAAI,UAAU;AACZ,eAAS,KAAK,QAAQ;AAAA,IACxB;AAAA,EACF;AACA,QAAM,UAAU,MAAM;AACpB,eAAW,YAAY,UAAU;AACtB;IACX;AAAA,EAAA;AAEF,MAAI,YAAY;AAChB,MAAI,aAAa,OAAO,cAAc,YAAY,WAAW,WAAW;AAC1D,gBAAA,UAAU,MAAM,CAAC,UAAU;AAC7B;AACF,YAAA;AAAA,IAAA,CACP;AAAA,EACH;AACO,SAAA,CAAC,WAAW,OAAO;AAC5B;ACrHA,MAAM,kBAAkB,CAAC,OAAO,UAAU;AACxC,SAAO,MAAM,KAAK,QAAQ,oBAAoB,IAAI,EAAE,QAAQ,gBAAgB,IAAI,EAAE,QAAQ,SAAS,CAAC,MAAM;;AAAA,wBAAM,OAAO,EAAE,MAAM,CAAC,CAAC,MAAvB,mBAA0B,eAAc;AAAA,GAAE;AACtJ;AACO,MAAMC,qBAAmB,CAAC,YAAY,aAAa;AACxD,QAAM,eAAe,WAAW,MAAM,QAAQ,KAAK,CAAC;;AAAM,oBAAE,eAAF,mBAAc,aAAY,WAAW,UAAU;AAAA,GAAI;AAC7G,QAAM,SAAS,aAAY,6CAAc,KAAK,SAAQ,gBAAgB,gBAAgB,WAAW,OAAO,YAAY;AACpH,SAAO,OAAO,WAAW,aAAa,OAAO,WAAW,KAAK,IAAI;AACnE;AACO,MAAM,kBAAkB,CAAC,OAAO,aAAa;AAClD,SAAO,EAAE,SAAS,MAA0F;AAC9G;AACO,SAASC,UAAQ,OAAO;AAC7B,SAAO,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAC9C;ACNO,MAAM,sBAAsB;AAE5B,MAAM,oBAAoB;AAI1B,MAAM,eAAe;AA8BhB,MAAC,mBAAmB,EAAC,iBAAgB,WAAU;ACnBpD,eAAe,cAAc,KAAK;AACf;AACtB,UAAM,qBAAqB;AAAA,MACzBC,aAAkB,EAAE,SAAQ,iCAAkB,GAAC,MAAM,WAAU,CAAE;AAAA,IACvE;AACI,WAAO,KAAK,CAAE,GAAE,GAAG,mBAAmB,SAAS,GAAG,EAAE,QAAO,CAAE;AAAA,EAC9D;AAGH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA,MAAe,UAAA;AAAA,EACb;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAuD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC1G;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAuD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC1G;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAuD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC1G;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAuD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC1G;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAwD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC3G;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA+D,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAClH;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA8D,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EACjH;AAAA,EACD;AAAA,IACE,OAAMC,yDAAyB,SAAQ;AAAA,IACvC,OAAMA,yDAAyB,SAAQ;AAAA,IACvC,MAAMA,sBAA2B,CAAE;AAAA,IACnC,QAAOA,yDAAyB,UAAS,CAAE;AAAA,IAC3C,UAAUA,yDAAyB;AAAA,IACnC,WAAW,MAAM,OAAO,+BAAmD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EACtG;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAqD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EACxG;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA+C,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAClG;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA+C,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAClG;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAuD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC1G;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA+D,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAClH;AAAA,EACD;AAAA,IACE,OAAMC,yDAAwB,SAAQ;AAAA,IACtC,OAAMA,yDAAwB,SAAQ;AAAA,IACtC,MAAMA,sBAA0B,CAAE;AAAA,IAClC,QAAOA,yDAAwB,UAAS,CAAE;AAAA,IAC1C,UAAUA,yDAAwB;AAAA,IAClC,WAAW,MAAM,OAAO,0BAAsD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EACzG;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAAoD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EACvG;AAAA,EACD;AAAA,IACE,OAAMC,yDAAqB,SAAQ;AAAA,IACnC,OAAMA,yDAAqB,SAAQ;AAAA,IACnC,MAAMA,sBAAuB,CAAE;AAAA,IAC/B,QAAOA,yDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,yDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA4D,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC/G;AAAA,EACD;AAAA,IACE,OAAMC,qDAAqB,SAAQ;AAAA,IACnC,OAAMA,qDAAqB,SAAQ;AAAA,IACnC,MAAMA,oBAAuB,CAAE;AAAA,IAC/B,QAAOA,qDAAqB,UAAS,CAAE;AAAA,IACvC,UAAUA,qDAAqB;AAAA,IAC/B,WAAW,MAAM,OAAO,2BAA0D,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AAAA,EAC7G;AACH;ACvJO,MAAM,UAAU,CAAC,WAAW,OAAO,UAAU;AAClD,UAAQ,UAAU,OAAO,CAAA,IAAK;AAC9B,SAAO,EAAE,SAAS;;AAAM,mBAAQ,EAAE,WAAW,OAAO,KAAK,KAAI,WAAM,YAAN;AAAA,IAAiB;AAChF;AACA,SAAS,iBAAiB,OAAO;AAC/B,QAAM,UAAS,+BAAO,KAAK,QAAO,MAAM,KAAK,QAAQ,oBAAoB,IAAI,EAAE,QAAQ,gBAAgB,IAAI,EAAE,QAAQ,SAAS,CAAC,MAAM;;AAAA,wBAAM,OAAO,EAAE,MAAM,CAAC,CAAC,MAAvB,mBAA0B,eAAc;AAAA,GAAE;AAC/K,SAAO,OAAO,WAAW,aAAa,OAAO,KAAK,IAAI;AACxD;AACO,SAAS,eAAe,IAAI,MAAM;AACvC,MAAI,OAAO,QAAQ,SAAS,gBAAgB;AAC1C,WAAO;AAAA,EACR;AACD,MAAI,iBAAiB,EAAE,MAAM,iBAAiB,IAAI,GAAG;AACnD,WAAO;AAAA,EACR;AACD,QAAM,oBAAoB,GAAG,QAAQ;AAAA,IACnC,CAAC,MAAM,UAAK;;AAAK,kBAAK,cAAc,KAAK,WAAW,cAAY,gBAAK,QAAQ,KAAK,MAAlB,mBAAqB,eAArB,mBAAiC;AAAA;AAAA,EACrG;AACE,MAAI,mBAAmB;AACrB,WAAO;AAAA,EACR;AACD,SAAO;AACT;ACrBA,MAAe,iBAAA;AAAA,EACb,eAAe,IAAI,MAAM,eAAe;;AACtC,UAAM,UAAU;AAChB,UAAM,aAAW,eAAA,EAAY,YAAZ,mBAAqB,uBAAsB;AAC5D,QAAI,WAAW,iBAAiB;AAChC,UAAM,yBAAyB,OAAO,GAAG,KAAK,gBAAgB,aAAa,GAAG,KAAK,YAAY,IAAI,IAAI,IAAI,GAAG,KAAK;AAC/G,QAAA,CAAC,YAAY,QAAQ,MAAM,2BAA2B,SAAS,eAAe,IAAI,IAAI,GAAG;AAC3F,iBAAW,EAAE,MAAM,GAAG,KAAK,EAAE;AAAA,IAC/B;AACI,QAAA,GAAG,SAAS,KAAK,MAAM;AACzB,UAAI,KAAK,QAAQ,CAAC,GAAG,MAAM;AACzB,eAAO,EAAE,MAAM,GAAG,KAAK,EAAE;AAAA,MAC3B;AACA,UAAI,GAAG,MAAM;AACJ,eAAA,EAAE,IAAI,GAAG,MAAM,KAAK,+BAA+B,GAAG,IAAI,GAAG;MACtE;AACO,aAAA;AAAA,IACT;AACA,UAAM,gBAAgB,CAAC,UAAU,CAAC,EAAE,MAAM,KAAK,kBAAkBC;AACjE,UAAM,aAAa,cAAc,IAAI,KAAK,cAAc,EAAE,IAAI,2BAA2B;AAClF,WAAA,IAAI,QAAQ,CAAC,YAAY;AACtB,cAAA,MAAM,SAAS,YAAY,YAAY;AAC7C,cAAM,IAAI,QAAQ,CAAC,aAAa,WAAW,UAAU,CAAC,CAAC;AACvD,YAAI,GAAG,MAAM;AACA,qBAAA,EAAE,IAAI,GAAG,MAAM,KAAK,+BAA+B,GAAG,IAAI,GAAG;QAC1E;AACA,gBAAQ,QAAQ;AAAA,MAAA,CACjB;AAAA,IAAA,CACF;AAAA,EACH;AACF;AACA,SAAS,+BAA+B,UAAU;AAC5C,MAAA;AACI,UAAA,OAAgB,SAAA,cAAc,QAAQ;AAC5C,QAAI,MAAM;AACR,aAAO,WAAW,iBAAiB,IAAI,EAAE,eAAe;AAAA,IAC1D;AAAA,EAAA,QACM;AAAA,EACR;AACO,SAAA;AACT;AC3CA,MAAM,sBAAsB;AAAA,EAC1B,UAAU;AAAA,EACV,oBAAoB;AACtB;AACA,MAAe,gBAAA;AAAA,EACf,GAAG;AAAA,EACH,GAAG;AACH;ACJE,MAAQ,aAAA,0CAAgB,OAAA,OAAA;;AAAA,MAAA,QAAA;AACtB,MAAA,GAAA,QAAA,SAAA,mBAAA,WAAA;AACF;AAAA,EACA;AAEqB,YAAA;AACrB,kBAAqB,CAAA,QAAA,SAAA,IAAAC,aAAA,MAAA,QAAA,QAAA,GAAA,KAAA,SAAA,EAAA,CAAA,CAAA,GAAA,SAAA,MAAA,QAAA,aAAA;AACnB,MAAA,WAAA,MAAA;AACF;AAAA,EACA;AACS;AACT,WAAA;AAAA,EACA;;ACZA,MAAA,0BAA4C,0CAAA,OAAA,OAAA;AAC1C;AACF;AAAA,EACA;;ACLK,MAAM,mBAAmB;AAAA,EAC9BC;AAAAA,EACA;AACF;AACO,MAAM,kBAAkB;AAAA,EAC7B,OAAO,MAAM,OAAO,2BAAmD;AAAA,EACvE,MAAM,MAAM,OAAO,0BAAkD;AAAA,EACrE,cAAc,MAAM,OAAO,+BAAuD;AACpF;ACwBgC,MACxB,SAAA,iCAAA;AAAA,EACN,MAAS;AAAA,EACT;EACM,MAAA,MAAA,SAA8B;;AAAA,QAAA,QAAA;AAClC,QAAI,kDAAsC,IAAA;AAC1B,QAAA,cAAA,YAAA,CAAA,WAAA,SAAA,GAAA,GAAA;AAChB,oBAAA;AAAA,IACA;AACA,UAAM,YAAS,mBAAuB,YAAvB,uCAAuB,gBAAY,oBAAA,UAAA;AAC9C,UAAA,WAAA,mBAAA,WAAA,uCAAA,aAAA;AACE,QAAA;AACN,UAAM,aAAsB,QAAA,WAAA;AAAA,UACvB,SAAAC,eAAA;AAAA,MACH,GAAgB;AAAA,MACd,gBAA6B,CAAA,IAAA,MAAA,kBAAA;AACX,YAAA,SAAA,gBAAA;AAChB,0BAAA;AACF;AAAA,QACA;AACS,YAAA,8BAAyB;AAC5B,iBAAA,QAAA,+BAAuC;AACnC,cAAA,uBAAe,SAAiB,SAAA;AAC9B,kBAAA,QAAA,OAAA,WAAA,MAAA;AACN;AACD,cAAA,SAAA,QAAA,oBAAA;AAAA,YAAA,CACH;AAAA,UACA;AACF,iBAAA,cAAA,eAAA,IAAA,gBAAA,iBAAA,aAAA;AAAA,QACF;AAAA,MACA;AAAA,MACA;AAAA,MACD;AAAA,IACD,CAAA;AAIA,YAAsB,OAAA,IAAA,MAAA;AACf,UAAA,gBAAW,WAAc,OAAA,aAAA,KAAA;AAC9B,WAAA,UAAsB,CAAA,KAAA,SAAA;AACvB,oBAAA,QAAA;AAAA,IACD,CAAA;AACE,WAAK,eAAoB,QAAA,OAAA,OAAA,kBAAA,iBAAA;AAAA,MAC1B,KAAA,MAAA,cAAA;AAAA,IACD,CAAA;AACA,UAAM,oBAAyB,OAAA,QAAA,UAAA,CAAA;AACtB,UAAA,mBAA4B,MAAA;AACrC,aAAA,QAAA,OAAA,aAAA;AAAA,IACA;AACO,YAAA,KAAA,eAAwB,gBAAA;AACzB,WAAA,UAAW,CAAC,IAAG,SAAA;;AACA,YAAAC,OAAA7B,MAAA,GAAA,QAAA,CAAA,MAAA,gBAAAA,IAAA,eAAA,gBAAA6B,IAAA,eAAA,MAAAC,MAAA,KAAA,QAAA,CAAA,MAAA,gBAAAA,IAAA,eAAA,mBAAA,UAAA;AACnB;MACD;AAAA,IACD,CAAA;AACW,UAAA,QAAA,CAAA;AACF,eAAA,OAAA,cAA2B;AAAA,aAC3B,eAAa,OAAS,KAAA;AAAA,QAC5B,KAAA,MAAA,OAAA,MAAA,GAAA;AAAA,MAAA,CACH;AAAA,IACQ;AACA,YAAA,SAAA,gBAAqC,KAAA;AAAA,0BAClC,QAAA,eAAA;AAAA,MACT,QAAQ,CAAA;AAAA,MACV,OAAA,CAAA;AAAA,IACA;AACI,aAAA;AACF,QAAA;AACQ,UAAA,MAAA;AACR;AAAA,QAAA,CAAA,QAAA,SAAA,IAAAJ,aAAA,MAAA,OAAA,KAAA,UAAA,CAAA,GAAA,MAAA,QAAA,UAAA;AAAA;AAAA;;eAEe,SAAA,IAAAA,aAAA,MAAA,OAAA,QAAA,CAAA,GAAA,MAAA,QAAA,UAAA;AAAA;AAAA,IACf,SAAA,QAAA;AACF,MAAA,CAAA,QAAA,SAAA,IAAAA,aAAA,MAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA,CAAA,GAAA,MAAA,QAAA,UAAA;AAAA,IAC0B;AACxB,SAAA,aAAS,eAAT,mBAAoB,eAAS;AAC/B,aAAA,EAAA,SAAA,EAAA,OAAA;IACM;AACC,UAAA,gBAAkB,QAAa,QAAA,MAAA;AAC9B,WAAA,kBAAiB,IAAoB,SAAA;;AACxC,YAAA,QAAgB,SAAO,oBAAA;AACtB,SAAA,OAAA;AACF,UAAA,QAAiB,eAAA,iBAAA,CAAA,WAAA,GAAA,KAAA,MAAA,GAAA;AACnB,WAAA,KAAA,SAAA;AAAA,MACA;AAC0B,cAAS,wBAA2B;AACtD,UAAA,GAAA1B,MAAA,QAAA,eAAA,gBAAAA,IAAA,gBAAwC;AACnC,cAAA,oBAAyB,oBAAA,IAAA,CAAA,GAAA,kBAAA,GAAA,QAAA,YAAA,MAAA,CAAA;AAC5B,mBAAA,aAAA,GAAA;AACN,gBAA0B,sBAAA,UAAA,KAAA;AACxB,cAAA,CAAA,qBAAA;AACF;AAAA,UACW;AACT,qBAAAG,UAAkBG,UAAS,mBAAA,GAAA;AAC7B,8BAAA,IAAAH,MAAA;AAAA,UACF;AAAA,QACA;;AAEE,6BAA8B,MAAA,QAAA,eAAA,MAAA,cAAA,GAAA,IAAA,CAAA;AACjB,cAAA,WAAA;AACL,uBAAA,OAAyB,WAAA,eAAM;AACjC,kBAAA,WAAA,cAAyB,GAAA,GAAA;AACpB,kCAAA,IAAA,GAAA;AAAA,cACL,OAAA;AACF,kCAAA,OAAA,GAAA;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACA;AACQ,mBAAAA,UAAA,mBAA8B;AACpC,gBAAiB,aAAA,OAAAA,WAAA,WAAA,QAAA,YAAA,MAAAA,MAAA,KAAA,QAAA0B,MAAA,gBAAA1B,YAAA,gBAAA0B,IAAA,sBAAA,KAAA,CAAA,MAAA,EAAA,WAAA,MAAA1B;AACf,cAAA,CAAA,YAAqB;AAIvB,kBAAA,IAAA,MAAA,8BAAAA,MAAA,IAAA;AAAA,UACM;AACN,gBAAkF,SAAA,MAAA,QAAA,eAAA,MAAA,WAAA,IAAA,IAAA,CAAA;AAC5E;AACI,gBAAA,WAAA,2BAA+B,OAAA;AAAA,oBACvB,SAAA,UAAA4B,cAAA;AAAA,gBACZ,YAAA;AAAA,gBACD,eAAA,mBAAA,UAAA;AAAA,cACD,CAAA;AACO,oBAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA;AACT,qBAAA;AAAA,YACF;AAAA,UACA;AACE,cAAA,WAAA,MAAA;AACF;AAAA,UACI;AACK,cAAA,UAAA,WAAA,OAAA;AACT,mBAAA;AAAA,UACF;AAAA,QACF;AAAA,MACD;AAAA,IACD,CAAA;AACE,WAAA,QAAe,YAAA;AACT,aAAA;AACP,YAAA,QAAA,SAAA,kBAAA;AAAA,IACD,CAAA;AACE,WAAA,UAAe,OAAA,IAAA,OAAA,YAAA;AACf,aAA+D,QAAA;AAIvD,UAAA,SAAA;AACR,cAAA,QAAA,SAAA,kBAAA;AAAA,MAC0B;AACxB,WAAA,mCAAA,UAAA,GAAA;AACF;AAAA,MACI;AACF,UAAA,GAAA,QAAc,WAAA,GAAA;AAA2C,cAC3C,QAAA,eAAA,MAAA,UAAAA,cAAA;AAAA,UACZ,YAAO;AAAA,UACP,OAAA;AAAA,UACA,eAAM,mBAAA,GAAA,QAAA;AAAA,UAAA;YAEN,MAAA,GAAA;AAAA,UACC;AAAA,QAC4B,CAAA,CAAA,CAAA;AAAA,MAC/B,gCAA6B,GAAA,aAAiB,YAAG;AACnD,cAAA,QAAA,eAAA,MAAA,WAAA,GAAA,YAAA,GAAA,CAAA;AAAA,MACD;AAAA,IACD,CAAQ;AACF,YAAA,MAAA,SAAA,eAAA,YAAA;AACI,UAAA;AACN,0BAAkB,QAAA,UAAA;AAChB,YAAA,UAAU,IAAA;AACZ,aAAA,OAAA;AAAA,QACA;AAAqB,cAChB,OAAA,QAAA;AAAA,UACH,GAAO;AAAA,UACR,OAAA;AAAA,QACD,CAAO;eACA,QAAQ,iBAAA,cAAA;AAAA,MACf,SAAc,QAAA;AAChB,cAAA,QAAA,eAAA,MAAA,UAAA,MAAA,CAAA;AAAA,MACD;AAAA,IACD,CAAA;AACF,WAAA,EAAA,SAAA,EAAA,OAAA;EACD;AACD,CAAe;ACjHC,SAAA,qBAAqB,MAAM,QAAQ;AACzB;AACtB,gCAAa,GAAA,WAAW,iBAAiB,IAAI,IAAI;AAAA,EACnD;AACF;ACtGA,MAAM,WAAW;AAAA,EACf,WAAW,CAAC,SAAS,YAAY,IAAI,KAAK,KAAK,OAAQ;AAAA,EACvD,iBAAiB,CAAC,SAAS,MAAM,IAAI,KAAK,UAAU,IAAI,KAAK,CAAC,KAAK,UAAU,OAAO,KAAK,UAAU,WAAW,OAAO,KAAK,UAAU,KAAK,KAAK,KAAK;AAAA,EACnJ,UAAU,CAAC,SAAS,MAAM,IAAI,KAAK,CAAC,KAAK,UAAU,OAAO,KAAK,UAAU,WAAW,OAAO,KAAK,UAAU,KAAK,KAAK,KAAK;AAAA,EACzH,YAAY,CAAC,SAAS,MAAM,IAAI,KAAK,UAAU,IAAI,KAAK,KAAK;AAAA,EAC7D,iBAAiB,CAAC,SAAS,WAAW,IAAI,KAAK,UAAU,IAAI,KAAK,MAAM,IAAI;AAAA,EAC5E,KAAK,CAAC,SAAS,MAAM,IAAI,KAAK,KAAK;AAAA,EACnC,UAAU,CAAC,SAAS,WAAW,IAAI,KAAK,MAAM,IAAI;AACpD;AAIA,MAAA,mCAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,QAAQ;AACN,eAAW,WAAW,UAAU;AAC9B,2BAAqB,SAAS,SAAS,OAAO,CAAC;AAAA,IAChD;AAAA,EACF;AACH,CAAC;;;ACtBD,MAAM,uBAAuB;AAAA,EAC3B,CAAC,QAAQ,QAAQ;AAAA,EACnB,CAAC,WAAW,WAAW;AAEvB;AAEA,MAAA,+BAAe,iCAAiB;AAAA,EAC9B,MAAM;AAAA,EACN,MAAO,SAAS;AACd,eAAW,CAAC,MAAM,SAAS,KAAK,sBAAsB;AACpD,cAAQ,OAAO,UAAU,MAAM,SAAS;AACxC,cAAQ,OAAO,UAAU,SAAS,MAAM,SAAS;AAAA,IAClD;AAAA,EACF;AACH,CAAC;ACbM,MAAM,mBAAmB,OAAO,IAAI,kBAAkB;AAC9C,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA;AAAA,EAEd,OAAO,CAAC,YAAY,eAAe,kBAAkB,aAAa;AAAA,EAClE,MAAM,GAAG,EAAE,OAAO,MAAK,GAAI;AACzB,UAAM,UAAU,IAAI,KAAK;AASzB,YAAQ,kBAAkB,IAAI;AAC9B,WAAO,CAAC,UAAU;;AAChB,UAAI,QAAQ,OAAO;AACjB,gBAAO,WAAM,YAAN;AAAA,MACR;AACD,YAAM,OAAO,MAAM,YAAY,MAAM;AACrC,UAAI,MAAM;AACR,eAAO,KAAI;AAAA,MACZ;AACD,YAAM,cAAc,MAAM,YAAY,MAAM,eAAe;AAC3D,YAAM,cAAc,MAAM,eAAe,MAAM,kBAAkB;AACjE,aAAO,mBAAmB,aAAa,OAAO,WAAW;AAAA,IAC/D;AAAA,EACG;AACH,CAAC;ACmlCD,MAAM,yBAAyB;AAAA,EAC7B,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AACP;ACrkCO,SAAS,qBAAqB,OAAO;AAC1C,SAAO,KAAK,sBAAsB,EAAE;AAAA,IAClC,CAAC,eAAe,MAAM,WAAW,UAAU;AAAA,EAC5C,KAAI;AACP;ACUO,SAAS,WAAW,OAAO;AAChC,SAAO,CAAC,MAAM,SAAS,KAAK,CAAC;AAC/B;AACO,SAAS,SAAS,OAAO;AAC9B,SAAO,SAAS,KAAK,KAAK,SAAS,SAAS,KAAK,KAAK,QAAQ,KAAK;AACrE;AAqBO,SAAS,QAAQ,OAAO;AAC7B,MAAI,QAAQ,KAAK,GAAG;AAClB,WAAO;AAAA,EACR;AACD,MAAI,SAAS,KAAK,GAAG;AACnB,WAAO,MAAM,MAAM,GAAG,EAAE,OAAO,CAAC,SAAS,IAAI;AAAA,EAC9C;AACD,MAAI,SAAS,UAAU,SAAS,OAAO;AACrC,WAAO;EACR;AACD,SAAO,CAAC,KAAK;AACf;AAsBO,SAAS,QAAQ,KAAK,KAAK;AAChC,MAAI,WAAW,GAAG,GAAG;AACnB,WAAO,GAAG,GAAG,IAAI,GAAG;AAAA,EACrB;AACD,MAAI,qBAAqB,GAAG,GAAG;AAC7B,WAAO,GAAG,GAAG,IAAI,GAAG;AAAA,EACrB;AACD,MAAI,OAAO,QAAQ;AACjB,WAAO,GAAG,GAAG,IAAI,GAAG;AAAA,EACrB;AACD,SAAO,GAAG,GAAG,GAAG,GAAG;AACrB;ACzIO,SAAS,aAAa,SAAS;AACpC,MAAI,WAAW,QAAQ,YAAY;AACjC,eAAW,QAAQ,QAAQ,YAAY;AACrC,cAAQ,KAAK,MAAI;AAAA,QACf,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,QAAQ,KAAK,KAAK;AAAA,UAC9B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,QAAQ,KAAK,KAAK;AAAA,UAC9B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,cAAc,KAAK,KAAK;AAAA,UACpC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,eAAe,KAAK,KAAK;AAAA,UACrC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,iBAAiB,KAAK,KAAK;AAAA,UACvC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,IAAI,SAAS,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE,OAAO;AAAA,UAC9F;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,QAAQ,CAAC,EAAE;AAAA,UAC3D;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,OAAO,SAAS,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,EAAE,OAAO;AAAA,UACjG;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,QAAQ,KAAK,KAAK;AAAA,UAC9B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,QAAQ,CAAC,EAAE;AAAA,UAC3D;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,SAAS,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,EAAE;AAAA,UACjE;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,YAAY,KAAK,KAAK;AAAA,UAClC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,mBAAmB,SAAS,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,EAAE;AAAA,UAC3E;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,mBAAmB,KAAK,KAAK;AAAA,UACzC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,UAAU,CAAC,EAAE;AAAA,UAC7D;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,cAAc,CAAC,EAAE;AAAA,UACjE;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAAA,UACxD;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,MAAM,KAAK,KAAK;AAAA,UAC5B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,MAAM,KAAK,KAAK;AAAA,UAC5B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,OAAO,KAAK,KAAK;AAAA,UAC7B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,MAAM,KAAK,KAAK;AAAA,UAC5B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,mBAAmB,KAAK,KAAK;AAAA,UACzC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,QAAQ,KAAK,KAAK;AAAA,UAC9B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,WAAW,KAAK,KAAK;AAAA,UACjC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,IAAI,KAAK,KAAK;AAAA,UAC1B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,QAAQ,KAAK,KAAK;AAAA,UAC9B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,QAAQ,GAAG,GAAG,CAAC;AAAA,UAC/D;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,QAAQ,GAAG,GAAG,CAAC;AAAA,UAC/D;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,OAAO,CAAC,EAAE;AAAA,UAC1D;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,kBAAkB,SAAS,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,EAAE;AAAA,UAC1E;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,eAAe,KAAK,KAAK;AAAA,UACrC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,MAAM,KAAK,KAAK;AAAA,UAC5B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,MAAM,KAAK,KAAK;AAAA,UAC5B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,cAAc,KAAK,KAAK;AAAA,UACpC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,KAAK,KAAK,KAAK;AAAA,UAC3B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,KAAK,KAAK,KAAK;AAAA,UAC3B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,KAAK,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;AAAA,UACxD;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,WAAW,KAAK,KAAK;AAAA,UACjC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,cAAc,SAAS,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,EAAE;AAAA,UACtE;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,eAAe,KAAK,KAAK;AAAA,UACrC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,SAAS,KAAK,KAAK,GAAG,CAAC,MAAM,OAAO,CAAC,EAAE;AAAA,UACpE;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,YAAY,KAAK,KAAK;AAAA,UAClC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,OAAO,KAAK,KAAK;AAAA,UAC7B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,KAAK,KAAK;AAAA,UAC/B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,OAAO,KAAK,KAAK;AAAA,UAC7B;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,UAAU,KAAK,KAAK;AAAA,UAChC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,aAAa,KAAK,KAAK;AAAA,UACnC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,SAAS,SAAS,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,EAAE;AAAA,UACjE;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,UAAU,KAAK,KAAK;AAAA,UAChC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,UAAU,KAAK,KAAK;AAAA,UAChC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,UAAU,SAAS,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,KAAK,EAAE;AAAA,UAClE;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,WAAW,KAAK,KAAK;AAAA,UACjC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,gBAAgB,KAAK,KAAK;AAAA,UACtC;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB;AAAA,UACZ;AACU,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,SAAS,KAAK,KAAK,GAAG,CAAC,MAAM,0BAA0B,CAAC,EAAE;AAAA,UACvF;AACU;AAAA,QACF,KAAK;AACH,kBAAQ,UAAU;AAAA,YAChB,GAAG,cAAc,SAAS,KAAK,KAAK,GAAG,CAAC,MAAM,eAAe,CAAC,EAAE;AAAA,UAC5E;AAAA,MACO;AAAA,IACF;AAAA,EACF;AACH;AACA,SAAS,cAAc,OAAO,MAAM;AAClC,QAAM,aAAa,CAAA;AACnB,QAAM,SAAS,QAAQ,KAAK;AAC5B,SAAO,QAAQ,CAAC,MAAM;AACpB,eAAW,KAAK,KAAK,CAAC,CAAC;AAAA,EAC3B,CAAG;AACD,SAAO;AACT;ACvYA,MAAA,uBAAe,iCAAiB,CAAC,YAAY;AAC3C,UAAQ,OAAO;AAAA,IACb;AAAA,IACA;AAAA,MACE,QAAQ,IAAI;AACV,qBAAa,EAAE;AAAA,MAChB;AAAA,IACF;AAAA,EACL;AACA,CAAC;ACTD,MAAA,2CAAe,iCAAiB,CAAC,YAAY;AAC3C,UAAQ,KAAK,gBAAgB,CAAC,QAAQ;;AACpC,SAAI,SAAI,eAAJ,mBAAgB,WAAW;AAC7B,UAAI,WAAW,YAAY,gBAAgB,IAAI,WAAW,SAAS;AAAA,IACpE;AAAA,EACL,CAAG;AACH,CAAC;AAED,SAAS,gBAAiB,WAAW;AACnC,QAAM,OAAO,OAAO,QAAQ,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK,MAAM;AACnE,QAAI,IAAI,WAAW,uBAAuB,KAAK,CAAA,EAAG,SAAS,GAAG,GAAG;AAC/D,aAAO,GAAG,GAAG,YAAY,IAAI,MAAM,CAAC,CAAC,KAAK,KAAK;AAAA,IAChD;AACD,WAAO;AAAA,EACX,GAAK,UAAU,QAAQ,EAAE;AACvB,SAAO,EAAE,GAAG,WAAW,KAAM;AAC/B;ACRA,MAAM,mBAAmB,OAAO,eAAe;ACDhC,IAAI,CAAC;AAEpB,MAAM,uBAAuB,OAAO,oBAAoB;ACRxD,MAAe,2CAAA,iCAAiB,aAAW;AACzC,UAAQ,OACL,QAAQ,kBAAkB,EAAC,UAAS,MAAK,WAAU,EAAC,CAAC,EACrD,QAAQ,sBAAsB,EAAC,WAAU,EAAC,CAAC;AAChD,CAAC;ACND,MAAA,2BAAe,iCAAiB,CAAC,YAAY;AACzC,UAAQ,OAAO,UAAU,aAAa,gBAAgB;AAC1D,CAAC;ACeD,MAAe,iBAAA,iCAAiB,MAAM;AAAC,CAAC;ACHxC,MAAA,oBAAe,iCAAiB,CAAC,YAAY;AACzC,QAAM,QAAQ;AA8DN,UAAA,QAAQ,SAAS,KAAK;AAClC,CAAC;AC/ED;AAAA;AAAA;AAAA;AAAA;AAQA,SAAS,WAAW,IAAI;AACpB,SAAO,OAAO,OAAO;AACzB;AACA,SAASC,oBAAkB,OAAO;AACvB,SAAA,UAAU,QAAQ,UAAU;AACvC;AACA,MAAM,WAAW,CAAC,QAAQ,QAAQ,QAAQ,CAAC,CAAC,OAAO,OAAO,QAAQ,YAAY,CAAC,MAAM,QAAQ,GAAG;AAChG,SAAS,QAAQ,OAAO;AACb,SAAA,OAAO,KAAK,KAAK;AAC5B;AACA,SAAS,SAAS,OAAO;AACf,QAAA,IAAI,WAAW,KAAK;AACnB,SAAA,MAAM,CAAC,IAAI,QAAQ;AAC9B;AACA,SAAS,aAAa,OAAO;AAClB,SAAA,OAAO,UAAU,YAAY,UAAU;AAClD;AACA,SAAS,OAAO,OAAO;AACnB,MAAI,SAAS,MAAM;AACR,WAAA,UAAU,SAAY,uBAAuB;AAAA,EACxD;AACA,SAAO,OAAO,UAAU,SAAS,KAAK,KAAK;AAC/C;AAEA,SAAS,cAAc,OAAO;AAC1B,MAAI,CAAC,aAAa,KAAK,KAAK,OAAO,KAAK,MAAM,mBAAmB;AACtD,WAAA;AAAA,EACX;AACA,MAAI,OAAO,eAAe,KAAK,MAAM,MAAM;AAChC,WAAA;AAAA,EACX;AACA,MAAI,QAAQ;AACZ,SAAO,OAAO,eAAe,KAAK,MAAM,MAAM;AAClC,YAAA,OAAO,eAAe,KAAK;AAAA,EACvC;AACO,SAAA,OAAO,eAAe,KAAK,MAAM;AAC5C;AACA,SAAS,MAAM,QAAQ,QAAQ;AAC3B,SAAO,KAAK,MAAM,EAAE,QAAQ,CAAO,QAAA;AAC3B,QAAA,cAAc,OAAO,GAAG,CAAC,KAAK,cAAc,OAAO,GAAG,CAAC,GAAG;AACtD,UAAA,CAAC,OAAO,GAAG,GAAG;AACP,eAAA,GAAG,IAAI;MAClB;AACA,YAAM,OAAO,GAAG,GAAG,OAAO,GAAG,CAAC;AAC9B;AAAA,IACJ;AACO,WAAA,GAAG,IAAI,OAAO,GAAG;AAAA,EAAA,CAC3B;AACM,SAAA;AACX;AAIA,SAAS,kBAAkB,MAAM;AACvB,QAAA,UAAU,KAAK,MAAM,GAAG;AAC1B,MAAA,CAAC,QAAQ,QAAQ;AACV,WAAA;AAAA,EACX;AACA,MAAI,WAAW,OAAO,QAAQ,CAAC,CAAC;AAChC,WAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,QAAI,QAAQ,QAAQ,CAAC,CAAC,GAAG;AACT,kBAAA,IAAI,QAAQ,CAAC,CAAC;AAC1B;AAAA,IACJ;AACY,gBAAA,IAAI,QAAQ,CAAC,CAAC;AAAA,EAC9B;AACO,SAAA;AACX;AAEA,MAAM,QAAQ,CAAA;AAId,SAAS,WAAW,IAAI,WAAW;AAE/B,cAAY,IAAI,SAAS;AACzB,QAAM,EAAE,IAAI;AAChB;AAIA,SAAS,YAAY,IAAI;AACrB,SAAO,MAAM,EAAE;AACnB;AAIA,SAAS,YAAY,IAAI,WAAW;AAC5B,MAAA,WAAW,SAAS,GAAG;AACvB;AAAA,EACJ;AACA,QAAM,IAAI,MAAM,mCAAmC,EAAE,uBAAuB;AAChF;AAEA,SAAS,IAAI,KAAK,KAAK,KAAK;AACvB,MAAA,OAAO,IAAI,UAAU;AAAc,QAAA,QAAQ,MAAM,IAAI,KAAK;AAC9D,MAAI,CAAC,IAAI,cAAc,IAAI,OAAO,IAAI,OAAO,CAAC,IAAI,gBAAgB,CAAC,IAAI,YAAY,QAAQ,aAAa;AAChG,WAAA,eAAe,KAAK,KAAK,GAAG;AAAA,EACpC;AAAW,QAAA,GAAG,IAAI,IAAI;AACvB;AAEA,SAAS,MAAM,GAAG;AACjB,MAAI,OAAO,MAAM;AAAiB,WAAA;AAE9B,MAAA,IAAE,GAAG,GAAG,MAAM,KAAK,MAAI,OAAO,UAAU,SAAS,KAAK,CAAC;AAE3D,MAAI,QAAQ,mBAAmB;AAC9B,UAAM,OAAO,OAAO,EAAE,aAAa,IAAI;AAAA,EAAA,WAC7B,QAAQ,kBAAkB;AAC9B,UAAA,MAAM,EAAE,MAAM;AAAA,EAAA,WACV,QAAQ,gBAAgB;AAClC,UAAU,oBAAA;AACR,MAAA,QAAQ,SAAU,KAAK;AACpB,UAAA,IAAI,MAAM,GAAG,CAAC;AAAA,IAAA,CAClB;AAAA,EAAA,WACS,QAAQ,gBAAgB;AAClC,UAAU,oBAAA;AACR,MAAA,QAAQ,SAAU,KAAK,KAAK;AAC7B,UAAI,IAAI,MAAM,GAAG,GAAG,MAAM,GAAG,CAAC;AAAA,IAAA,CAC9B;AAAA,EAAA,WACS,QAAQ,iBAAiB;AAC7B,UAAA,oBAAI,KAAK,CAAC,CAAC;AAAA,EAAA,WACP,QAAQ,mBAAmB;AACrC,UAAM,IAAI,OAAO,EAAE,QAAQ,EAAE,KAAK;AAAA,EAAA,WACxB,QAAQ,qBAAqB;AACvC,UAAM,IAAI,EAAE,YAAa,MAAM,EAAE,MAAM,CAAE;AAAA,EAAA,WAC/B,QAAQ,wBAAwB;AACpC,UAAA,EAAE,MAAM,CAAC;AAAA,EACL,WAAA,IAAI,MAAM,EAAE,MAAM,UAAU;AAGhC,UAAA,IAAI,EAAE,YAAY,CAAC;AAAA,EAC1B;AAEA,MAAI,KAAK;AACH,SAAA,OAAK,OAAO,sBAAsB,CAAC,GAAG,IAAI,KAAK,QAAQ,KAAK;AAC5D,UAAA,KAAK,KAAK,CAAC,GAAG,OAAO,yBAAyB,GAAG,KAAK,CAAC,CAAC,CAAC;AAAA,IAC9D;AAEK,SAAA,IAAE,GAAG,OAAK,OAAO,oBAAoB,CAAC,GAAG,IAAI,KAAK,QAAQ,KAAK;AACnE,UAAI,OAAO,eAAe,KAAK,KAAK,IAAE,KAAK,CAAC,CAAC,KAAK,IAAI,CAAC,MAAM,EAAE,CAAC;AAAG;AACnE,UAAI,KAAK,GAAG,OAAO,yBAAyB,GAAG,CAAC,CAAC;AAAA,IAClD;AAAA,EACD;AAEA,SAAO,OAAO;AACf;AAEA,MAAM,iBAAiB,OAAO,mBAAmB;AACjD,MAAM,kBAAkB,OAAO,6BAA6B;AAC5D,MAAM,YAAY,OAAO,qBAAqB;AAG9C,SAAS,UAAU,OAAO;AACtB,SAAO,WAAW,KAAK,KAAK,CAAC,CAAC,MAAM;AACxC;AACA,SAAS,cAAc,OAAO;AACnB,SAAA,CAAC,CAAC,SAAS,WAAW,MAAM,KAAK,KAAK,MAAM,WAAW;AAClE;AACA,SAAS,eAAe,OAAO;AAC3B,SAAO,CAAC,CAAC,SAAS,WAAW,MAAM,QAAQ;AAC/C;AACA,SAAS,eAAe,MAAM;AACnB,SAAA,SAAS,cAAc,SAAS;AAC3C;AACA,SAAS,iBAAiB,OAAO;AAC7B,SAAO,SAAS,KAAK,KAAK,MAAM,QAAQ,KAAK;AACjD;AAIA,SAAS,iBAAiB,OAAO;AACzB,MAAA,MAAM,QAAQ,KAAK,GAAG;AACtB,WAAO,MAAM,WAAW;AAAA,EAC5B;AACA,SAAO,SAAS,KAAK,KAAK,OAAO,KAAK,KAAK,EAAE,WAAW;AAC5D;AAIA,SAAS,gBAAgB,MAAM;AACpB,SAAA,YAAY,KAAK,IAAI;AAChC;AAIA,SAAS,oBAAoB,IAAI;AACtB,SAAA,eAAe,EAAE,KAAK,GAAG;AACpC;AAIA,SAAS,eAAe,IAAI;AACxB,SAAO,GAAG,YAAY;AAC1B;AAIA,SAAS,wBAAwB,KAAK,OAAO;AAEzC,QAAM,wBAAwB,CAAC,CAAC,OAAO,MAAM,QAAW,CAAC,EAAE,SAAS,MAAM,QAAQ,KAAK,CAAC,OAAO,MAAM,MAAM,QAAQ;AAC5G,SAAA,QAAQ,YAAY,cAAc,SAAS;AACtD;AAQA,SAAS,uBAAuB,KAAK,OAAO;AACjC,SAAA,CAAC,wBAAwB,KAAK,KAAK,KAAK,MAAM,SAAS,UAAU,CAAC,eAAe,MAAM,IAAI;AACtG;AACA,SAAS,kBAAkB,KAAK;AAC5B,SAAO,QAAQ,GAAG,KAAK,IAAI,UAAU,YAAY,IAAI;AACzD;AACA,SAAS,QAAQ,KAAK;AAClB,MAAI,CAAC,KAAK;AACC,WAAA;AAAA,EACX;AACA,MAAI,OAAO,UAAU,eAAe,WAAW,KAAK,KAAK,eAAe,OAAO;AACpE,WAAA;AAAA,EACX;AAGI,MAAA,OAAO,IAAI,YAAY;AAChB,WAAA;AAAA,EACX;AACO,SAAA;AACX;AACA,SAAS,cAAc,KAAK,MAAM;AAC9B,SAAO,QAAQ,OAAO,IAAI,IAAI,MAAM;AACxC;AAMA,SAAS,QAAQ,GAAG,GAAG;AACnB,MAAI,MAAM;AACC,WAAA;AACX,MAAI,KAAK,KAAK,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;AACtD,QAAA,EAAE,gBAAgB,EAAE;AACb,aAAA;AAEX,QAAI,QAAQ,GAAGC;AACX,QAAA,MAAM,QAAQ,CAAC,GAAG;AAClB,eAAS,EAAE;AAEX,UAAI,UAAU,EAAE;AACL,eAAA;AACN,WAAA,IAAI,QAAQ,QAAQ;AACrB,YAAI,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC;AACZ,iBAAA;AACR,aAAA;AAAA,IACX;AACI,QAAA,aAAa,OAAO,aAAa,KAAK;AAClC,UAAA,EAAE,SAAS,EAAE;AACN,eAAA;AACN,WAAA,KAAK,EAAE,QAAQ;AAChB,YAAI,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;AACJ,iBAAA;AACV,WAAA,KAAK,EAAE,QAAQ;AACZ,YAAA,CAAC,QAAQ,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACnB,iBAAA;AACR,aAAA;AAAA,IACX;AAGA,QAAI,OAAQ,KAAK,OAAQ,GAAG;AACpB,UAAA,EAAE,SAAS,EAAE;AACN,eAAA;AACP,UAAA,EAAE,SAAS,EAAE;AACN,eAAA;AACP,UAAA,EAAE,iBAAiB,EAAE;AACd,eAAA;AACP,UAAA,EAAE,SAAS,EAAE;AACN,eAAA;AACJ,aAAA;AAAA,IACX;AACI,QAAA,aAAa,OAAO,aAAa,KAAK;AAClC,UAAA,EAAE,SAAS,EAAE;AACN,eAAA;AACN,WAAA,KAAK,EAAE,QAAQ;AAChB,YAAI,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;AACJ,iBAAA;AACR,aAAA;AAAA,IACX;AACA,QAAI,YAAY,OAAO,CAAC,KAAK,YAAY,OAAO,CAAC,GAAG;AAChD,eAAS,EAAE;AAEX,UAAI,UAAU,EAAE;AACL,eAAA;AACN,WAAA,IAAI,QAAQ,QAAQ;AACrB,YAAI,EAAE,CAAC,MAAM,EAAE,CAAC;AACL,iBAAA;AACR,aAAA;AAAA,IACX;AACA,QAAI,EAAE,gBAAgB;AAClB,aAAO,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE;AAC9C,QAAA,EAAE,YAAY,OAAO,UAAU;AAC/B,aAAO,EAAE,QAAA,MAAc,EAAE,QAAQ;AACjC,QAAA,EAAE,aAAa,OAAO,UAAU;AAChC,aAAO,EAAE,SAAA,MAAe,EAAE,SAAS;AAChC,IAAAA,QAAA,OAAO,KAAK,CAAC;AACpB,aAASA,MAAK;AACT,SAAA,IAAI,QAAQ,QAAQ,KAAI;AAErB,UAAA,MAAMA,MAAK,CAAC;AAChB,UAAI,CAAC,QAAQ,EAAE,GAAG,GAAG,EAAE,GAAG,CAAC;AAChB,eAAA;AAAA,IACf;AACO,WAAA;AAAA,EACX;AAGO,SAAA,MAAM,KAAK,MAAM;AAC5B;AACA,SAAS,OAAO,GAAG;AACA;AACJ,WAAA;AAAA,EACX;AAEJ;AAEA,SAAS,qBAAqB,MAAM;AAC5B,MAAA,gBAAgB,IAAI,GAAG;AAChB,WAAA,KAAK,QAAQ,WAAW,EAAE;AAAA,EACrC;AACO,SAAA;AACX;AACA,SAAS,YAAY,QAAQ,MAAM,UAAU;AACzC,MAAI,CAAC,QAAQ;AACF,WAAA;AAAA,EACX;AACI,MAAA,gBAAgB,IAAI,GAAG;AAChB,WAAA,OAAO,qBAAqB,IAAI,CAAC;AAAA,EAC5C;AACA,QAAM,iBAAiB,QAAQ,IAC1B,MAAM,cAAc,EACpB,OAAO,OAAO,EACd,OAAO,CAAC,KAAK,YAAY;AAC1B,QAAI,iBAAiB,GAAG,KAAK,WAAW,KAAK;AACzC,aAAO,IAAI,OAAO;AAAA,IACtB;AACO,WAAA;AAAA,KACR,MAAM;AACF,SAAA;AACX;AAIA,SAAS,UAAU,QAAQ,MAAM,OAAO;AAChC,MAAA,gBAAgB,IAAI,GAAG;AAChB,WAAA,qBAAqB,IAAI,CAAC,IAAI;AACrC;AAAA,EACJ;AACA,QAAMA,QAAO,KAAK,MAAM,cAAc,EAAE,OAAO,OAAO;AACtD,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAIA,MAAK,QAAQ,KAAK;AAE9B,QAAA,MAAMA,MAAK,SAAS,GAAG;AACnB,UAAAA,MAAK,CAAC,CAAC,IAAI;AACf;AAAA,IACJ;AAEI,QAAA,EAAEA,MAAK,CAAC,KAAK,QAAQD,oBAAkB,IAAIC,MAAK,CAAC,CAAC,CAAC,GAAG;AAEtD,UAAIA,MAAK,CAAC,CAAC,IAAI,QAAQA,MAAK,IAAI,CAAC,CAAC,IAAI,CAAA,IAAK,CAAA;AAAA,IAC/C;AACM,UAAA,IAAIA,MAAK,CAAC,CAAC;AAAA,EACrB;AACJ;AACA,SAAS,MAAM,QAAQ,KAAK;AACxB,MAAI,MAAM,QAAQ,MAAM,KAAK,QAAQ,GAAG,GAAG;AACvC,WAAO,OAAO,OAAO,GAAG,GAAG,CAAC;AAC5B;AAAA,EACJ;AACI,MAAA,SAAS,MAAM,GAAG;AAClB,WAAO,OAAO,GAAG;AAAA,EACrB;AACJ;AAIA,SAAS,UAAU,QAAQ,MAAM;AACzB,MAAA,gBAAgB,IAAI,GAAG;AAChB,WAAA,OAAO,qBAAqB,IAAI,CAAC;AACxC;AAAA,EACJ;AACA,QAAMA,QAAO,KAAK,MAAM,cAAc,EAAE,OAAO,OAAO;AACtD,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAIA,MAAK,QAAQ,KAAK;AAE9B,QAAA,MAAMA,MAAK,SAAS,GAAG;AACjB,YAAA,KAAKA,MAAK,CAAC,CAAC;AAClB;AAAA,IACJ;AAEI,QAAA,EAAEA,MAAK,CAAC,KAAK,QAAQD,oBAAkB,IAAIC,MAAK,CAAC,CAAC,CAAC,GAAG;AACtD;AAAA,IACJ;AACM,UAAA,IAAIA,MAAK,CAAC,CAAC;AAAA,EACrB;AACA,QAAM,aAAaA,MAAK,IAAI,CAAC,GAAG,QAAQ;AAC7B,WAAA,YAAY,QAAQA,MAAK,MAAM,GAAG,GAAG,EAAE,KAAK,GAAG,CAAC;AAAA,EAAA,CAC1D;AACD,WAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AAC7C,QAAI,CAAC,iBAAiB,WAAW,CAAC,CAAC,GAAG;AAClC;AAAA,IACJ;AACA,QAAI,MAAM,GAAG;AACH,YAAA,QAAQA,MAAK,CAAC,CAAC;AACrB;AAAA,IACJ;AACA,UAAM,WAAW,IAAI,CAAC,GAAGA,MAAK,IAAI,CAAC,CAAC;AAAA,EACxC;AACJ;AAIA,SAAS,OAAO,QAAQ;AACb,SAAA,OAAO,KAAK,MAAM;AAC7B;AAGA,SAAS,eAAe,QAAQ,MAAM,QAAW;AAC7C,QAAM,KAAK;AACH,UAAA,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,SAAS,MAAM,MAAM,OAAO,QAAQ,GAAG;AAC9F;AAIA,SAAS,yBAAyB,cAAc,cAAc,gBAAgB;AACtE,MAAA,MAAM,QAAQ,YAAY,GAAG;AACvB,UAAA,SAAS,CAAC,GAAG,YAAY;AAE/B,UAAM,MAAM,OAAO,UAAU,OAAK,QAAQ,GAAG,YAAY,CAAC;AACnD,WAAA,IAAI,OAAO,OAAO,KAAK,CAAC,IAAI,OAAO,KAAK,YAAY;AACpD,WAAA;AAAA,EACX;AACA,SAAO,QAAQ,cAAc,YAAY,IAAI,iBAAiB;AAClE;AAKA,SAAS,SAAS,MAAM,OAAO;AACvB,MAAA;AACA,MAAA;AACJ,SAAO,YAAa,MAAM;AAEtB,UAAM,UAAU;AAChB,QAAI,CAAC,YAAY;AACA,mBAAA;AACF,iBAAA,MAAO,aAAa,OAAQ,KAAK;AAC/B,mBAAA,KAAK,MAAM,SAAS,IAAI;AAAA,IACzC;AACO,WAAA;AAAA,EAAA;AAEf;AACA,SAAS,cAAc,OAAO,KAAK,GAAG;AAClC,MAAI,QAAQ;AACZ,MAAI,WAAW,CAAA;AACf,SAAO,YAAa,MAAM;AAEtB,QAAI,OAAO;AACP,mBAAa,KAAK;AAAA,IACtB;AAEA,YAAQ,WAAW,MAAM;AAGf,YAAA,SAAS,MAAM,GAAG,IAAI;AAC5B,eAAS,QAAQ,CAAA,MAAK,EAAE,MAAM,CAAC;AAC/B,iBAAW,CAAA;AAAA,OACZ,EAAE;AACL,WAAO,IAAI,QAAQ,CAAA,YAAW,SAAS,KAAK,OAAO,CAAC;AAAA,EAAA;AAE5D;AACA,SAAS,oBAAoB,OAAO,WAAW;AACvC,MAAA,CAAC,SAAS,SAAS,GAAG;AACf,WAAA;AAAA,EACX;AACA,MAAI,UAAU,QAAQ;AAClB,WAAO,SAAS,KAAK;AAAA,EACzB;AACO,SAAA;AACX;AACA,SAAS,WAAW,IAAI,QAAQ;AACxB,MAAA;AACG,SAAA,eAAe,aAAa,MAAM;AAC/B,UAAA,UAAU,GAAG,GAAG,IAAI;AACd,gBAAA;AACZ,UAAM,SAAS,MAAM;AACrB,QAAI,YAAY,WAAW;AAChB,aAAA;AAAA,IACX;AACY,gBAAA;AACL,WAAA,OAAO,QAAQ,IAAI;AAAA,EAAA;AAElC;AAqBA,SAAS,mBAAmB,SAAS;AAC1B,SAAA,MAAM,QAAQ,OAAO,IAAI,UAAU,UAAU,CAAC,OAAO,IAAI;AACpE;AAYA,SAAS,KAAK,KAAKA,OAAM;AACrB,QAAM,SAAS,CAAA;AACf,aAAW,OAAO,KAAK;AACnB,QAAI,CAACA,MAAK,SAAS,GAAG,GAAG;AACd,aAAA,GAAG,IAAI,IAAI,GAAG;AAAA,IACzB;AAAA,EACJ;AACO,SAAA;AACX;AACA,SAAS,iBAAiB,OAAO;AAC7B,MAAI,WAAW;AACf,MAAI,WAAW,CAAA;AACf,SAAO,YAAa,MAAM;AAEhB,UAAA,WAAW,SAAS,MAAM;AAC5B,UAAI,aAAa,UAAU;AACvB;AAAA,MACJ;AAGM,YAAA,SAAS,MAAM,GAAG,IAAI;AAC5B,eAAS,QAAQ,CAAA,MAAK,EAAE,MAAM,CAAC;AAC/B,iBAAW,CAAA;AACA,iBAAA;AAAA,IAAA,CACd;AACU,eAAA;AACX,WAAO,IAAI,QAAQ,CAAA,YAAW,SAAS,KAAK,OAAO,CAAC;AAAA,EAAA;AAE5D;AAEA,SAAS,kBAAkB,KAAK,SAAS,WAAW;AAC5C,MAAA,CAAC,QAAQ,MAAM,SAAS;AACxB,WAAO,QAAQ,MAAM;AAAA,EACzB;AACA,MAAI,OAAO,QAAQ,YAAY,CAAC,KAAK;AACjC,WAAO,QAAQ,MAAM,QAAQ,UAAW,CAAA;AAAA,EAC5C;AACO,SAAA;AAAA,IACH,SAAS,MAAM;AAAE,UAAI,IAAI;AAAI,cAAQ,MAAM,KAAK,QAAQ,OAAO,aAAa,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,IAAI,WAAW;AAAA,IAAG;AAAA,EAAA;AAE/I;AAKA,SAAS,cAAc,IAAI;AACnB,MAAA,gBAAgB,EAAE,GAAG;AACrB,WAAO,GAAG;AAAA,EACd;AACO,SAAA;AACX;AAKA,SAAS,gBAAgB,IAAI;AACzB,SAAO,YAAY;AACvB;AAEA,SAAS,gBAAgB,IAAI;AACrB,MAAA,GAAG,SAAS,UAAU;AACtB,WAAO,OAAO,MAAM,GAAG,aAAa,IAAI,GAAG,QAAQ,GAAG;AAAA,EAC1D;AACI,MAAA,GAAG,SAAS,SAAS;AACrB,WAAO,OAAO,MAAM,GAAG,aAAa,IAAI,GAAG,QAAQ,GAAG;AAAA,EAC1D;AACA,SAAO,GAAG;AACd;AACA,SAAS,oBAAoB,OAAO;AAC5B,MAAA,CAAC,QAAQ,KAAK,GAAG;AACV,WAAA;AAAA,EACX;AACA,QAAM,QAAQ,MAAM;AAGpB,MAAI,eAAe,MAAM,IAAI,KAAK,gBAAgB,KAAK,GAAG;AACtD,WAAO,cAAc,KAAK;AAAA,EAC9B;AACA,MAAI,MAAM,SAAS,UAAU,MAAM,OAAO;AACtC,UAAM,QAAQ,MAAM,KAAK,MAAM,KAAK;AACpC,WAAO,MAAM,WAAW,QAAQ,MAAM,CAAC;AAAA,EAC3C;AACI,MAAA,oBAAoB,KAAK,GAAG;AAC5B,WAAO,MAAM,KAAK,MAAM,OAAO,EAC1B,OAAO,CAAA,QAAO,IAAI,YAAY,CAAC,IAAI,QAAQ,EAC3C,IAAI,aAAa;AAAA,EAC1B;AAGI,MAAA,eAAe,KAAK,GAAG;AACjB,UAAA,iBAAiB,MAAM,KAAK,MAAM,OAAO,EAAE,KAAK,CAAO,QAAA,IAAI,QAAQ;AACzE,WAAO,iBAAiB,cAAc,cAAc,IAAI,MAAM;AAAA,EAClE;AACA,SAAO,gBAAgB,KAAK;AAChC;AAKA,SAAS,eAAe,OAAO;AAC3B,QAAM,MAAM,CAAA;AACL,SAAA,eAAe,KAAK,mBAAmB;AAAA,IAC1C,OAAO;AAAA,IACP,UAAU;AAAA,IACV,YAAY;AAAA,IACZ,cAAc;AAAA,EAAA,CACjB;AACD,MAAI,CAAC,OAAO;AACD,WAAA;AAAA,EACX;AAEA,MAAI,SAAS,KAAK,KAAK,MAAM,iBAAiB;AACnC,WAAA;AAAA,EACX;AACI,MAAA,SAAS,KAAK,GAAG;AACjB,WAAO,OAAO,KAAK,KAAK,EAAE,OAAO,CAAC,MAAM,SAAS;AAC7C,YAAM,SAAS,gBAAgB,MAAM,IAAI,CAAC;AACtC,UAAA,MAAM,IAAI,MAAM,OAAO;AAClB,aAAA,IAAI,IAAI,YAAY,MAAM;AAAA,MACnC;AACO,aAAA;AAAA,OACR,GAAG;AAAA,EACV;AAEI,MAAA,OAAO,UAAU,UAAU;AACpB,WAAA;AAAA,EACX;AACA,SAAO,MAAM,MAAM,GAAG,EAAE,OAAO,CAAC,MAAM,SAAS;AACrC,UAAA,aAAa,UAAU,IAAI;AAC7B,QAAA,CAAC,WAAW,MAAM;AACX,aAAA;AAAA,IACX;AACA,SAAK,WAAW,IAAI,IAAI,YAAY,WAAW,MAAM;AAC9C,WAAA;AAAA,KACR,GAAG;AACV;AAIA,SAAS,gBAAgB,QAAQ;AAC7B,MAAI,WAAW,MAAM;AACjB,WAAO;EACX;AACI,MAAA,MAAM,QAAQ,MAAM,GAAG;AAChB,WAAA;AAAA,EACX;AACI,MAAA,SAAS,MAAM,GAAG;AACX,WAAA;AAAA,EACX;AACA,SAAO,CAAC,MAAM;AAClB;AACA,SAAS,YAAY,UAAU;AACrB,QAAA,oBAAoB,CAAC,UAAU;AAEjC,QAAI,OAAO,UAAU,YAAY,MAAM,CAAC,MAAM,KAAK;AAC/C,aAAO,cAAc,MAAM,MAAM,CAAC,CAAC;AAAA,IACvC;AACO,WAAA;AAAA,EAAA;AAEP,MAAA,MAAM,QAAQ,QAAQ,GAAG;AAClB,WAAA,SAAS,IAAI,iBAAiB;AAAA,EACzC;AAEA,MAAI,oBAAoB,QAAQ;AAC5B,WAAO,CAAC,QAAQ;AAAA,EACpB;AACA,SAAO,OAAO,KAAK,QAAQ,EAAE,OAAO,CAAC,MAAM,QAAQ;AAC/C,SAAK,GAAG,IAAI,kBAAkB,SAAS,GAAG,CAAC;AACpC,WAAA;AAAA,EACX,GAAG,CAAE,CAAA;AACT;AAIA,MAAM,YAAY,CAAC,SAAS;AACxB,MAAI,SAAS,CAAA;AACb,QAAM,OAAO,KAAK,MAAM,GAAG,EAAE,CAAC;AAC1B,MAAA,KAAK,SAAS,GAAG,GAAG;AACX,aAAA,KAAK,MAAM,GAAG,EAAE,MAAM,CAAC,EAAE,KAAK,GAAG,EAAE,MAAM,GAAG;AAAA,EACzD;AACO,SAAA,EAAE,MAAM;AACnB;AACA,SAAS,cAAc,OAAO;AACpB,QAAA,UAAU,CAAC,eAAe;AAC5B,UAAM,MAAM,YAAY,YAAY,KAAK,KAAK,WAAW,KAAK;AACvD,WAAA;AAAA,EAAA;AAEX,UAAQ,eAAe;AAChB,SAAA;AACX;AACA,SAAS,gBAAgB,QAAQ;AACzB,MAAA,MAAM,QAAQ,MAAM,GAAG;AAChB,WAAA,OAAO,OAAO,SAAS;AAAA,EAClC;AACA,SAAO,OAAO,MAAM,EACf,OAAO,SAAO,UAAU,OAAO,GAAG,CAAC,CAAC,EACpC,IAAI,CAAO,QAAA,OAAO,GAAG,CAAC;AAC/B;AAEA,MAAM,iBAAiB;AAAA,EACnB,iBAAiB,CAAC,EAAE,MAAM,MAAM,GAAG,KAAK;AAAA,EACxC,OAAO;AAAA,EACP,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,iBAAiB;AAAA,EACjB,uBAAuB;AAC3B;AACA,IAAI,gBAAgB,OAAO,OAAO,IAAI,cAAc;AACpD,MAAM,YAAY,MAAM;AACxB,MAAM,YAAY,CAAC,YAAY;AACX,kBAAA,OAAO,OAAO,OAAO,OAAO,IAAI,aAAa,GAAG,OAAO;AAC3E;AACA,MAAM,YAAY;AAKlB,eAAe,SAAS,OAAO,OAAO,UAAU,CAAA,GAAI;AAChD,QAAM,aAAa,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ;AAC7E,QAAM,QAAQ;AAAA,IACV,OAAO,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,SAAS;AAAA,IAC1E;AAAA,IACA,OAAO,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ;AAAA,IACjE,OAAO,eAAe,QAAQ,eAAe,SAAS,aAAa;AAAA,IACnE,WAAW,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,WAAW,CAAC;AAAA,EAAA;AAErF,QAAM,SAAS,MAAM,UAAU,OAAO,KAAK;AAC3C,QAAM,SAAS,OAAO;AACf,SAAA;AAAA,IACH;AAAA,IACA,OAAO,CAAC,OAAO;AAAA,EAAA;AAEvB;AAIA,eAAe,UAAU,OAAO,OAAO;AACnC,MAAI,cAAc,MAAM,KAAK,KAAK,eAAe,MAAM,KAAK,GAAG;AACpD,WAAA,6BAA6B,OAAO,MAAM,KAAK;AAAA,EAC1D;AAEI,MAAA,WAAW,MAAM,KAAK,KAAK,MAAM,QAAQ,MAAM,KAAK,GAAG;AACvD,UAAM,MAAM;AAAA,MACR,OAAO,MAAM,SAAS,MAAM;AAAA,MAC5B,MAAM,MAAM;AAAA,MACZ,OAAO,MAAM;AAAA,MACb,MAAM,MAAM;AAAA,MACZ;AAAA,IAAA;AAGE,UAAA,WAAW,MAAM,QAAQ,MAAM,KAAK,IAAI,MAAM,QAAQ,CAAC,MAAM,KAAK;AACxE,UAAMC,UAAS,SAAS;AACxB,UAAMC,UAAS,CAAA;AACf,aAAS,IAAI,GAAG,IAAID,SAAQ,KAAK;AACvB,YAAA,OAAO,SAAS,CAAC;AACvB,YAAM,SAAS,MAAM,KAAK,OAAO,GAAG;AAC9B,YAAA,UAAU,OAAO,WAAW,YAAY,CAAC,MAAM,QAAQ,MAAM,KAAK;AACxE,UAAI,SAAS;AACT;AAAA,MACJ;AACI,UAAA,MAAM,QAAQ,MAAM,GAAG;AACvBC,gBAAO,KAAK,GAAG,MAAM;AAAA,MAAA,OAEpB;AACD,cAAM,UAAU,OAAO,WAAW,WAAW,SAAS,oBAAoB,GAAG;AAC7EA,gBAAO,KAAK,OAAO;AAAA,MACvB;AACA,UAAI,MAAM,OAAO;AACN,eAAA;AAAA,UACH,QAAAA;AAAAA,QAAA;AAAA,MAER;AAAA,IACJ;AACO,WAAA;AAAA,MACH,QAAAA;AAAAA,IAAA;AAAA,EAER;AACA,QAAM,oBAAoB,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,KAAK,GAAG,EAAE,OAAO,eAAe,MAAM,KAAK,EAAG,CAAA;AACxG,QAAM,SAAS,CAAA;AACf,QAAM,YAAY,OAAO,KAAK,kBAAkB,KAAK;AACrD,QAAM,SAAS,UAAU;AACzB,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AACvB,UAAA,OAAO,UAAU,CAAC;AACxB,UAAM,SAAS,MAAM,MAAM,mBAAmB,OAAO;AAAA,MACjD,MAAM;AAAA,MACN,QAAQ,kBAAkB,MAAM,IAAI;AAAA,IAAA,CACvC;AACD,QAAI,OAAO,OAAO;AACP,aAAA,KAAK,OAAO,KAAK;AACxB,UAAI,MAAM,OAAO;AACN,eAAA;AAAA,UACH;AAAA,QAAA;AAAA,MAER;AAAA,IACJ;AAAA,EACJ;AACO,SAAA;AAAA,IACH;AAAA,EAAA;AAER;AACA,SAAS,WAAW,KAAK;AACrB,SAAO,CAAC,CAAC,OAAO,IAAI,SAAS;AACjC;AACA,SAAS,iBAAiB,WAAW;AACjC,QAAM,SAAS;AAAA,IACX,QAAQ;AAAA,IACR,MAAM,MAAM,QAAQ;AACZ,UAAA;AACA,UAAA;AACM,cAAA,SAAS,MAAM,UAAU,SAAS,QAAQ,EAAE,YAAY,OAAO;AAC9D,eAAA;AAAA,UACH;AAAA,UACA,QAAQ,CAAC;AAAA,QAAA;AAAA,eAGV,KAAK;AAGJ,YAAA,CAAC,WAAW,GAAG,GAAG;AACZ,gBAAA;AAAA,QACV;AACA,YAAI,GAAG,KAAK,IAAI,WAAW,QAAQ,OAAO,SAAS,SAAS,GAAG,WAAW,IAAI,OAAO,QAAQ;AAClF,iBAAA,EAAE,QAAQ,CAAC,EAAE,MAAM,IAAI,MAAM,QAAQ,IAAI,OAAQ,CAAA;QAC5D;AACA,cAAM,SAAS,IAAI,MAAM,OAAO,CAAC,KAAK,SAAS;AACrC,gBAAA,OAAO,KAAK,QAAQ;AACtB,cAAA,CAAC,IAAI,IAAI,GAAG;AACZ,gBAAI,IAAI,IAAI,EAAE,QAAQ,IAAI,KAAK;AAAA,UACnC;AACA,cAAI,IAAI,EAAE,OAAO,KAAK,GAAG,KAAK,MAAM;AAC7B,iBAAA;AAAA,QACX,GAAG,CAAE,CAAA;AACL,eAAO,EAAE,QAAQ,OAAO,OAAO,MAAM,EAAE;AAAA,MAC3C;AAAA,IACJ;AAAA,EAAA;AAEG,SAAA;AACX;AAIA,eAAe,6BAA6B,OAAO,QAAQ;AACvD,QAAM,cAAc,cAAc,MAAM,IAAI,SAAS,iBAAiB,MAAM;AAC5E,QAAM,SAAS,MAAM,YAAY,MAAM,KAAK;AAC5C,QAAM,WAAW,CAAA;AACN,aAAA,SAAS,OAAO,QAAQ;AAC3B,QAAA,MAAM,OAAO,QAAQ;AACZ,eAAA,KAAK,GAAG,MAAM,MAAM;AAAA,IACjC;AAAA,EACJ;AACO,SAAA;AAAA,IACH,QAAQ;AAAA,EAAA;AAEhB;AAIA,eAAe,MAAM,OAAO,OAAO,MAAM;AAC/B,QAAA,YAAY,YAAY,KAAK,IAAI;AACvC,MAAI,CAAC,WAAW;AACZ,UAAM,IAAI,MAAM,sBAAsB,KAAK,IAAI,WAAW;AAAA,EAC9D;AACA,QAAM,SAAS,iBAAiB,KAAK,QAAQ,MAAM,QAAQ;AAC3D,QAAM,MAAM;AAAA,IACR,OAAO,MAAM,SAAS,MAAM;AAAA,IAC5B,MAAM,MAAM;AAAA,IACZ,OAAO,MAAM;AAAA,IACb;AAAA,IACA,MAAM,MAAM;AAAA,IACZ,MAAM,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,IAAI,GAAG,EAAE,QAAQ;AAAA,EAAA;AAE3D,QAAM,SAAS,MAAM,UAAU,OAAO,QAAQ,GAAG;AAC7C,MAAA,OAAO,WAAW,UAAU;AACrB,WAAA;AAAA,MACH,OAAO;AAAA,IAAA;AAAA,EAEf;AACO,SAAA;AAAA,IACH,OAAO,SAAS,SAAY,oBAAoB,GAAG;AAAA,EAAA;AAE3D;AAIA,SAAS,oBAAoB,UAAU;AAC7B,QAAA,UAAU,UAAY,EAAA;AAC5B,MAAI,CAAC,SAAS;AACH,WAAA;AAAA,EACX;AACA,SAAO,QAAQ,QAAQ;AAC3B;AACA,SAAS,iBAAiB,QAAQ,YAAY;AACpC,QAAA,YAAY,CAAC,UAAU;AACrB,QAAA,UAAU,KAAK,GAAG;AAClB,aAAO,MAAM,UAAU;AAAA,IAC3B;AACO,WAAA;AAAA,EAAA;AAEP,MAAA,MAAM,QAAQ,MAAM,GAAG;AAChB,WAAA,OAAO,IAAI,SAAS;AAAA,EAC/B;AACA,SAAO,OAAO,KAAK,MAAM,EAAE,OAAO,CAAC,KAAK,UAAU;AAC9C,QAAI,KAAK,IAAI,UAAU,OAAO,KAAK,CAAC;AAC7B,WAAA;AAAA,EACX,GAAG,CAAE,CAAA;AACT;AACA,eAAe,oBAAoB,QAAQ,QAAQ;AAC/C,QAAM,cAAc,cAAc,MAAM,IAAI,SAAS,iBAAiB,MAAM;AAC5E,QAAM,mBAAmB,MAAM,YAAY,MAAM,MAAM,MAAM,CAAC;AAC9D,QAAM,UAAU,CAAA;AAChB,QAAM,SAAS,CAAA;AACJ,aAAA,SAAS,iBAAiB,QAAQ;AACzC,UAAM,WAAW,MAAM;AAEjB,UAAA,QAAQ,MAAM,QAAQ,IAAI,QAAQ,gBAAgB,CAAC,GAAG,MAAM;AAC9D,aAAO,IAAI,CAAC;AAAA,IAAA,CACf;AACO,YAAA,IAAI,IAAI,EAAE,OAAO,CAAC,SAAS,QAAQ,QAAQ;AACnD,QAAI,SAAS,QAAQ;AACV,aAAA,IAAI,IAAI,SAAS,CAAC;AAAA,IAC7B;AAAA,EACJ;AACO,SAAA;AAAA,IACH,OAAO,CAAC,iBAAiB,OAAO;AAAA,IAChC;AAAA,IACA;AAAA,IACA,QAAQ,iBAAiB;AAAA,EAAA;AAEjC;AACA,eAAe,qBAAqB,QAAQ,QAAQ,MAAM;AAChD,QAAA,QAAQ,OAAO,MAAM;AAC3B,QAAM,cAAc,MAAM,IAAI,OAAO,SAAS;AAC1C,QAAI,IAAI,IAAI;AACZ,UAAM,WAAW,KAAK,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,WAAW,QAAQ,OAAO,SAAS,SAAS,GAAG,IAAI;AACpH,UAAA,cAAc,MAAM,SAAS,YAAY,QAAQ,IAAI,GAAG,OAAO,IAAI,GAAG;AAAA,MACxE,OAAO,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,SAAS;AAAA,MAC1E,OAAO,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ;AAAA,MACjE;AAAA,MACA,QAAQ,MAAM,KAAK,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,IAAI,OAAO,QAAQ,OAAO,SAAS,KAAK;AAAA,IAAA,CACjK;AACM,WAAA,OAAO,OAAO,OAAO,OAAO,IAAI,WAAW,GAAG,EAAE,KAAA,CAAM;AAAA,EAAA,CAChE;AACD,MAAI,aAAa;AACjB,QAAM,oBAAoB,MAAM,QAAQ,IAAI,WAAW;AACvD,QAAM,UAAU,CAAA;AAChB,QAAM,SAAS,CAAA;AACf,aAAW,UAAU,mBAAmB;AAC5B,YAAA,OAAO,IAAI,IAAI;AAAA,MACnB,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO;AAAA,IAAA;AAEf,QAAA,CAAC,OAAO,OAAO;AACF,mBAAA;AACb,aAAO,OAAO,IAAI,IAAI,OAAO,OAAO,CAAC;AAAA,IACzC;AAAA,EACJ;AACO,SAAA;AAAA,IACH,OAAO;AAAA,IACP;AAAA,IACA;AAAA,EAAA;AAER;AAEA,IAAI,aAAa;AACjB,SAAS,cAAc,MAAM,MAAM;AACzB,QAAA,EAAE,OAAO,cAAc,oBAAoB,eAAe,MAAM,KAAK,YAAY,KAAK,IAAI;AAC5F,MAAA,CAAC,KAAK,MAAM;AAIHC,QAAAA,YAAT,SAAkBC,QAAO;AACjB,UAAA;AACJ,UAAI,WAAWA,QAAO;AAClB,cAAM,QAAQA,OAAM;AAAA,MACxB;AACA,UAAI,YAAYA,QAAO;AACnB,kBAAUA,OAAM,MAAM;AAAA,MAC1B;AACA,UAAI,aAAaA,QAAO;AACf,aAAA,WAAW,KAAKA,OAAM,aAAa,QAAQ,OAAO,SAAS,KAAK,KAAK;AAAA,MAC9E;AACA,UAAI,kBAAkBA,QAAO;AACzB,wBAAgBA,OAAM,YAAY;AAAA,MACtC;AAAA,IAAA;AAhBJ,UAAM,EAAE,QAAAF,SAAQ,cAAc,kBAAkB;AAChD,UAAM,KAAK,cAAc,OAAO,mBAAmB,IAAI,EAAE;AACzD,UAAM,OAAO,gBAAgB,OAAO,cAAcA,SAAQ,KAAK,MAAM;AAgB9D,WAAA;AAAA,MACH;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,EAAE,gBAAgB,EAAE,CAAC,EAAE,GAAG,MAAS,GAAA,cAAc,MAAM;AAAA,MAC9D,QAAAA;AAAAA,MACA,UAAAC;AAAAA,IAAA;AAAA,EAER;AACA,QAAM,QAAQ,KAAK,KAAK,gBAAgB,MAAM;AAAA,IAC1C,OAAO,KAAK;AAAA,IACZ,OAAO,KAAK;AAAA,IACZ,MAAM,KAAK;AAAA,IACX,UAAU,KAAK;AAAA,IACf,QAAQ,KAAK;AAAA,EAAA,CAChB;AACD,QAAM,SAAS,SAAS,MAAM,MAAM,MAAM;AAC1C,WAAS,SAASC,QAAO;AACrB,QAAI,IAAI,IAAI;AACZ,QAAI,WAAWA,QAAO;AAClB,YAAM,QAAQA,OAAM;AAAA,IACxB;AACA,QAAI,YAAYA,QAAO;AACnB,OAAC,KAAK,KAAK,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,cAAc,MAAM,IAAI,GAAGA,OAAM,MAAM;AAAA,IACpG;AACA,QAAI,aAAaA,QAAO;AACpB,OAAC,KAAK,KAAK,UAAU,QAAQ,OAAO,SAAS,SAAS,GAAG,gBAAgB,MAAM,IAAI,IAAI,KAAKA,OAAM,aAAa,QAAQ,OAAO,SAAS,KAAK,KAAK;AAAA,IACrJ;AACA,QAAI,kBAAkBA,QAAO;AACzB,sBAAgBA,OAAM,YAAY;AAAA,IACtC;AAAA,EACJ;AACO,SAAA;AAAA,IACH,IAAI,MAAM,QAAQ,MAAM,EAAE,IAAI,MAAM,GAAG,MAAM,GAAG,SAAS,CAAC,IAAI,MAAM;AAAA,IACpE;AAAA,IACA;AAAA,IACA;AAAA,IACA,MAAM;AAAA,IACN;AAAA,IACA,OAAO,MAAM;AAAA,IACb;AAAA,EAAA;AAER;AAIA,SAAS,eAAe,MAAM,YAAY,MAAM;AAC5C,QAAM,WAAW,IAAI,MAAM,UAAU,CAAC;AACtC,WAASC,uBAAsB;AAC3B,QAAI,CAAC,MAAM;AACP,aAAO,MAAM,QAAQ;AAAA,IACzB;AACO,WAAA,YAAY,KAAK,cAAc,OAAO,MAAM,IAAI,GAAG,MAAM,QAAQ,CAAC;AAAA,EAC7E;AACA,WAAS,gBAAgBC,QAAO;AAC5B,QAAI,CAAC,MAAM;AACP,eAAS,QAAQA;AACjB;AAAA,IACJ;AACA,SAAK,qBAAqB,MAAM,IAAI,GAAGA,QAAO,IAAI;AAAA,EACtD;AACM,QAAA,eAAe,SAASD,oBAAmB;AAEjD,MAAI,CAAC,MAAM;AACDC,UAAAA,SAAQ,IAAID,qBAAAA,CAAqB;AAChC,WAAA;AAAA,MACH,OAAAC;AAAAA,MACA;AAAA,MACA;AAAA,IAAA;AAAA,EAER;AAKA,QAAM,eAAe,kBAAkB,YAAY,MAAM,cAAc,IAAI;AAC3E,OAAK,kBAAkB,MAAM,IAAI,GAAG,cAAc,IAAI;AAEtD,QAAM,QAAQ,SAAS;AAAA,IACnB,MAAM;AACF,aAAO,YAAY,KAAK,QAAQ,MAAM,IAAI,CAAC;AAAA,IAC/C;AAAA,IACA,IAAI,QAAQ;AACR,WAAK,cAAc,MAAM,IAAI,GAAG,QAAQ,KAAK;AAAA,IACjD;AAAA,EAAA,CACH;AACM,SAAA;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAER;AAOA,SAAS,kBAAkB,YAAY,MAAM,cAAc,MAAM;AACzD,MAAA,MAAM,UAAU,GAAG;AACnB,WAAO,MAAM,UAAU;AAAA,EAC3B;AACA,MAAI,eAAe,QAAW;AACnB,WAAA;AAAA,EACX;AACO,SAAA,YAAY,KAAK,QAAQ,MAAM,IAAI,GAAG,MAAM,YAAY,CAAC;AACpE;AAIA,SAAS,gBAAgB,cAAc,cAAc,QAAQ,QAAQ;AACjE,MAAI,IAAI;AACF,QAAA,cAAc,MAAM,KAAK,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,MAAM,EAAE,cAAc,QAAQ,OAAO,SAAS,KAAK;AAChM,QAAM,OAAO,SAAS;AAAA,IAClB,SAAS;AAAA,IACT,SAAS;AAAA,IACT,OAAO;AAAA,IACP,UAAU;AAAA,IACV,WAAW,CAAC,CAAC,MAAM,MAAM,EAAE;AAAA,IAC3B,cAAc,SAAS,MAAM,MAAM,YAAY,CAAC;AAAA,IAChD,OAAO,SAAS,MAAM;AAClB,aAAO,CAAC,QAAQ,MAAM,YAAY,GAAG,MAAM,YAAY,CAAC;AAAA,IAAA,CAC3D;AAAA,EAAA,CACJ;AACD,QAAM,QAAQ,CAAS,UAAA;AACd,SAAA,QAAQ,CAAC,MAAM;AAAA,EAAA,GACrB;AAAA,IACC,WAAW;AAAA,IACX,OAAO;AAAA,EAAA,CACV;AACM,SAAA;AACX;AAIA,SAAS,oBAAoB;AACnB,QAAA,SAAS,IAAI,CAAA,CAAE;AACd,SAAA;AAAA,IACH;AAAA,IACA,WAAW,CAAC,aAAa;AACd,aAAA,QAAQ,mBAAmB,QAAQ;AAAA,IAC9C;AAAA,EAAA;AAER;AAEA,SAAS,sBAAsB,KAAK;AAC3B,MAAA,QAAQ,IAAI,aAAa,cAAe;AACrB,wBAAA;AAAA,MAChB,IAAI;AAAA,MACJ,OAAO;AAAA,MACP,aAAa;AAAA,MACb,UAAU;AAAA,MACV;AAAA,MACA,MAAM;AAAA,OACP,aAAa;AAAA,EACpB;AACJ;AACA,MAAM,iBAAiB,CAAA;AACvB,MAAM,kBAAkB,CAAA;AACxB,IAAI;AACJ,MAAM,mBAAmB,SAAS,MAAM;AACpC,aAAW,YAAY;AACnB,UAAM,SAAS;AACf,YAAQ,QAAQ,QAAQ,SAAS,SAAS,IAAI,mBAAmB,YAAY;AAC7E,YAAQ,QAAQ,QAAQ,SAAS,SAAS,IAAI,kBAAkB,YAAY;AAAA,KAC7E,GAAG;AACV,GAAG,GAAG;AACN,SAAS,yBAAyB,MAAM;AACpC,QAAM,KAAK;AACX,MAAI,CAAC,KAAK;AACN,UAAM,MAAM,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,WAAW;AAClE,QAAI,CAAC,KAAK;AACN;AAAA,IACJ;AACA,0BAAsB,GAAG;AAAA,EAC7B;AACA,iBAAe,KAAK,MAAM,IAAI,OAAO,OAAO,CAAA,GAAI,IAAI;AACrC,iBAAA,KAAK,MAAM,EAAE,MAAM;AAClC,cAAY,MAAM;AACP,WAAA,eAAe,KAAK,MAAM;AAChB;EAAA,CACpB;AACgB;AACrB;AACA,SAAS,gCAAgC,OAAO;AAC5C,QAAM,KAAK;AACX,MAAI,CAAC,KAAK;AACN,UAAM,MAAM,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,WAAW;AAClE,QAAI,CAAC,KAAK;AACN;AAAA,IACJ;AACA,0BAAsB,GAAG;AAAA,EAC7B;AACA,kBAAgB,MAAM,EAAE,IAAI,OAAO,OAAO,CAAA,GAAI,KAAK;AACnC,kBAAA,MAAM,EAAE,EAAE,MAAM;AAChC,cAAY,MAAM;AACP,WAAA,gBAAgB,MAAM,EAAE;AACd;EAAA,CACpB;AACgB;AACrB;AACA,MAAM,eAAe;AACrB,MAAM,SAAS;AAAA,EACX,OAAO;AAAA,EACP,SAAS;AAAA,EACT,SAAS;AAAA,EACT,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,MAAM;AACV;AACA,IAAI,gBAAgB;AACpB,SAAS,cAAc,KAAK;AAClB,QAAA;AACN,MAAI,aAAa;AAAA,IACb,IAAI;AAAA,IACJ,MAAM;AAAA,IACN,OAAO;AAAA,IACP,iBAAiB;AAAA,IACjB,SAAS;AAAA,MACL;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,QACT,QAAQ,YAAY;AAChB,cAAI,CAAC,eAAe;AAChB,oBAAQ,MAAM,8DAA8D;AAC5E;AAAA,UACJ;AACI,cAAA,cAAc,SAAS,SAAS;AAC1B,kBAAA,cAAc,MAAM;AAC1B;AAAA,UACJ;AACI,cAAA,cAAc,SAAS,QAAQ;AACzB,kBAAA,cAAc,KAAK;AACzB;AAAA,UACJ;AACI,cAAA,cAAc,SAAS,aAAa;AACpC,kBAAM,cAAc,KAAK,cAAc,cAAc,MAAM,IAAI;AAAA,UACnE;AAAA,QACJ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,QACT,QAAQ,MAAM;AACV,cAAI,CAAC,eAAe;AAChB,oBAAQ,MAAM,8DAA8D;AAC5E;AAAA,UACJ;AACI,cAAA,cAAc,SAAS,SAAS;AAChC,0BAAc,MAAM;AACpB;AAAA,UACJ;AACI,cAAA,cAAc,SAAS,QAAQ;AAC/B,0BAAc,KAAK;UACvB;AACI,cAAA,cAAc,SAAS,aAAa;AACpC,0BAAc,KAAK,WAAW,cAAc,MAAM,IAAI;AAAA,UAC1D;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EAAA,CACH;AACG,MAAA,GAAG,iBAAiB,CAAW,YAAA;AAC3B,QAAA,QAAQ,gBAAgB,cAAc;AACtC;AAAA,IACJ;AACM,UAAA,QAAQ,OAAO,OAAO,cAAc;AACpC,UAAA,SAAS,OAAO,OAAO,eAAe;AAC5C,YAAQ,YAAY;AAAA,MAChB,GAAG,MAAM,IAAI,2BAA2B;AAAA,MACxC,GAAG,OAAO,IAAI,CAAS,UAAA,6BAA6B,KAAK,CAAC;AAAA,IAAA;AAAA,EAC9D,CACH;AACD,MAAI,GAAG,kBAAkB,CAAC,SAAS,QAAQ;AACvC,QAAI,QAAQ,gBAAgB,gBAAgB,IAAI,eAAe,oBAAoB,YAAY,IAAI;AAC/F;AAAA,IACJ;AACM,UAAA,EAAE,MAAM,OAAO,OAAO,SAAS,aAAa,QAAQ,MAAM;AAC5D,QAAA,QAAQ,SAAS,QAAQ;AACjB,cAAA,QAAQ,eAAe,IAAI;AACnB,sBAAA,EAAE,MAAM,QAAQ,KAAK;AACrC;AAAA,IACJ;AACI,QAAA,SAAS,SAAS,eAAe,MAAM;AAC/B,cAAA,QAAQ,gBAAgB,KAAK;AACrC,sBAAgB,EAAE,MAAM,aAAa,OAAO,KAAK;AACjD;AAAA,IACJ;AACI,QAAA,SAAS,SAAS,SAAS;AAC3B,cAAQ,QAAQ,gBAAgB;AAAA,QAC5B,QAAQ,MAAM,OAAO;AAAA,QACrB,OAAO,MAAM,KAAK;AAAA,QAClB,OAAO,MAAM,KAAK;AAAA,QAClB,SAAS,MAAM,KAAK;AAAA,QACpB,OAAO,MAAM,MAAM;AAAA,QACnB,cAAc,MAAM,KAAK;AAAA,MAAA,CAC5B;AACe,sBAAA,EAAE,OAAO,MAAM,QAAQ;AACvC;AAAA,IACJ;AACgB,oBAAA;AAAA,EAAA,CACnB;AACL;AACA,SAAS,4BAA4B,MAAM;AACjC,QAAA,EAAE,WAAW,YAAY,kBAAkB,KAAK,KAAK,MAAM,KAAK;AACtE,QAAM,gBAAgB,CAAA;AACtB,SAAO,OAAO,KAAK,iBAAkB,CAAA,EAAE,QAAQ,CAAS,UAAA;AAC1C,cAAA,eAAe,MAAM,MAAM,IAAI,GAAG,4BAA4B,OAAO,IAAI,CAAC;AAAA,EAAA,CACvF;AACD,WAAS,cAAc,MAAM,OAAO,IAAI;AACpC,UAAM,MAAM,CAAC,GAAG,IAAI,EAAE,IAAI;AAC1B,QAAI,QAAQ,MAAM;AACd,aAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,IAAI,GAAG,EAAE,OAAO,OAAO,KAAK,MAAO,CAAA;AAAA,IAC9E;AACI,QAAA,SAAS,IAAI,GAAG;AACT,aAAA;AAAA,QACH,IAAI,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,QACrB,OAAO,OAAO;AAAA,QACd,UAAU,OAAO,KAAK,IAAI,EAAE,IAAI,CAAAC,SAAO,cAAc,KAAKA,IAAG,GAAG,CAAC,GAAG,MAAMA,IAAG,CAAC,CAAC;AAAA,MAAA;AAAA,IAEvF;AACI,QAAA,MAAM,QAAQ,IAAI,GAAG;AACd,aAAA;AAAA,QACH,IAAI,GAAG,KAAK,KAAK,GAAG,CAAC;AAAA,QACrB,OAAO,GAAG,GAAG;AAAA,QACb,UAAU,KAAK,IAAI,CAAC,GAAG,QAAQ,cAAc,GAAG,CAAC,GAAG,MAAM,OAAO,GAAG,CAAC,CAAC,CAAC;AAAA,MAAA;AAAA,IAE/E;AACA,WAAO,EAAE,IAAI,IAAI,OAAO,IAAI,UAAU,CAAA;EAC1C;AACA,QAAM,EAAE,SAAA,IAAa,cAAc,aAAa;AACzC,SAAA;AAAA,IACH,IAAI,aAAa,IAAI;AAAA,IACrB,OAAO;AAAA,IACP;AAAA,IACA,MAAM;AAAA,MACF;AAAA,QACI,OAAO;AAAA,QACP;AAAA,QACA,iBAAiB;AAAA,MACrB;AAAA,MACA;AAAA,QACI,OAAO,GAAG,KAAK,iBAAA,EAAmB,MAAM;AAAA,QACxC,WAAW,OAAO;AAAA,QAClB,iBAAiB,OAAO;AAAA,MAC5B;AAAA,IACJ;AAAA,EAAA;AAER;AACA,SAAS,4BAA4B,OAAO,MAAM;AACvC,SAAA;AAAA,IACH,IAAI,aAAa,MAAM,KAAK;AAAA,IAC5B,OAAO,MAAM,MAAM,IAAI;AAAA,IACvB,MAAM,iBAAiB,MAAM,UAAU,MAAM,aAAa,MAAM,MAAM,MAAM,OAAO,IAAI;AAAA,EAAA;AAE/F;AACA,SAAS,6BAA6B,OAAO,MAAM;AACxC,SAAA;AAAA,IACH,IAAI,aAAa,MAAM,KAAK;AAAA,IAC5B,OAAO,MAAM,MAAM,IAAI;AAAA,IACvB,MAAM,iBAAiB,OAAO,GAAG,MAAM,MAAM,MAAM,KAAK,OAAO,IAAI;AAAA,EAAA;AAE3E;AACA,SAAS,iBAAiB,UAAU,aAAa,MAAM,OAAO,MAAM;AAChE,QAAM,EAAE,WAAW,QAAQ,IAAI,kBAAkB,KAAK;AAC/C,SAAA;AAAA,IACH,WACM,SACA;AAAA,MACE,OAAO;AAAA,MACP;AAAA,MACA,iBAAiB;AAAA,IACrB;AAAA,IACJ,CAAC,OACK;AAAA,MACE,OAAO;AAAA,MACP,WAAW,OAAO;AAAA,MAClB,iBAAiB,OAAO;AAAA,IAE1B,IAAA;AAAA,IACN,SAAS,aACH;AAAA,MACE,OAAO;AAAA,MACP,WAAW,OAAO;AAAA,MAClB,iBAAiB,OAAO;AAAA,IAE1B,IAAA;AAAA,IACN,SAAS,UACH;AAAA,MACE,OAAO;AAAA,MACP,WAAW,OAAO;AAAA,MAClB,iBAAiB,OAAO;AAAA,IAE1B,IAAA;AAAA,IACN,WACM;AAAA,MACE,OAAO;AAAA,MACP,WAAW,OAAO;AAAA,MAClB,iBAAiB,OAAO;AAAA,IAE1B,IAAA;AAAA,EAAA,EACR,OAAO,OAAO;AACpB;AACA,SAAS,aAAa,MAAM,cAAc;AACtC,QAAM,OAAO,eAAgB,UAAU,eAAe,cAAc,UAAW;AAC/E,QAAM,YAAY,eAAgB,UAAU,eAAe,iBAAiB,QAAQ,iBAAiB,SAAS,SAAS,aAAa,OAAO,MAAM,iBAAiB,QAAQ,iBAAiB,SAAS,SAAS,aAAa,IAAI,IAAK;AACnO,QAAM,WAAW,EAAE,GAAG,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,QAAQ,IAAI,WAAW,KAAK;AACnG,SAAO,KAAK,mBAAmB,KAAK,UAAU,QAAQ,CAAC,CAAC;AAC5D;AACA,SAAS,aAAa,QAAQ;AACtB,MAAA;AACA,UAAM,WAAW,KAAK,MAAM,mBAAmB,KAAK,MAAM,CAAC,CAAC;AACtD,UAAA,OAAO,eAAe,SAAS,CAAC;AAClC,QAAA,CAAC,QAAQ,SAAS,IAAI;AAChB,YAAA,QAAQ,gBAAgB,SAAS,EAAE;AACzC,UAAI,CAAC,OAAO;AACR,eAAO;MACX;AACO,aAAA;AAAA,QACH,MAAM,SAAS;AAAA,QACf;AAAA,MAAA;AAAA,IAER;AACA,QAAI,CAAC,MAAM;AACP,aAAO;IACX;AACA,UAAM,QAAQ,KAAK,aAAa,SAAS,EAAE;AACpC,WAAA;AAAA,MACH,MAAM,SAAS;AAAA,MACf;AAAA,MACA;AAAA,IAAA;AAAA,WAGD,KAAK;AAAA,EAEZ;AACA,SAAO;AACX;AACA,SAAS,gBAAgB,OAAO;AACrB,SAAA;AAAA,IACH,eAAe;AAAA,MACX,EAAE,KAAK,UAAU,OAAO,MAAM,OAAO;AAAA,MACrC;AAAA,QACI,KAAK;AAAA,QACL,OAAO,MAAM;AAAA,MACjB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,MAAM;AAAA,MACjB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,MAAM;AAAA,MACjB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,MAAM;AAAA,MACjB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,MAAM;AAAA,MACjB;AAAA,IACJ;AAAA,EAAA;AAER;AACA,SAAS,eAAe,MAAM;AAC1B,QAAM,EAAE,UAAU,MAAM,QAAQ,cAAc,cAAc,YAAgB,IAAA;AACrE,SAAA;AAAA,IACH,cAAc;AAAA,MACV;AAAA,QACI,KAAK;AAAA,QACL,OAAO,YAAY;AAAA,MACvB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,aAAa;AAAA,MACxB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,aAAa;AAAA,MACxB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,KAAK,MAAM;AAAA,MACtB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,KAAK,MAAM;AAAA,MACtB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,KAAK,MAAM;AAAA,MACtB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,KAAK,MAAM;AAAA,MACtB;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO;AAAA,MACX;AAAA,MACA;AAAA,QACI,KAAK;AAAA,QACL,OAAO,OAAO,SAAS,KAAK,EAAE,OAAO,CAAC,KAAK,QAAQ;AAC3C,cAAA;AACE,gBAAA,WAAW,KAAK,SAAS,MAAM,GAAG,OAAO,QAAQ,OAAO,SAAS,SAAS,GAAG,CAAC;AACpF,cAAI,SAAS;AACT,gBAAI,GAAG,IAAI;AAAA,UACf;AACO,iBAAA;AAAA,QACX,GAAG,EAAE;AAAA,MACT;AAAA,IACJ;AAAA,EAAA;AAER;AAIA,SAAS,kBAAkB,OAAO;AACvB,SAAA;AAAA,IACH,SAAS,QAAQ,OAAO,UAAU,OAAO;AAAA,IACzC,WAAW,QAAQ,OAAO,QAAQ,OAAO;AAAA,EAAA;AAEjD;AAKA,SAAS,SAAS,MAAM,OAAO,MAAM;AAC7B,MAAA,eAAe,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,IAAI,GAAG;AAChE,WAAA,oBAAoB,MAAM,OAAO,IAAI;AAAA,EAChD;AACO,SAAA,UAAU,MAAM,OAAO,IAAI;AACtC;AACA,SAAS,UAAU,MAAM,OAAO,MAAM;AAClC,QAAM,EAAE,cAAc,YAAY,iBAAiB,OAAO,MAAM,cAAc,OAAO,uBAAuB,gBAAgB,YAAY,oBAAoB,YAAY,MAAM,gBAAiB,iBAAiB,IAAI;AACpN,QAAM,eAAe,aAAa,eAAe,cAAc,IAAI;AACnE,QAAM,OAAO,eAAe;AAC5B,QAAM,OAAO,SAAS,MAAM,kBAAkB,QAAQ,IAAI,CAAC,CAAC;AACtD,QAAA,YAAY,SAAS,MAAM;AACvB,UAAA,SAAS,QAAQ,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,MAAM;AAC9E,QAAI,QAAQ;AACD,aAAA;AAAA,IACX;AACM,UAAA,aAAa,MAAM,KAAK;AAC9B,QAAI,eAAe,UAAU,KACzB,cAAc,UAAU,KACxB,WAAW,UAAU,KACrB,MAAM,QAAQ,UAAU,GAAG;AACpB,aAAA;AAAA,IACX;AACA,WAAO,eAAe,UAAU;AAAA,EAAA,CACnC;AACK,QAAA,EAAE,IAAI,OAAO,cAAc,MAAM,UAAU,QAAQ,MAAA,IAAU,cAAc,MAAM;AAAA,IACnF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,UAAU,QAAQC,cAAa;AAAA,IACzC,QAAQ,cAAc,KAAK,IAAI,QAAQ;AAAA,EAAA,CAC1C;AACD,QAAM,eAAe,SAAS,MAAM,OAAO,MAAM,CAAC,CAAC;AACnD,MAAI,YAAY;AACF,cAAA;AAAA,MACN;AAAA,MACA,MAAM;AAAA,MACN;AAAA,MACA,gBAAgB,MAAM,yBAAyB,CAAC,MAAM;AAAA,IAAA,CACzD;AAAA,EACL;AAIA,QAAM,aAAa,CAAC,KAAK,iBAAiB,UAAU;AAChD,SAAK,UAAU;AACf,QAAI,gBAAgB;AACU;IAC9B;AAAA,EAAA;AAEJ,iBAAe,qBAAqB,MAAM;AACtC,QAAI,IAAI;AACR,QAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,gBAAgB;AACjE,YAAM,EAAE,QAAQ,IAAI,MAAM,KAAK,eAAe,IAAI;AAClD,cAAQ,KAAK,QAAQ,QAAQ,IAAI,CAAC,OAAO,QAAQ,OAAO,SAAS,KAAK,EAAE,OAAO,MAAM,QAAQ,CAAA;IACjG;AACA,QAAI,UAAU,OAAO;AACjB,aAAO,SAAS,MAAM,OAAO,UAAU,OAAO;AAAA,QAC1C,MAAM,QAAQ,IAAI;AAAA,QAClB,OAAO,QAAQ,KAAK;AAAA,QACpB,SAAS,KAAK,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,YAAY,QAAQ,OAAO,SAAS,KAAK,CAAC;AAAA,QACzG;AAAA,MAAA,CACH;AAAA,IACL;AACA,WAAO,EAAE,OAAO,MAAM,QAAQ,CAAG,EAAA;AAAA,EACrC;AACM,QAAA,4BAA4B,WAAW,YAAY;AACrD,SAAK,UAAU;AACf,SAAK,YAAY;AACjB,WAAO,qBAAqB,gBAAgB;AAAA,KAC7C,CAAU,WAAA;AACT,QAAI,MAAM,eAAe,MAAM,EAAE,GAAG;AACzB,aAAA;AAAA,IACX;AACA,aAAS,EAAE,QAAQ,OAAO,OAAQ,CAAA;AAClC,SAAK,UAAU;AACf,SAAK,QAAQ,OAAO;AACb,WAAA;AAAA,EAAA,CACV;AACK,QAAA,yBAAyB,WAAW,YAAY;AAClD,WAAO,qBAAqB,QAAQ;AAAA,KACrC,CAAU,WAAA;AACT,SAAK,QAAQ,OAAO;AACb,WAAA;AAAA,EAAA,CACV;AACD,WAASA,YAAWC,OAAM;AACtB,SAAKA,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,UAAU,UAAU;AACtE,aAAO,uBAAuB;AAAA,IAClC;AACA,WAAO,0BAA0B;AAAA,EACrC;AAES,WAAA,aAAa,GAAG,iBAAiB,MAAM;AACtC,UAAA,WAAW,oBAAoB,CAAC;AACtC,aAAS,UAAU,cAAc;AAAA,EACrC;AAYA,WAAS,WAAW,WAAW;AAC3B,SAAK,UAAU;AAAA,EACnB;AACA,WAAS,WAAW,OAAO;AACnB,QAAA;AACJ,UAAM,WAAW,SAAS,WAAW,QAAQ,MAAM,QAAQ,aAAa;AAC/D,aAAA;AAAA,MACL,OAAO,MAAM,QAAQ;AAAA,MACrB,cAAc,MAAM,QAAQ;AAAA,MAC5B,UAAU,KAAK,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,aAAa,QAAQ,OAAO,SAAS,KAAK;AAAA,MAC7G,SAAS,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,WAAW,CAAC;AAAA,IAAA,CAC5E;AACD,SAAK,UAAU;AACf,SAAK,YAAY;AACM;EAC3B;AACA,QAAM,KAAK;AACF,WAAA,SAAS,UAAU,iBAAiB,MAAM;AACzC,UAAA,QAAQ,MAAM,aAAa,oBAAoB,UAAU,GAAG,MAAM,cAAc,IAAI;AACpF,UAAA,aAAa,iBAAiB,4BAA4B;AACrD;EACf;AACA,WAAS,UAAUP,SAAQ;AACd,aAAA,EAAE,QAAQ,MAAM,QAAQA,OAAM,IAAIA,UAAS,CAACA,OAAM,EAAA,CAAG;AAAA,EAClE;AACA,QAAM,aAAa,SAAS;AAAA,IACxB,MAAM;AACF,aAAO,MAAM;AAAA,IACjB;AAAA,IACA,IAAI,UAAU;AACV,eAAS,UAAU,qBAAqB;AAAA,IAC5C;AAAA,EAAA,CACH;AACD,QAAM,QAAQ;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,aAAa,MAAM,WAAW;AAAA,IAC9B,UAAUM;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAEJ,UAAQ,iBAAiB,KAAK;AAC9B,MAAI,MAAM,KAAK,KAAK,OAAO,MAAM,KAAK,MAAM,YAAY;AAC9C,UAAA,OAAO,CAACF,QAAO,aAAa;AAC1B,UAAA,QAAQA,QAAO,QAAQ,GAAG;AAC1B;AAAA,MACJ;AACK,WAAA,YAAY,0BAA0B,IAAI,uBAAuB;AAAA,IAAA,GACvE;AAAA,MACC,MAAM;AAAA,IAAA,CACT;AAAA,EACL;AACK,MAAA,QAAQ,IAAI,aAAa,cAAe;AACzC,UAAM,MAAM;AACZ,UAAM,MAAO,OAAO,OAAO,OAAO,OAAO,EAAE,QAAQ,OAAO,MAAA,GAAS,IAAI,GAAG,EAAE,OAAO,MAAM,MAAM,CAAC,GAAI,kBAAkB;AAAA,MAClH,MAAM;AAAA,IAAA,CACT;AACD,QAAI,CAAC,MAAM;AACP,sCAAgC,KAAK;AAAA,IACzC;AAAA,EACJ;AAEA,MAAI,CAAC,MAAM;AACA,WAAA;AAAA,EACX;AAGM,QAAA,eAAe,SAAS,MAAM;AAChC,UAAM,WAAW,UAAU;AAE3B,QAAI,CAAC,YACD,WAAW,QAAQ,KACnB,eAAe,QAAQ,KACvB,cAAc,QAAQ,KACtB,MAAM,QAAQ,QAAQ,GAAG;AACzB,aAAO;IACX;AACA,WAAO,OAAO,KAAK,QAAQ,EAAE,OAAO,CAAC,KAAK,SAAS;AAC/C,YAAM,OAAO,gBAAgB,SAAS,IAAI,CAAC,EACtC,IAAI,CAAC,QAAQ,IAAI,YAAY,EAC7B,OAAO,CAAC,QAAQ,YAAY;AACvB,cAAA,WAAW,YAAY,KAAK,QAAQ,OAAO,KAAK,KAAK,OAAO,OAAO;AACzE,YAAI,aAAa,QAAW;AACxB,iBAAO,OAAO,IAAI;AAAA,QACtB;AACO,eAAA;AAAA,MACX,GAAG,CAAE,CAAA;AACE,aAAA,OAAO,KAAK,IAAI;AAChB,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EAAA,CACR;AAEK,QAAA,cAAc,CAAC,MAAM,YAAY;AAEnC,QAAI,CAAC,OAAO,KAAK,IAAI,EAAE,QAAQ;AAC3B;AAAA,IACJ;AACA,UAAM,iBAAiB,CAAC,QAAQ,MAAM,OAAO;AAC7C,QAAI,gBAAgB;AACX,WAAA,YAAY,0BAA0B,IAAI,uBAAuB;AAAA,IAC1E;AAAA,EAAA,CACH;AAiCM,SAAA;AACX;AAIA,SAAS,iBAAiB,MAAM;AAC5B,QAAM,WAAW,OAAO;AAAA,IACpB,cAAc;AAAA,IACd,iBAAiB;AAAA,IACjB,OAAO;AAAA,IACP,OAAO;AAAA,IACP,uBAAuB;AAAA,IACvB,oBAAoB;AAAA,IACpB,YAAY;AAAA,IACZ,YAAY;AAAA,EAAA;AAEV,QAAA,iBAAiB,CAAC,EAAE,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AAC3E,QAAM,gBAAgB,QAAQ,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,gBAAgB,WAAW,KAAK,cAAc,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,kBAAkB;AAChM,QAAM,eAAe,kBAAkB,EAAE,mBAAmB,QAAQ,OAC9D,qBAAqB,mBAAmB,GAAG,aAAa,IACxD,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACvD,MAAI,CAAC,MAAM;AACA,WAAA,OAAO,OAAO,OAAO,OAAO,IAAI,UAAU,GAAG,EAAE,aAAA,CAAc;AAAA,EACxE;AAEA,QAAM,eAAe,eAAe,OAAO,KAAK,YAAY,KAAK;AACjE,QAAM,aAAa,gBAAgB,OAAO,CAAC,KAAK,aAAa,KAAK;AAClE,QAAM,cAAc,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,mBAAmB,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,eAAe;AACxJ,SAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,SAAU,CAAA,GAAI,QAAQ,CAAG,CAAA,GAAG;AAAA,IAAE;AAAA,IAAc,YAAY,eAAe,QAAQ,eAAe,SAAS,aAAa;AAAA,IAAM;AAAA,IAC3K;AAAA,EAAA,CAAY;AACpB;AACA,SAAS,oBAAoB,MAAM,OAAO,MAAM;AACtC,QAAA,OAAO,EAAE,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,cAAc,eAAe,cAAc,IAAI;AAC/G,QAAM,eAAe,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACtE,QAAM,iBAAiB,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACxE,WAAS,gBAAgB,OAAO;AAC5B,UAAM,eAAe,MAAM;AACrB,UAAA,UAAU,SAAS,MAAM;AACrB,YAAA,eAAe,QAAQ,MAAM,KAAK;AAClC,YAAA,aAAa,QAAQ,YAAY;AACvC,aAAO,MAAM,QAAQ,YAAY,IAC3B,aAAa,UAAU,CAAA,MAAK,QAAQ,GAAG,UAAU,CAAC,KAAK,IACvD,QAAQ,YAAY,YAAY;AAAA,IAAA,CACzC;AACQ,aAAA,qBAAqB,GAAG,iBAAiB,MAAM;AACpD,UAAI,IAAI;AACR,UAAI,QAAQ,YAAY,KAAK,MAAM,QAAQ,MAAM,SAAS,SAAS,EAAE,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,UAAU;AAC3H,YAAI,gBAAgB;AAChB,gBAAM,SAAS;AAAA,QACnB;AACA;AAAA,MACJ;AACM,YAAA,OAAO,QAAQ,IAAI;AACnB,YAAA,YAAY,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,aAAa,IAAI;AAC9E,YAAA,QAAQ,oBAAoB,CAAC;AAC/B,UAAA,YAAY,KAAK,QAAQ,YAAY,OAAO,QAAQ,OAAO,SAAS,KAAK;AACzE,UAAA,SAAS,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,aAAa,UAAU,SAAS,YAAY;AAC1G,mBAAA,yBAAyB,YAAY,KAAK,QAAQ,IAAI,KAAK,IAAI,UAAU,MAAS;AAAA,MACjG,YACU,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,UAAU,YAAY;AAClE,mBAAA,yBAAyB,QAAQ,MAAM,KAAK,GAAG,UAAU,QAAQ,cAAc,CAAC;AAAA,MAC/F;AACA,mBAAa,UAAU,cAAc;AAAA,IACzC;AACA,WAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,GAAG;AAAA,MAAE;AAAA,MAC7C;AAAA,MACA;AAAA,MAAgB,cAAc;AAAA,IAAA,CAAsB;AAAA,EAC5D;AACA,SAAO,gBAAgB,UAAU,MAAM,OAAO,IAAI,CAAC;AACvD;AACA,SAAS,UAAU,EAAE,MAAM,OAAO,cAAc,kBAAkB;AAC9D,QAAM,KAAK;AAEP,MAAA,CAAC,MAAM,CAAC,MAAM;AACT,QAAA,QAAQ,IAAI,aAAa,cAAe;AACzC,cAAQ,KAAK,0EAA0E;AAAA,IAC3F;AACA;AAAA,EACJ;AACA,QAAM,WAAW,OAAO,SAAS,WAAW,OAAO;AAC7C,QAAA,WAAW,UAAU,QAAQ;AAE/B,MAAA,EAAE,YAAY,GAAG,QAAQ;AACzB;AAAA,EACJ;AACA,QAAM,OAAO,CAAY,aAAA;AACrB,QAAI,QAAQ,UAAU,qBAAqB,IAAI,QAAQ,CAAC,GAAG;AACvD;AAAA,IACJ;AACG,OAAA,KAAK,UAAU,QAAQ;AAAA,EAAA,CAC7B;AACD,QAAM,MAAM,qBAAqB,IAAI,QAAQ,GAAG,CAAa,cAAA;AACzD,QAAI,cAAc,aAAa,MAAM,UAAU,QAAW;AACtD;AAAA,IACJ;AACM,UAAA,WAAW,cAAc,YAAY,SAAY;AACvD,QAAI,QAAQ,UAAU,MAAM,KAAK,GAAG;AAChC;AAAA,IACJ;AACa,iBAAA,UAAU,gBAAgB;AAAA,EAAA,CAC1C;AACL;AACA,SAAS,qBAAqB,IAAI,UAAU;AACxC,MAAI,CAAC,IAAI;AACE,WAAA;AAAA,EACX;AACO,SAAA,GAAG,MAAM,QAAQ;AAC5B;AAEA,MAAM,YAA6C,gCAAA;AAAA,EAC/C,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACH,IAAI;AAAA,MACA,MAAM,CAAC,QAAQ,MAAM;AAAA,MACrB,SAAS;AAAA,IACb;AAAA,IACA,MAAM;AAAA,MACF,MAAM;AAAA,MACN,UAAU;AAAA,IACd;AAAA,IACA,OAAO;AAAA,MACH,MAAM,CAAC,QAAQ,QAAQ,QAAQ;AAAA,MAC/B,SAAS;AAAA,IACb;AAAA,IACA,iBAAiB;AAAA,MACb,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,gBAAgB;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,kBAAkB;AAAA,MACd,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,iBAAiB;AAAA,MACb,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,uBAAuB;AAAA,MACnB,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,OAAO;AAAA,MACH,MAAM;AAAA,MACN,SAAS,MAAM,UAAA,EAAY;AAAA,IAC/B;AAAA,IACA,OAAO;AAAA,MACH,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,gBAAgB;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,YAAY;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,gBAAgB;AAAA,MACZ,MAAM;AAAA,MACN,SAAS,OAAO,CAAA;AAAA,IACpB;AAAA,IACA,uBAAuB;AAAA,MACnB,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,YAAY;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,WAAW;AAAA,MACP,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,EACJ;AAAA,EACA,MAAM,OAAO,KAAK;AACR,UAAA,QAAQ,MAAM,OAAO,OAAO;AAC5B,UAAA,OAAO,MAAM,OAAO,MAAM;AAC1B,UAAA,QAAQ,MAAM,OAAO,OAAO;AAC5B,UAAA,iBAAiB,MAAM,OAAO,gBAAgB;AAC9C,UAAA,YAAY,MAAM,OAAO,WAAW;AAC1C,UAAM,EAAE,QAAQ,OAAO,cAAc,UAAU,eAAe,cAAc,YAAY,YAAY,YAAY,aAAa,MAAM,SAAS,cAAe,SAAS,MAAM,OAAO;AAAA,MAC7K,iBAAiB,MAAM;AAAA,MACvB,OAAO,MAAM;AAAA,MACb,YAAY,MAAM;AAAA,MAClB,MAAM,IAAI,MAAM;AAAA,MAChB,cAAc,oBAAoB,OAAO,GAAG;AAAA;AAAA,MAE5C,cAAc,IAAI,MAAM;AAAA,MACxB;AAAA,MACA;AAAA,MACA,uBAAuB,MAAM;AAAA,MAC7B,oBAAoB;AAAA,MACpB,YAAY;AAAA,IAAA,CACf;AAED,UAAM,kBAAkB,SAAS,sBAAsB,GAAG,iBAAiB,MAAM;AAC7E,mBAAa,GAAG,cAAc;AAAA,IAAA;AAE5B,UAAA,cAAc,SAAS,MAAM;AAC/B,YAAM,EAAE,iBAAiB,kBAAkB,gBAAgB,0BAA0B,0BAA0B,KAAK;AACpH,eAAS,WAAW,GAAG;AACnB,mBAAW,GAAG,cAAc;AAC5B,YAAI,WAAW,IAAI,MAAM,MAAM,GAAG;AAC1B,cAAA,MAAM,OAAO,CAAC;AAAA,QACtB;AAAA,MACJ;AACA,eAAS,YAAY,GAAG;AACpB,wBAAgB,GAAG,eAAe;AAClC,YAAI,WAAW,IAAI,MAAM,OAAO,GAAG;AAC3B,cAAA,MAAM,QAAQ,CAAC;AAAA,QACvB;AAAA,MACJ;AACA,eAAS,aAAa,GAAG;AACrB,wBAAgB,GAAG,gBAAgB;AACnC,YAAI,WAAW,IAAI,MAAM,QAAQ,GAAG;AAC5B,cAAA,MAAM,SAAS,CAAC;AAAA,QACxB;AAAA,MACJ;AACA,YAAM,QAAQ;AAAA,QACV,MAAM,MAAM;AAAA,QACZ,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,UAAU;AAAA,MAAA;AAEd,YAAM,qBAAqB,IAAI,CAAK,MAAA,gBAAgB,GAAG,qBAAqB;AACrE,aAAA;AAAA,IAAA,CACV;AACK,UAAA,aAAa,SAAS,MAAM;AAC9B,YAAM,QAAQ,OAAO,OAAO,CAAA,GAAI,YAAY,KAAK;AACjD,UAAI,eAAe,IAAI,MAAM,IAAI,KAAK,SAAS;AAC3C,cAAM,UAAU,QAAQ;AAAA,MAC5B;AACM,YAAA,MAAM,WAAW,OAAO,GAAG;AACjC,UAAI,uBAAuB,KAAK,IAAI,KAAK,GAAG;AACxC,cAAM,QAAQ,MAAM;AAAA,MACxB;AACO,aAAA;AAAA,IAAA,CACV;AACK,UAAA,iBAAiB,SAAS,MAAM;AAClC,aAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,YAAY,KAAK,GAAG,EAAE,YAAY,MAAM,MAAO,CAAA;AAAA,IAAA,CACzF;AACD,aAAS,YAAY;AACV,aAAA;AAAA,QACH,OAAO,WAAW;AAAA,QAClB,gBAAgB,eAAe;AAAA,QAC/B,OAAO,MAAM;AAAA,QACb;AAAA,QACA,QAAQ,OAAO;AAAA,QACf,cAAc,aAAa;AAAA,QAC3B,UAAU;AAAA,QACV;AAAA,QACA,cAAc;AAAA,QACd,aAAa,CAAA,MAAK,gBAAgB,GAAG,KAAK;AAAA,QAC1C;AAAA,QACA,YAAY,YAAY,MAAM;AAAA,QAC9B;AAAA,QACA;AAAA,MAAA;AAAA,IAER;AACA,QAAI,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO;AAAA,MACP,UAAU;AAAA,MACV;AAAA,IAAA,CACH;AACD,WAAO,MAAM;AACT,YAAM,MAAM,wBAAwB,WAAW,OAAO,GAAG,CAAC;AAC1D,YAAM,WAAW,kBAAkB,KAAK,KAAK,SAAS;AACtD,UAAI,KAAK;AACL,eAAO,EAAE,KAAK,OAAO,OAAO,OAAO,OAAO,CAAI,GAAA,IAAI,KAAK,GAAG,WAAW,KAAK,GAAG,QAAQ;AAAA,MACzF;AACO,aAAA;AAAA,IAAA;AAAA,EAEf;AACJ,CAAC;AACD,SAAS,WAAW,OAAO,KAAK;AACxB,MAAA,MAAM,MAAM,MAAM;AACtB,MAAI,CAAC,MAAM,MAAM,CAAC,IAAI,MAAM,SAAS;AAC3B,UAAA;AAAA,EACV;AACO,SAAA;AACX;AACA,SAAS,0BAA0B,OAAO;AAClC,MAAA,IAAI,IAAI,IAAI;AAChB,QAAM,EAAE,iBAAiB,kBAAkB,gBAAgB,sBAAA,IAA0B;AAC9E,SAAA;AAAA,IACH,kBAAkB,KAAK,MAAM,qBAAqB,QAAQ,OAAO,SAAS,KAAK;AAAA,IAC/E,mBAAmB,KAAK,MAAM,sBAAsB,QAAQ,OAAO,SAAS,KAAK;AAAA,IACjF,iBAAiB,KAAK,MAAM,oBAAoB,QAAQ,OAAO,SAAS,KAAK;AAAA,IAC7E,wBAAwB,KAAK,MAAM,2BAA2B,QAAQ,OAAO,SAAS,KAAK;AAAA,EAAA;AAEnG;AACA,SAAS,oBAAoB,OAAO,KAAK;AAGrC,MAAI,CAAC,eAAe,IAAI,MAAM,IAAI,GAAG;AACjC,WAAO,cAAc,OAAO,YAAY,IAAI,MAAM,aAAa,IAAI,MAAM;AAAA,EAC7E;AACA,SAAO,cAAc,OAAO,YAAY,IAAI,MAAM,aAAa;AACnE;AACA,MAAM,QAAQ;AAEd,IAAI,eAAe;AACnB,MAAM,0BAA0B,CAAC,SAAS,eAAe,MAAM,YAAY,QAAQ,UAAU;AAC7F,SAAS,qBAAqB,MAAM;AAChC,QAAM,iBAAiB,OAAO,OAAO,CAAA,GAAI,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,kBAAkB,CAAE,CAAA,CAAC;AAClH,QAAA,SAAS,MAAM,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,gBAAgB;AACtF,MAAI,UAAU,cAAc,MAAM,KAAK,WAAW,OAAO,IAAI,GAAG;AAC5D,WAAO,MAAM,OAAO,KAAK,cAAc,KAAK,CAAE,CAAA;AAAA,EAClD;AACA,SAAO,MAAM,cAAc;AAC/B;AACA,SAAS,QAAQ,MAAM;AACf,MAAA;AACJ,QAAM,SAAS;AAEf,MAAI,mBAAmB;AAEjB,QAAA,eAAe,IAAI,KAAK;AAExB,QAAA,eAAe,IAAI,KAAK;AAExB,QAAA,cAAc,IAAI,CAAC;AAEzB,QAAM,cAAc,CAAA;AAEpB,QAAM,aAAa,SAAS,qBAAqB,IAAI,CAAC;AAChD,QAAA,aAAa,IAAI,CAAA,CAAE;AACnB,QAAA,iBAAiB,IAAI,CAAA,CAAE;AACvB,QAAA,kBAAkB,IAAI,CAAA,CAAE;AACxB,QAAA,oBAAoB,iBAAiB,MAAM;AAC7C,oBAAgB,QAAQ,WAAW,MAAM,OAAO,CAAC,OAAO,UAAU;AAC9D,YAAM,kBAAkB,QAAQ,MAAM,IAAI,CAAC,CAAC,IAAI;AACzC,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EAAA,CACR;AAIQ,WAAA,cAAc,OAAO,SAAS;AAC7B,UAAA,QAAQ,cAAc,KAAK;AACjC,QAAI,CAAC,OAAO;AACJ,UAAA,OAAO,UAAU,UAAU;AAC3B,uBAAe,MAAM,kBAAkB,KAAK,CAAC,IAAI,mBAAmB,OAAO;AAAA,MAC/E;AACA;AAAA,IACJ;AAEI,QAAA,OAAO,UAAU,UAAU;AACrB,YAAA,iBAAiB,kBAAkB,KAAK;AAC1C,UAAA,eAAe,MAAM,cAAc,GAAG;AAC/B,eAAA,eAAe,MAAM,cAAc;AAAA,MAC9C;AAAA,IACJ;AACM,UAAA,SAAS,mBAAmB,OAAO;AACnC,UAAA,QAAQ,CAAC,MAAM,OAAO;AAAA,EAChC;AAIA,WAAS,UAAU,OAAO;AACf,WAAA,KAAK,EAAE,QAAQ,CAAQ,SAAA;AACZ,oBAAA,MAAM,MAAM,IAAI,CAAC;AAAA,IAAA,CAClC;AAAA,EACL;AACA,MAAI,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,eAAe;AAChE,cAAU,KAAK,aAAa;AAAA,EAChC;AACM,QAAA,WAAW,SAAS,MAAM;AAC5B,UAAM,aAAa,WAAW,MAAM,OAAO,CAAC,KAAK,UAAU;AACnD,UAAA,MAAM,OAAO,QAAQ;AACjB,YAAA,MAAM,IAAI,IAAI,MAAM;AAAA,MAC5B;AACO,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AACE,WAAA,OAAO,OAAO,OAAO,OAAO,CAAI,GAAA,eAAe,KAAK,GAAG,UAAU;AAAA,EAAA,CAC3E;AAEK,QAAA,SAAS,SAAS,MAAM;AAC1B,WAAO,OAAO,SAAS,KAAK,EAAE,OAAO,CAAC,KAAK,QAAQ;AACzCJ,YAAAA,UAAS,SAAS,MAAM,GAAG;AACjC,UAAIA,YAAW,QAAQA,YAAW,SAAS,SAASA,QAAO,QAAQ;AAC3D,YAAA,GAAG,IAAIA,QAAO,CAAC;AAAA,MACvB;AACO,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EAAA,CACR;AAIK,QAAA,aAAa,SAAS,MAAM;AAC9B,WAAO,WAAW,MAAM,OAAO,CAAC,OAAO,UAAU;AACvC,YAAA,MAAM,IAAI,IAAI,EAAE,MAAM,MAAM,QAAQ,IAAI,OAAO,MAAM,SAAS,GAAG;AAChE,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EAAA,CACR;AACK,QAAA,gBAAgB,SAAS,MAAM;AACjC,WAAO,WAAW,MAAM,OAAO,CAAC,KAAK,UAAU;AACvCnC,UAAAA;AACA,UAAA,MAAM,IAAI,KAAKA,MAAK,MAAM,WAAW,QAAQA,QAAO,SAASA,MAAK;AAC/D,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EAAA,CACR;AAGD,QAAM,gBAAgB,OAAO,OAAO,CAAA,IAAM,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,kBAAkB,CAAG,CAAA;AAChH,QAAM,uBAAuB,KAAK,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,yBAAyB,QAAQ,OAAO,SAAS,KAAK;AAEnI,QAAA,EAAE,eAAe,uBAAuB,iBAAA,IAAqB,qBAAqB,YAAY,YAAY,IAAI;AAEpH,QAAM,OAAO,YAAY,YAAY,YAAY,uBAAuB,MAAM;AACxE,QAAA,mBAAmB,SAAS,MAAM;AACpC,WAAO,WAAW,MAAM,OAAO,CAAC,KAAK,UAAU;AAC3C,YAAM,QAAQ,YAAY,YAAY,MAAM,IAAI;AACtC,gBAAA,KAAK,MAAM,MAAM,KAAK;AACzB,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EAAA,CACR;AACD,QAAM,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK;AACvD,WAAA,gBAAgB,MAAM,QAAQ;AACnC,QAAIA,KAAI;AACF,UAAA,eAAe,SAAS,MAAM,YAAY,cAAc,OAAO,QAAQ,IAAI,CAAC,CAAC;AACnF,UAAM,kBAAkB,gBAAgB,MAAM,QAAQ,IAAI,CAAC;AAC3D,UAAM,qBAAqB,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,UAAU,eAAe,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,UAAU;AAC5K,QAAI,mBAAmB,mBAAmB;AACtC,sBAAgB,WAAW;AAC3B,YAAM2C,MAAK;AACX,UAAI,MAAM,QAAQ,gBAAgB,EAAE,GAAG;AACnB,wBAAA,GAAG,KAAKA,GAAE;AAAA,MAAA,OAEzB;AACD,wBAAgB,KAAK,CAAC,gBAAgB,IAAIA,GAAE;AAAA,MAChD;AACgB,sBAAA;AACA,sBAAA,QAAQ,eAAeA,GAAE,IAAI;AACtC,aAAA;AAAA,IACX;AACM,UAAA,eAAe,SAAS,MAAM,YAAY,YAAY,QAAQ,IAAI,CAAC,CAAC;AACpE,UAAA,YAAY,QAAQ,IAAI;AAC9B,UAAM,kBAAkB,YAAY,UAAU,CAAA,UAAS,UAAU,SAAS;AAC1E,QAAI,oBAAoB,IAAI;AACZ,kBAAA,OAAO,iBAAiB,CAAC;AAAA,IACzC;AACM,UAAA,aAAa,SAAS,MAAM;AAC9B,UAAI3C,KAAI6B,KAAI,IAAI,IAAI,IAAI;AACpB,UAAA,cAAc,MAAM,GAAG;AACf,gBAAA,MAAMA,OAAM7B,MAAK,QAAQ,cAAc,QAAQ6B,QAAO,SAAS,SAASA,IAAG,KAAK7B,KAAI,QAAQ,IAAI,CAAC,EAAE,cAAc,QAAQ,OAAO,SAAS,KAAK;AAAA,MAC1J;AAEI,UAAA,cAAc,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,MAAM,GAAG;AACtE,gBAAA,MAAM,MAAM,KAAM,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,QAAS,cAAc,QAAQ,OAAO,SAAS,SAAS,GAAG,KAAK,EAAE,EAAE,cAAc,QAAQ,OAAO,SAAS,KAAK;AAAA,MACpM;AACO,aAAA;AAAA,IAAA,CACV;AACD,UAAM,KAAK;AACX,UAAM,QAAQ,SAAS;AAAA,MACnB;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT,SAAS;AAAA,MACT,OAAO;AAAA,MACP,WAAW,CAAC,GAAGA,MAAK,cAAc,SAAS,OAAO,QAAQA,QAAO,SAAS,SAASA,IAAG;AAAA,MACtF,UAAU;AAAA,MACV;AAAA,MACA,QAAQ,WAAW,EAAE;AAAA,MACrB,QAAQ,KAAK,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,WAAW,QAAQ,OAAO,SAAS,KAAK;AAAA,MAC5G,OAAO,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO;AAAA,MAC9D,OAAO,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,SAAS;AAAA,MACvE,OAAO;AAAA,MACP,UAAU;AAAA,MACV,SAAS;AAAA,QACL,gBAAgB,EAAE,CAAC,EAAE,GAAG,MAAM;AAAA,QAC9B,cAAc;AAAA,MAClB;AAAA,MACA,aAAa;AAAA,MACb,UAAU,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO;AAAA,MACjE,OAAO,SAAS,MAAM;AAClB,eAAO,CAAC,QAAQ,MAAM,YAAY,GAAG,MAAM,YAAY,CAAC;AAAA,MAAA,CAC3D;AAAA,IAAA,CACJ;AACU,eAAA,MAAM,KAAK,KAAK;AACX,oBAAA,MAAM,SAAS,IAAI;AACjB;AAClB,QAAI,OAAO,MAAM,SAAS,KAAK,CAAC,cAAc,SAAS,GAAG;AACtD,eAAS,MAAM;AACX,sBAAc,WAAW,EAAE,MAAM,SAAU,CAAA;AAAA,MAAA,CAC9C;AAAA,IACL;AAEI,QAAA,MAAM,IAAI,GAAG;AACb,YAAM,MAAM,CAAW,YAAA;AACD;AACZ,cAAA,YAAY,MAAM,aAAa,KAAK;AAC1B,wBAAA,MAAM,OAAO,IAAI;AACjC,iBAAS,MAAM;AACD,oBAAA,YAAY,SAAS,SAAS;AAAA,QAAA,CAC3C;AAAA,MAAA,CACJ;AAAA,IACL;AACO,WAAA;AAAA,EACX;AAKM,QAAA,4BAA4B,cAAc,iBAAiB,CAAC;AAC5D,QAAA,sBAAsB,cAAc,iBAAiB,CAAC;AACtD,QAAA,iBAAiB,WAAW,OAAO,SAAS;AAC9C,WAAQ,OAAO,SAAS,WAClB,0BAAA,IACA,oBAAoB;AAAA,EAAA,GAC3B,CAAC,YAAY,CAAC,IAAI,MAAM;AAGvB,UAAM,qBAAqB,OAAO,QAAQ,SAAS,KAAK;AAGxD,UAAM,QAAQ;AAAA,MACV,GAAO,oBAAA,IAAI,CAAC,GAAG,OAAO,WAAW,OAAO,GAAG,GAAG,WAAW,MAAM,IAAI,CAAK,MAAA,EAAE,IAAI,GAAG,GAAG,kBAAkB,CAAC;AAAA,MACzG,KAAK;AAEP,UAAM,UAAU,MAAM,OAAO,CAAC,YAAY,UAAU;AAC5CA,UAAAA;AACJ,YAAM,eAAe;AACrB,YAAM,YAAY,cAAc,YAAY,KAAK,gBAAgB,YAAY;AAC7E,YAAM,aAAaA,MAAK,WAAW,QAAQ,YAAY,OAAO,QAAQA,QAAO,SAAS,SAASA,IAAG,WAAW;AAEvG,YAAA,OAAQ,QAAQ,cAAc,QAAQ,cAAc,SAAS,SAAS,UAAU,IAAI,KAAK;AAG/F,YAAM,cAAc,uBAAuB,EAAE,QAAQ,UAAU,OAAO,CAAC,SAAS,OAAO,GAAG,WAAW,QAAQ,IAAI,CAAC;AACvG,iBAAA,QAAQ,IAAI,IAAI;AACvB,UAAA,CAAC,YAAY,OAAO;AACpB,mBAAW,OAAO,IAAI,IAAI,YAAY,OAAO,CAAC;AAAA,MAClD;AAEA,UAAI,aAAa,eAAe,MAAM,IAAI,GAAG;AAClC,eAAA,eAAe,MAAM,IAAI;AAAA,MACpC;AAEA,UAAI,CAAC,WAAW;AACZ,sBAAc,MAAM,QAAQ;AACrB,eAAA;AAAA,MACX;AAEA,gBAAU,QAAQ,YAAY;AAC9B,UAAI,SAAS,UAAU;AACZ,eAAA;AAAA,MACX;AACA,UAAI,SAAS,oBAAoB,CAAC,UAAU,WAAW;AAC5C,eAAA;AAAA,MACX;AACc,oBAAA,WAAW,YAAY,MAAM;AACpC,aAAA;AAAA,IAAA,GACR,EAAE,OAAO,WAAW,OAAO,SAAS,IAAI,QAAQ,CAAC,EAAA,CAAG;AACvD,QAAI,WAAW,QAAQ;AACnB,cAAQ,SAAS,WAAW;AAAA,IAChC;AACA,WAAO,QAAQ,OAAO,EAAE,QAAQ,CAAQ,SAAA;AAChCA,UAAAA;AACE,YAAA,YAAY,cAAc,IAAI;AACpC,UAAI,CAAC,WAAW;AACZ;AAAA,MACJ;AACA,UAAI,SAAS,UAAU;AACnB;AAAA,MACJ;AACA,UAAI,SAAS,oBAAoB,CAAC,UAAU,WAAW;AACnD;AAAA,MACJ;AACc,oBAAA,YAAYA,MAAK,QAAQ,QAAQ,IAAI,OAAO,QAAQA,QAAO,SAAS,SAASA,IAAG,MAAM;AAAA,IAAA,CACvG;AACM,WAAA;AAAA,EAAA,CACV;AACD,WAAS,mBAAmB,UAAU;AACvB,eAAA,MAAM,QAAQ,QAAQ;AAAA,EACrC;AACA,WAAS,cAAc,MAAM;AACzB,UAAM,iBAAiB,OAAO,SAAS,WAAW,kBAAkB,IAAI,IAAI;AAC5E,UAAM,YAAY,OAAO,mBAAmB,WAAW,gBAAgB,MAAM,cAAc,IAAI;AACxF,WAAA;AAAA,EACX;AACA,WAAS,gBAAgB,MAAM;AACrB,UAAA,aAAa,WAAW,MAAM,OAAO,WAAS,KAAK,WAAW,MAAM,IAAI,CAAC;AAC/E,WAAO,WAAW,OAAO,CAAC,eAAe,cAAc;AACnD,UAAI,CAAC,eAAe;AACT,eAAA;AAAA,MACX;AACA,aAAQ,UAAU,KAAK,SAAS,cAAc,KAAK,SAAS,YAAY;AAAA,IAAA,GACzE,MAAS;AAAA,EAChB;AACA,MAAI,cAAc,CAAA;AACd,MAAA;AACJ,WAAS,eAAe,MAAM;AAC1B,gBAAY,KAAK,IAAI;AACrB,QAAI,CAAC,eAAe;AAChB,sBAAgB,SAAS,MAAM;AAC3B,cAAM,cAAc,CAAC,GAAG,WAAW,EAAE,KAAA,EAAO;AAC5C,oBAAY,QAAQ,CAAK,MAAA;AACrB,oBAAU,YAAY,CAAC;AAAA,QAAA,CAC1B;AACD,sBAAc,CAAA;AACE,wBAAA;AAAA,MAAA,CACnB;AAAA,IACL;AACO,WAAA;AAAA,EACX;AACA,WAAS,sBAAsB,gBAAgB;AACpC,WAAA,SAAS,qBAAqB,IAAI,mBAAmB;AACjD,aAAA,SAAS,kBAAkB,GAAG;AACjC,YAAI,aAAa,OAAO;AACpB,YAAE,eAAe;AACjB,YAAE,gBAAgB;AAAA,QACtB;AAEmB,2BAAA,CAAA,MAAM,EAAE,UAAU,IAAK;AAC1C,qBAAa,QAAQ;AACT,oBAAA;AACL2B,eAAAA,UACF,EAAA,KAAK,CAAU,WAAA;AACV,gBAAA,SAAS,MAAM,UAAU;AAC/B,cAAI,OAAO,SAAS,OAAO,OAAO,YAAY;AACpC,kBAAA,aAAa,MAAM,iBAAiB,KAAK;AAC3C,gBAAA,kBAAmB,iBAAiB,aAAa;AACrD,gBAAI,OAAO,QAAQ;AACf,gCAAkB,OAAO;AAAA,YAC7B;AACA,mBAAO,GAAG,iBAAiB;AAAA,cACvB,KAAK;AAAA,cACL,kBAAkB;AAAA,cAClB;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,cACA;AAAA,YAAA,CACH;AAAA,UACL;AACA,cAAI,CAAC,OAAO,SAAS,OAAO,sBAAsB,YAAY;AACxC,8BAAA;AAAA,cACd;AAAA,cACA,KAAK;AAAA,cACL,QAAQ,OAAO;AAAA,cACf,SAAS,OAAO;AAAA,YAAA,CACnB;AAAA,UACL;AAAA,QAAA,CACH,EACI,KAAK,CAAa,cAAA;AACnB,uBAAa,QAAQ;AACd,iBAAA;AAAA,WACR,CAAO,QAAA;AACN,uBAAa,QAAQ;AAEf,gBAAA;AAAA,QAAA,CACT;AAAA,MAAA;AAAA,IACL;AAAA,EAER;AACM,QAAA,mBAAmB,sBAAsB,KAAK;AACpD,QAAM,eAAe;AACR,eAAA,iBAAiB,sBAAsB,IAAI;AAC/C,WAAA,gBAAgB,MAAM,IAAI;AAC/B,UAAM,MAAM,WAAW,MAAM,UAAU,CAAK,MAAA;AACxC,aAAO,EAAE,SAAS,SAAS,MAAM,QAAQ,EAAE,EAAE,IAAI,EAAE,GAAG,SAAS,EAAE,IAAI,EAAE,OAAO;AAAA,IAAA,CACjF;AACK,UAAA,YAAY,WAAW,MAAM,GAAG;AAClC,QAAA,QAAQ,MAAM,CAAC,WAAW;AAC1B;AAAA,IACJ;AACA,aAAS,MAAM;AACX,oBAAc,MAAM,EAAE,MAAM,UAAU,MAAM,OAAO;AAAA,IAAA,CACtD;AACG,QAAA,UAAU,YAAY,UAAU,aAAa;AACnC,gBAAA;AAAA,IACd;AACA,QAAI,MAAM,QAAQ,UAAU,EAAE,GAAG;AAC7B,YAAM,UAAU,UAAU,GAAG,QAAQ,EAAE;AACvC,UAAI,WAAW,GAAG;AACJ,kBAAA,GAAG,OAAO,SAAS,CAAC;AAAA,MAClC;AACO,aAAA,UAAU,QAAQ,eAAe,EAAE;AAAA,IAC9C;AACA,QAAI,CAAC,UAAU,YAAY,UAAU,eAAe,GAAG;AACxC,iBAAA,MAAM,OAAO,KAAK,CAAC;AAC9B,wBAAkB,IAAI;AACJ;AACX,aAAA,gBAAgB,MAAM,IAAI;AAAA,IACrC;AAAA,EACJ;AACA,WAAS,YAAY,MAAM;AACvB,WAAO,gBAAgB,KAAK,EAAE,QAAQ,CAAO,QAAA;AACrC,UAAA,IAAI,WAAW,IAAI,GAAG;AACf,eAAA,gBAAgB,MAAM,GAAG;AAAA,MACpC;AAAA,IAAA,CACH;AACU,eAAA,QAAQ,WAAW,MAAM,OAAO,CAAA,MAAK,CAAC,EAAE,KAAK,WAAW,IAAI,CAAC;AACxE,aAAS,MAAM;AACO;IAAA,CACrB;AAAA,EACL;AACA,QAAM,UAAU;AAAA,IACZ;AAAA,IACA,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,gBAAgB,MAAM,MAAM,IAAI,iBAAiB;AAAA,IACjD,UAAAA;AAAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB,MAAM,WAAW;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAKJ,WAAS,cAAc,OAAO,OAAO,iBAAiB,MAAM;AAClD,UAAA,cAAc,MAAM,KAAK;AAC/B,UAAM,OAAO,OAAO,UAAU,WAAW,QAAQ,MAAM;AACjD,UAAA,YAAY,cAAc,IAAI;AACpC,QAAI,CAAC,WAAW;AACZ,sBAAgB,IAAI;AAAA,IACxB;AACU,cAAA,YAAY,MAAM,WAAW;AACvC,QAAI,gBAAgB;AAChB,oBAAc,IAAI;AAAA,IACtB;AAAA,EACJ;AACS,WAAA,eAAe,QAAQ,iBAAiB,MAAM;AAE5C,WAAA,UAAU,EAAE,QAAQ,CAAO,QAAA;AAC9B,aAAO,WAAW,GAAG;AAAA,IAAA,CACxB;AAEM,WAAA,MAAM,EAAE,QAAQ,CAAQ,SAAA;AAC3B,oBAAc,MAAM,OAAO,IAAI,GAAG,KAAK;AAAA,IAAA,CAC1C;AACD,QAAI,gBAAgB;AAChBA;IACJ;AAAA,EACJ;AAIS,WAAA,UAAU,QAAQ,iBAAiB,MAAM;AAC9C,UAAM,YAAY,MAAM;AAExB,gBAAY,QAAQ,CAAA,MAAK,KAAK,EAAE,OAAO;AACvC,QAAI,gBAAgB;AAChBA;IACJ;AAAA,EACJ;AACS,WAAA,YAAY,MAAM,gBAAgB;AACvC,UAAM,YAAY,cAAc,QAAQ,IAAI,CAAC,KAAK,gBAAgB,IAAI;AACtE,WAAO,SAAS;AAAA,MACZ,MAAM;AACF,eAAO,UAAU;AAAA,MACrB;AAAA,MACA,IAAI,OAAO;AACH3B,YAAAA;AACE,cAAA,YAAY,QAAQ,IAAI;AAChB,sBAAA,WAAW,QAAQA,MAAK,QAAQ,cAAc,OAAO,QAAQA,QAAO,SAASA,MAAK,KAAK;AAAA,MACzG;AAAA,IAAA,CACH;AAAA,EACL;AAIS,WAAA,gBAAgB,OAAO,WAAW;AACjC,UAAA,YAAY,cAAc,KAAK;AACrC,QAAI,WAAW;AACX,gBAAU,UAAU;AAAA,IACxB;AAAA,EACJ;AACA,WAAS,eAAe,OAAO;AACrB,UAAA,YAAY,cAAc,KAAK;AACrC,QAAI,WAAW;AACX,aAAO,UAAU;AAAA,IACrB;AAEA,WAAO,WAAW,MAAM,OAAO,CAAA,MAAK,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,KAAK,CAAA,MAAK,EAAE,OAAO;AAAA,EACrF;AACA,WAAS,aAAa,OAAO;AACnB,UAAA,YAAY,cAAc,KAAK;AACrC,QAAI,WAAW;AACX,aAAO,UAAU;AAAA,IACrB;AACA,WAAO,WAAW,MAAM,OAAO,CAAA,MAAK,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,KAAK,CAAA,MAAK,EAAE,KAAK;AAAA,EACnF;AACA,WAAS,aAAa,OAAO;AACnB,UAAA,YAAY,cAAc,KAAK;AACrC,QAAI,WAAW;AACX,aAAO,UAAU;AAAA,IACrB;AACA,WAAO,WAAW,MAAM,OAAO,CAAA,MAAK,EAAE,KAAK,WAAW,KAAK,CAAC,EAAE,MAAM,CAAA,MAAK,EAAE,KAAK;AAAA,EACpF;AAIA,WAAS,WAAW,QAAQ;AACpB,QAAA,OAAO,WAAW,WAAW;AAC7B,yBAAmB,CAAS,UAAA;AACxB,cAAM,UAAU;AAAA,MAAA,CACnB;AACD;AAAA,IACJ;AACO,WAAA,MAAM,EAAE,QAAQ,CAAS,UAAA;AAC5B,sBAAgB,OAAO,CAAC,CAAC,OAAO,KAAK,CAAC;AAAA,IAAA,CACzC;AAAA,EACL;AACS,WAAA,WAAW,OAAO,OAAO;AAC1BA,QAAAA;AACE,UAAA,WAAW,SAAS,WAAW,QAAQ,MAAM,QAAQ,YAAY,cAAc,OAAO,KAAK;AAC3F,UAAA,YAAY,cAAc,KAAK;AACrC,QAAI,WAAW;AACX,gBAAU,QAAQ,eAAe;AAAA,IACrC;AACA,yBAAqB,OAAO,MAAM,QAAQ,GAAG,IAAI;AACnC,kBAAA,OAAO,UAAU,KAAK;AACpC,oBAAgB,QAAQA,MAAK,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,aAAa,QAAQA,QAAO,SAASA,MAAK,KAAK;AAClH,kBAAA,QAAQ,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,WAAW,CAAE,CAAA;AACvF,aAAS,MAAM;AACX,UAAI,WAAW;AACX,kBAAU,QAAQ,eAAe;AAAA,MACrC;AAAA,IAAA,CACH;AAAA,EACL;AAIS,WAAA,UAAU,YAAY0C,OAAM;AACjC,QAAI,YAAY,OAAO,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,UAAU,WAAW,SAAS,sBAAsB,KAAK;AACtIA,iBAAAA,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,SAAS,YAAY,MAAM,sBAAsB,OAAO,SAAS;AACnH,gBAAA,cAAc,MAAM,KAAK,WAAW,OAAO,IAAI,IAAI,OAAO,KAAK,SAAS,IAAI;AACxF,qBAAiB,SAAS;AAC1B,uBAAmB,CAAS,UAAA;AACpB1C,UAAAA;AACJ,YAAM,QAAQ,eAAe;AAC7B,YAAM,YAAY;AAClB,YAAM,YAAYA,MAAK,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,aAAa,QAAQA,QAAO,SAAS,SAASA,IAAG,MAAM,IAAI,MAAM;AAC3J,oBAAc,MAAM,MAAM,YAAY,WAAW,MAAM,IAAI,GAAG,KAAK;AACrD,oBAAA,MAAM,MAAM,MAAS;AAAA,IAAA,CACtC;AACD,KAAC0C,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,SAAS,eAAe,WAAW,KAAK,IAAI,UAAU,WAAW,KAAK;AAC7G,eAAA,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,WAAW,CAAE,CAAA;AAC3F,gBAAY,SAAS,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,gBAAgB;AACxG,aAAS,MAAM;AACXf,gBAAS,EAAE,MAAM,SAAA,CAAU;AAC3B,yBAAmB,CAAS,UAAA;AACxB,cAAM,QAAQ,eAAe;AAAA,MAAA,CAChC;AAAA,IAAA,CACJ;AAAA,EACL;AACA,iBAAeA,UAASe,OAAM;AAC1B,UAAM,QAAQA,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,SAAS;AACxE,QAAI,SAAS,SAAS;AACC,yBAAA,CAAA,MAAM,EAAE,YAAY,IAAK;AAAA,IAChD;AACA,QAAI,QAAQ,gBAAgB;AACjB,aAAA,QAAQ,eAAe,IAAI;AAAA,IACtC;AACA,iBAAa,QAAQ;AAErB,UAAM,cAAc,MAAM,QAAQ,IAAI,WAAW,MAAM,IAAI,CAAS,UAAA;AAC5D,UAAA,CAAC,MAAM,UAAU;AACjB,eAAO,QAAQ,QAAQ;AAAA,UACnB,KAAK,MAAM;AAAA,UACX,OAAO;AAAA,UACP,QAAQ,CAAC;AAAA,QAAA,CACZ;AAAA,MACL;AACA,aAAO,MAAM,SAASA,KAAI,EAAE,KAAK,CAAC,WAAW;AAClC,eAAA;AAAA,UACH,KAAK,MAAM;AAAA,UACX,OAAO,OAAO;AAAA,UACd,QAAQ,OAAO;AAAA,QAAA;AAAA,MACnB,CACH;AAAA,IACJ,CAAA,CAAC;AACF,iBAAa,QAAQ;AACrB,UAAM,UAAU,CAAA;AAChB,UAAMP,UAAS,CAAA;AACf,eAAW,cAAc,aAAa;AAC1B,cAAA,WAAW,GAAG,IAAI;AAAA,QACtB,OAAO,WAAW;AAAA,QAClB,QAAQ,WAAW;AAAA,MAAA;AAEnB,UAAA,WAAW,OAAO,QAAQ;AAC1BA,gBAAO,WAAW,GAAG,IAAI,WAAW,OAAO,CAAC;AAAA,MAChD;AAAA,IACJ;AACO,WAAA;AAAA,MACH,OAAO,YAAY,MAAM,CAAA,MAAK,EAAE,KAAK;AAAA,MACrC;AAAA,MACA,QAAAA;AAAAA,IAAA;AAAA,EAER;AACe,iBAAA,cAAc,MAAMO,OAAM;AACjC1C,QAAAA;AACE,UAAA,QAAQ,cAAc,IAAI;AAC5B,QAAA,UAAU0C,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,UAAU,UAAU;AAC/E,YAAM,YAAY;AAAA,IACtB;AACA,QAAI,QAAQ;AACR,YAAM,EAAE,QAAY,IAAA,MAAM,gBAAgBA,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,SAAS,gBAAgB;AAC7G,aAAA,QAAQ,IAAI,KAAK,EAAE,QAAQ,IAAI,OAAO;IACjD;AACA,QAAI,UAAU,QAAQ,UAAU,SAAS,SAAS,MAAM,UAAU;AACvD,aAAA,MAAM,SAASA,KAAI;AAAA,IAC9B;AACA,UAAM,aAAa,CAAC,WAAW1C,MAAK0C,UAAS,QAAQA,UAAS,SAAS,SAASA,MAAK,UAAU,QAAQ1C,QAAO,SAASA,MAAK;AAC5H,QAAI,YAAY;AACP,UAAA,QAAQ,IAAI,aAAa,cAAe;AAClC4C,aAAA,mBAAmB,IAAI,gBAAgB;AAAA,MAClD;AAAA,IACJ;AACO,WAAA,QAAQ,QAAQ,EAAE,QAAQ,CAAA,GAAI,OAAO,MAAM;AAAA,EACtD;AACA,WAAS,kBAAkB,MAAM;AACnB,cAAA,cAAc,OAAO,IAAI;AAAA,EACvC;AAIA,WAAS,kBAAkB,MAAM,OAAO,iBAAiB,OAAO;AAC5D,yBAAqB,MAAM,KAAK;AACtB,cAAA,YAAY,MAAM,KAAK;AAC7B,QAAA,kBAAkB,EAAE,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,gBAAgB;AACrF,gBAAU,sBAAsB,OAAO,MAAM,MAAM,KAAK,CAAC;AAAA,IAC7D;AAAA,EACJ;AACA,WAAS,qBAAqB,MAAM,OAAO,iBAAiB,OAAO;AAC/D,cAAU,cAAc,OAAO,MAAM,MAAM,KAAK,CAAC;AACjD,QAAI,gBAAgB;AAChB,gBAAU,sBAAsB,OAAO,MAAM,MAAM,KAAK,CAAC;AAAA,IAC7D;AAAA,EACJ;AACA,iBAAe,kBAAkB;AACvB,UAAA,cAAc,MAAM,MAAM;AAChC,QAAI,CAAC,aAAa;AACP,aAAA,EAAE,OAAO,MAAM,SAAS,CAAA,GAAI,QAAQ,CAAA;IAC/C;AACA,iBAAa,QAAQ;AACrB,UAAM,aAAa,eAAe,WAAW,KAAK,cAAc,WAAW,IACrE,MAAM,oBAAoB,aAAa,UAAU,IACjD,MAAM,qBAAqB,aAAa,YAAY;AAAA,MAClD,OAAO,WAAW;AAAA,MAClB,UAAU,cAAc;AAAA,IAAA,CAC3B;AACL,iBAAa,QAAQ;AACd,WAAA;AAAA,EACX;AACA,QAAM,aAAa,aAAa,CAAC,GAAG,EAAE,UAAU;AACxC,QAAA,kBAAkB,GAAG,GAAG;AACxB,UAAI,OAAO;IACf;AAAA,EAAA,CACH;AAoBG,MAAA,MAAM,MAAM,GAAG;AACf,UAAM,QAAQ,MAAM;AACZ5C,UAAAA;AACHA,OAAAA,MAAK,QAAQ,oBAAoB,QAAQA,QAAO,SAAS,SAASA,IAAG,KAAK,SAAS,gBAAgB;AAAA,IAAA,CACvG;AAAA,EACL;AAEA,UAAQ,gBAAgB,OAAO;AAC1B,MAAA,QAAQ,IAAI,aAAa,cAAe;AACzC,6BAAyB,OAAO;AAC1B,UAAA,MAAO,OAAO,OAAO,OAAO,OAAO,EAAE,QAAQ,SAAS,MAAA,GAAS,KAAK,KAAK,GAAG,EAAE,QAAQ,YAAY,cAAc,aAAa,OAAO,cAAc,aAAa,OAAO,aAAa,YAAY,MAAO,CAAA,GAAI,kBAAkB;AAAA,MAC9N,MAAM;AAAA,IAAA,CACT;AAAA,EACL;AACS,WAAA,YAAY,MAAM,QAAQ;AACzB,UAAA,QAAQ,WAAW,MAAM,IAAI,SAAY,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO;AAChG,UAAA,YAAa,cAAc,QAAQ,IAAI,CAAC,KAAK,gBAAgB,MAAM,EAAE,MAAA,CAAO;AAClF,UAAM,aAAa,MAAO,WAAW,MAAM,IAAI,OAAO,KAAK,WAAW,uBAAuB,CAAC,IAAI,UAAU,CAAA;AAC5G,aAAS,SAAS;AACVA,UAAAA;AACJ,gBAAU,UAAU;AACd,YAAA,kBAAkBA,MAAK,WAAA,EAAa,oBAAoB,QAAQA,QAAO,SAASA,MAAK,UAAA,EAAY;AACvG,UAAI,gBAAgB;AAChB,sBAAc,UAAU,IAAI;AAAA,MAChC;AAAA,IACJ;AACA,aAAS,UAAU;AACXA,UAAAA;AACE,YAAA,mBAAmBA,MAAK,WAAA,EAAa,qBAAqB,QAAQA,QAAO,SAASA,MAAK,UAAA,EAAY;AACzG,UAAI,iBAAiB;AACjB,iBAAS,MAAM;AACX,wBAAc,UAAU,IAAI;AAAA,QAAA,CAC/B;AAAA,MACL;AAAA,IACJ;AACA,aAAS,WAAW;AACZA,UAAAA;AACE,YAAA,oBAAoBA,MAAK,WAAA,EAAa,sBAAsB,QAAQA,QAAO,SAASA,MAAK,UAAA,EAAY;AAC3G,UAAI,kBAAkB;AAClB,iBAAS,MAAM;AACX,wBAAc,UAAU,IAAI;AAAA,QAAA,CAC/B;AAAA,MACL;AAAA,IACJ;AACM,UAAA,QAAQ,SAAS,MAAM;AACzB,YAAM,OAAO;AAAA,QACT;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAEA,UAAA,WAAW,MAAM,GAAG;AACpB,eAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,IAAI,GAAI,OAAO,KAAK,WAAW,uBAAuB,CAAC,EAAE,SAAS,CAAG,CAAA;AAAA,MAChH;AACA,UAAI,WAAW,QAAQ,WAAW,SAAS,SAAS,OAAO,OAAO;AAC9D,eAAO,OAAO,OAAO,OAAO,OAAO,CAAI,GAAA,IAAI,GAAG,OAAO,MAAM,KAAK,WAAW,uBAAuB,CAAC,CAAC;AAAA,MACxG;AACO,aAAA;AAAA,IAAA,CACV;AACK,UAAA,QAAQ,YAAY,MAAM,MAAM;AAAE,UAAIA,KAAI,IAAI;AAAY,cAAA,MAAMA,MAAK,WAAW,EAAE,2BAA2B,QAAQA,QAAO,SAASA,OAAM,KAAK,iBAAiB,QAAQ,OAAO,SAAS,SAAS,GAAG,2BAA2B,QAAQ,OAAO,SAAS,KAAK;AAAA,IAAA,CAAO;AACnQ,WAAA,CAAC,OAAO,KAAK;AAAA,EACxB;AACA,WAAS,cAAc,aAAa;AAChC,QAAI,CAAC,MAAM,QAAQ,WAAW,GAAG;AAC7B,aAAO,YAAY,WAAW;AAAA,IAClC;AACA,WAAO,YAAY,IAAI,CAAA,MAAK,YAAY,GAAG,IAAI,CAAC;AAAA,EACpD;AAIS,WAAA,iBAAiB,MAAM,QAAQ;AACpC,UAAM,CAAC,OAAO,KAAK,IAAI,YAAY,MAAM,MAAM;AAC/C,aAAS,SAAS;AACd,YAAM,MAAM;IAChB;AACA,aAAS,QAAQ,GAAG;AACV,YAAA,QAAQ,oBAAoB,CAAC;AACnC,oBAAc,QAAQ,IAAI,GAAG,OAAO,KAAK;AACzC,YAAM,MAAM;IAChB;AACA,aAAS,SAAS,GAAG;AACX,YAAA,QAAQ,oBAAoB,CAAC;AACnC,oBAAc,QAAQ,IAAI,GAAG,OAAO,KAAK;AACzC,YAAM,MAAM;IAChB;AACA,WAAO,SAAS,MAAM;AACX,aAAA,OAAO,OAAO,OAAO,OAAO,IAAI,MAAM,KAAK,GAAG;AAAA,QAAE;AAAA,QACnD;AAAA,QACA;AAAA,QAAU,OAAO,MAAM;AAAA,MAAA,CAAO;AAAA,IAAA,CACrC;AAAA,EACL;AAIS,WAAA,qBAAqB,MAAM,QAAQ;AACxC,UAAM,CAAC,OAAO,KAAK,IAAI,YAAY,MAAM,MAAM;AAC/C,UAAM,YAAY,cAAc,QAAQ,IAAI,CAAC;AAC7C,aAAS,mBAAmB,OAAO;AAC/B,YAAM,QAAQ;AAAA,IAClB;AACA,WAAO,SAAS,MAAM;AACZ,YAAA,OAAO,WAAW,MAAM,IAAI,OAAO,KAAK,WAAW,uBAAuB,CAAC,IAAI,UAAU,CAAA;AACxF,aAAA,OAAO,OAAO,EAAE,CAAC,KAAK,SAAS,YAAY,GAAG,MAAM,OAAO,CAAC,YAAY,KAAK,SAAS,YAAY,EAAE,GAAG,sBAAsB,MAAM,KAAK;AAAA,IAAA,CAClJ;AAAA,EACL;AACA,SAAO,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,OAAO,GAAG,EAAE,QAAQ,SAAS,UAAU,GAAG,aAAa,MAAM,UAAU,GAAG,YAAY;AACjI;AAIA,SAAS,YAAY,YAAY,eAAe,eAAe,QAAQ;AACnE,QAAM,mBAAmB;AAAA,IACrB,SAAS;AAAA,IACT,SAAS;AAAA,IACT,OAAO;AAAA,EAAA;AAEL,QAAA,UAAU,SAAS,MAAM;AAC3B,WAAO,CAAC,QAAQ,eAAe,MAAM,aAAa,CAAC;AAAA,EAAA,CACtD;AACD,WAAS,iBAAiB;AACtB,UAAM,SAAS,WAAW;AAC1B,WAAO,OAAO,gBAAgB,EAAE,OAAO,CAAC,KAAK,SAAS;AAC5C,YAAA,cAAc,iBAAiB,IAAI;AACrC,UAAA,IAAI,IAAI,OAAO,WAAW,EAAE,CAAK,MAAA,EAAE,IAAI,CAAC;AACrC,aAAA;AAAA,IACX,GAAG,CAAE,CAAA;AAAA,EACT;AACM,QAAA,QAAQ,SAAS,eAAA,CAAgB;AACvC,cAAY,MAAM;AACd,UAAM,QAAQ;AACd,UAAM,UAAU,MAAM;AACtB,UAAM,QAAQ,MAAM;AACpB,UAAM,UAAU,MAAM;AAAA,EAAA,CACzB;AACD,SAAO,SAAS,MAAM;AACX,WAAA,OAAO,OAAO,OAAO,OAAO,EAAE,eAAe,MAAM,aAAa,KAAK,KAAK,GAAG,EAAE,OAAO,MAAM,SAAS,CAAC,OAAO,OAAO,KAAK,EAAE,QAAQ,OAAO,QAAQ,MAAO,CAAA;AAAA,EAAA,CACnK;AACL;AAIA,SAAS,qBAAqB,YAAY,YAAY,MAAM;AAClD,QAAA,SAAS,qBAAqB,IAAI;AAElC,QAAA,gBAAgB,IAAI,MAAM;AAMhC,QAAM,wBAAwB,IAAI,MAAM,MAAM,CAAC;AACtC,WAAA,iBAAiB6C,SAAQ,eAAe,OAAO;AACtC,kBAAA,QAAQ,MAAM,MAAM,cAAc,KAAK,KAAK,IAAI,MAAMA,OAAM,CAAC;AACrD,0BAAA,QAAQ,MAAM,MAAM,sBAAsB,KAAK,KAAK,IAAI,MAAMA,OAAM,CAAC;AAC3F,QAAI,CAAC,cAAc;AACf;AAAA,IACJ;AAKW,eAAA,MAAM,QAAQ,CAAS,UAAA;AAC9B,YAAM,aAAa,MAAM;AACzB,UAAI,YAAY;AACZ;AAAA,MACJ;AACA,YAAM,WAAW,YAAY,cAAc,OAAO,MAAM,IAAI;AAC5D,gBAAU,YAAY,MAAM,MAAM,MAAM,QAAQ,CAAC;AAAA,IAAA,CACpD;AAAA,EACL;AACO,SAAA;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EAAA;AAER;AACA,SAAS,uBAAuB,GAAG,GAAG;AAClC,MAAI,CAAC,GAAG;AACG,WAAA;AAAA,EACX;AACO,SAAA;AAAA,IACH,OAAO,EAAE,SAAS,EAAE;AAAA,IACpB,QAAQ,CAAC,GAAG,EAAE,QAAQ,GAAG,EAAE,MAAM;AAAA,EAAA;AAEzC;AAEA,MAAM,WAA4C,gCAAA;AAAA,EAC9C,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACH,IAAI;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,kBAAkB;AAAA,MACd,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,eAAe;AAAA,MACX,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,eAAe;AAAA,MACX,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,gBAAgB;AAAA,MACZ,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,iBAAiB;AAAA,MACb,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,UAAU;AAAA,MACN,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,iBAAiB;AAAA,MACb,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,YAAY;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,EACJ;AAAA,EACA,MAAM,OAAO,KAAK;AACR,UAAA,mBAAmB,MAAM,OAAO,kBAAkB;AAClD,UAAA,aAAa,MAAM,OAAO,YAAY;AACtC,UAAA,EAAE,QAAQ,UAAU,QAAQ,MAAM,cAAc,cAAc,aAAa,kBAAkB,UAAAlB,WAAU,eAAe,aAAa,WAAW,cAAc,WAAW,eAAe,eAAe,WAAW,iBAAiB,YAAY,WAAY,IAAI,QAAQ;AAAA,MACvQ,kBAAkB,iBAAiB,QAAQ,mBAAmB;AAAA,MAC9D,eAAe,MAAM;AAAA,MACrB,eAAe,MAAM;AAAA,MACrB,gBAAgB,MAAM;AAAA,MACtB,iBAAiB,MAAM;AAAA,MACvB,qBAAqB;AAAA,IAAA,CACxB;AACD,UAAM,aAAa,aAAa,CAAC,GAAG,EAAE,UAAU;AACxC,UAAA,kBAAkB,GAAG,GAAG;AACxB,YAAI,OAAO;MACf;AAAA,IAAA,GACD,MAAM,eAAe;AAClB,UAAA,WAAW,MAAM,WAAW,aAAa,MAAM,UAAU,MAAM,eAAe,IAAI;AACxF,aAAS,gBAAgB,GAAG;AACpB,UAAA,QAAQ,CAAC,GAAG;AAEZ,UAAE,eAAe;AAAA,MACrB;AACY;AACZ,UAAI,OAAO,IAAI,MAAM,YAAY,YAAY;AACzC,YAAI,MAAM;MACd;AAAA,IACJ;AACS,aAAA,uBAAuB,KAAKmB,WAAU;AAC3C,YAAM,YAAY,OAAO,QAAQ,cAAc,CAACA,YAAW,MAAMA;AACjE,aAAO,aAAa,WAAW,MAAM,eAAe,EAAE,GAAG;AAAA,IAC7D;AACA,aAAS,YAAY;AACjB,aAAO,MAAM,MAAM;AAAA,IACvB;AACA,aAAS,UAAU;AACR,aAAA,MAAM,KAAK,KAAK;AAAA,IAC3B;AACA,aAAS,YAAY;AACV,aAAA,MAAM,OAAO,KAAK;AAAA,IAC7B;AACA,aAAS,YAAY;AACV,aAAA;AAAA,QACH,MAAM,KAAK;AAAA,QACX,QAAQ,OAAO;AAAA,QACf,UAAU,SAAS;AAAA,QACnB;AAAA,QACA,cAAc,aAAa;AAAA,QAC3B,cAAc,aAAa;AAAA,QAC3B,aAAa,YAAY;AAAA,QACzB,kBAAkB,iBAAiB;AAAA,QACnC,UAAAnB;AAAAA,QACA;AAAA,QACA,cAAc;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MAAA;AAAA,IAER;AAEA,QAAI,OAAO;AAAA,MACP;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAAA;AAAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACH;AACD,WAAO,SAAS,aAAa;AAEzB,YAAM,MAAM,MAAM,OAAO,SAAS,MAAM,KAAK,CAAC,MAAM,KAAK,OAAO,wBAAwB,MAAM,EAAE;AAChG,YAAM,WAAW,kBAAkB,KAAK,KAAK,SAAS;AACtD,UAAI,CAAC,KAAK;AACC,eAAA;AAAA,MACX;AAEM,YAAA,YAAY,QAAQ,SACpB;AAAA;AAAA,QAEE,YAAY;AAAA,UAEd;AACC,aAAA,EAAE,KAAK,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,CAAC,GAAG,SAAS,GAAG,IAAI,KAAK,GAAG,EAAE,UAAU,SAAS,gBAAA,CAAiB,GAAG,QAAQ;AAAA,IAAA;AAAA,EAE7I;AACJ,CAAC;AACD,MAAM,OAAO;AAoRb,MAAM,mBAAoD,gCAAA;AAAA,EACtD,MAAM;AAAA,EACN,OAAO;AAAA,IACH,IAAI;AAAA,MACA,MAAM;AAAA,MACN,SAAS;AAAA,IACb;AAAA,IACA,MAAM;AAAA,MACF,MAAM;AAAA,MACN,UAAU;AAAA,IACd;AAAA,EACJ;AAAA,EACA,MAAM,OAAO,KAAK;AACR,UAAA,OAAO,OAAO,gBAAgB,MAAS;AACvC,UAAA,UAAU,SAAS,MAAM;AACpB,aAAA,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,OAAO,MAAM,MAAM,IAAI;AAAA,IAAA,CAClF;AACD,aAAS,YAAY;AACV,aAAA;AAAA,QACH,SAAS,QAAQ;AAAA,MAAA;AAAA,IAEzB;AACA,WAAO,MAAM;AAEL,UAAA,CAAC,QAAQ,OAAO;AACT,eAAA;AAAA,MACX;AACA,YAAM,MAAO,MAAM,KAAK,wBAAwB,MAAM,EAAE,IAAI,MAAM;AAClE,YAAM,WAAW,kBAAkB,KAAK,KAAK,SAAS;AAChD,YAAA,QAAQ,OAAO,OAAO,EAAE,MAAM,QAAQ,GAAG,IAAI,KAAK;AAGxD,UAAI,CAAC,QAAQ,MAAM,QAAQ,QAAQ,KAAK,CAAC,cAAc,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,SAAS;AAClH,eAAA;AAAA,MACX;AAGA,WAAK,MAAM,QAAQ,QAAQ,KAAK,CAAC,aAAa,EAAE,aAAa,QAAQ,aAAa,SAAS,SAAS,SAAS,SAAS;AAClH,eAAO,EAAE,OAAO,QAAQ,OAAO,QAAQ,KAAK;AAAA,MAChD;AACO,aAAA,EAAE,KAAK,OAAO,QAAQ;AAAA,IAAA;AAAA,EAErC;AACJ,CAAC;AACD,MAAM,eAAe;ACj6GrB;AAAA;AAAA;AAAA;AAAA;AAoHA,SAAS,eAAe,QAAQ,WAAW;AAChC,SAAA,MAAM,QAAQ,MAAM,IAAI,OAAO,CAAC,IAAI,OAAO,SAAS;AAC/D;AACA,SAAS,QAAQ,OAAO;AACpB,MAAI,UAAU,QAAQ,UAAU,UAAa,UAAU,IAAI;AAChD,WAAA;AAAA,EACX;AACA,MAAI,MAAM,QAAQ,KAAK,KAAK,MAAM,WAAW,GAAG;AACrC,WAAA;AAAA,EACX;AACO,SAAA;AACX;AAgQA,MAAM,eAAe,CAAC,OAAO,WAAW;AAChC,MAAA,QAAQ,KAAK,GAAG;AACT,WAAA;AAAA,EACX;AACM,QAAA,SAAS,eAAe,QAAQ,QAAQ;AAC1C,MAAA,MAAM,QAAQ,KAAK,GAAG;AACf,WAAA,MAAM,MAAM,CAAO,QAAA,aAAa,KAAK,EAAE,OAAQ,CAAA,CAAC;AAAA,EAC3D;AACO,SAAA,CAAC,GAAG,OAAO,KAAK,CAAC,EAAE,UAAU,OAAO,MAAM;AACrD;AA+DA,SAAS,kBAAkB,OAAO;AACvB,SAAA,UAAU,QAAQ,UAAU;AACvC;AACA,SAAS,aAAa,KAAK;AACvB,SAAO,MAAM,QAAQ,GAAG,KAAK,IAAI,WAAW;AAChD;AAGA,MAAM,oBAAoB,CAAC,UAAU;AACjC,MAAI,kBAAkB,KAAK,KAAK,aAAa,KAAK,KAAK,UAAU,OAAO;AAC7D,WAAA;AAAA,EACX;AACA,SAAO,CAAC,CAAC,OAAO,KAAK,EAAE,OAAO;AAClC;ACjdA,MAAe,0BAAA,iCAAiB,MAAM;AACxB,YAAA;AAAA,IACN,iBAAiB,CAAC,QAAa;AAC3B,YAAM,WAAgB;AAAA,QAClB,UAAU;AAAA,QACV,KAAK,UAAU,IAAI,KAAK,oBAAoB,IAAI,KAAK,OAAO,CAAC,CAAC;AAAA,QAC9D,SAAS,UAAU,IAAI,KAAK;AAAA,MAAA;AAGzB,aAAA,SAAS,IAAI,KAAK,IAAI;AAAA,IACjC;AAAA,EAAA,CACH;AACD,aAAW,YAAYoB,iBAAQ;AAC/B,aAAW,OAAOC,YAAG;AACV,aAAA,SAAS,CAAC,UAAkB;AACnC,QAAI,CAAC,SAAS,CAAC,MAAM,QAAQ;AAClB,aAAA;AAAA,IACX;AACA,QAAI,CAAC,wJAAwJ,KAAK,KAAK,GACrK;AACS,aAAA;AAAA,IACX;AACO,WAAA;AAAA,EAAA,CACV;AACD,aAAW,aAAa,CAAC,OAAe,CAAC,QAAQ,CAAC,MAAM;AAEpD,QAAI,CAAC,SAAS,CAAC,MAAM,QAAQ;AAClB,aAAA;AAAA,IACX;AACI,QAAA,MAAM,SAAS,OAAO;AACtB,aAAO,+BAA+B,KAAK;AAAA,IAC/C;AACO,WAAA;AAAA,EAAA,CACV;AACU,aAAA,YAAY,CAAC,UAAkB;AAEtC,UAAM,UAAU;AACT,WAAA,QAAQ,KAAK,KAAK,KAAK;AAAA,EAAA,CACjC;AACU,aAAA,SAAS,CAAC,UAAkB;AAEnC,UAAM,UAAU;AACT,WAAA,QAAQ,KAAK,KAAK,KAAK;AAAA,EAAA,CACjC;AACU,aAAA,kBAAkB,CAAC,UAAkB;AAE5C,UAAM,UAAU;AACT,WAAA,QAAQ,KAAK,KAAK,KAAK;AAAA,EAAA,CACjC;AAEU,aAAA,SAAS,CAAC,UAAkB;AAC7B,UAAA,SAAS,WAAW,KAAK;AAC/B,QAAI,MAAM,MAAM,KAAK,SAAS,MAAM;AACzB,aAAA;AAAA,IACX;AACI,QAAA,SAAS,KAAK,SAAS,GAAG;AACnB,aAAA;AAAA,IACX;AACO,WAAA;AAAA,EAAA,CACV;AACU,aAAA,iBAAiB,CAAC,UAAkB;AAErC,UAAA,SAAS,SAAS,OAAO,EAAE;AAGjC,QAAI,MAAM,MAAM,KAAK,SAAS,GAAG;AACtB,aAAA;AAAA,IACX;AACO,WAAA;AAAA,EAAA,CACV;AACU,aAAA,QAAQ,CAAC,UAAkB;AAC5B,UAAA,SAAS,SAAS,OAAO,EAAE;AAE7B,QAAA,MAAM,MAAM,KAAK,SAAS,KAAK,MAAM,SAAS,GAAG,GAAG;AAC7C,aAAA;AAAA,IACX;AACO,WAAA;AAAA,EAAA,CACV;AACU,aAAA,YAAY,CAAC,UAAkB;AAChC,UAAA,SAAS,WAAW,KAAK;AAE/B,QAAI,MAAM,MAAM,KAAK,SAAS,KAAK,SAAS,KAAK;AACtC,aAAA;AAAA,IACX;AACO,WAAA;AAAA,EAAA,CACV;AAED,aAAW,2BAA2B,CAAC,OAAe,CAAC,SAAS,MAAW;AACnE,QAAA,CAAC,SAAS,CAAC;AAAkB,aAAA;AAC3B,UAAA,QAAQ,IAAI,KAAK,SAAS;AAC1B,UAAA,MAAM,IAAI,KAAK,KAAK;AAC1B,WAAO,MAAM,SAAS;AAAA,EAAA,CACzB;AACD,aAAW,kBAAkB,CAAC,OAAe,CAAC,SAAS,MAAgB;AAEnE,QAAI,QAAQ,WAAW;AACZ,aAAA;AAAA,IACX;AACO,WAAA;AAAA,EAAA,CACV;AAML,CAAC;ACjGD,MAAe,UAAA;AAAA,EACb;AAAA,EACAC;AAAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;ACvBA,MAAe,UAAA;AAAA,EACb,SAAS,MAAM,OAAO,6BAAmD,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC;AACrG;ACMA,MAAM,eAAe,gBAAgB;AAAA,EACnC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACd;AAAA,EACD,MAAM,MAAM,OAAO,SAAS;AAC1B,UAAM,kBAAkB,MAAM,QAAQ,MAAM,IAAI,EAAC,EAAG,KAAK,CAAC,MAAM,EAAE,WAAW,CAAC;AAC9E,WAAO,MAAM,EAAE,iBAAiB,MAAM,aAAa,QAAQ,KAAK;AAAA,EACjE;AACH,CAAC;AACD,MAAA,qBAAe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,MACJ,MAAM,CAAC,QAAQ,SAAS,MAAM;AAAA,MAC9B,SAAS;AAAA,IACV;AAAA,IACD,UAAU;AAAA,MACR,MAAM,CAAC,QAAQ,MAAM;AAAA,MACrB,SAAS;AAAA,IACV;AAAA,EACF;AAAA,EACD,MAAM,OAAO,SAAS;AACpB,UAAM,UAAU;AAChB,UAAM,gBAAgB,OAAO,eAAe;AAC5C,UAAM,QAAQ,kBAAkB,SAAU,IAAGC,WAAiB,IAAK;AACnE,UAAM,SAAS,SAAS,MAAM;AAC5B,UAAI,UAAU,MAAM,MAAM,IAAI,KAAK,MAAM,KAAK,UAAU;AACxD,UAAI,WAAW,EAAE,WAAW,UAAU;AAIpC,YAAI,MAAM,UAAU;AAClB,oBAAU,MAAM,MAAM,QAAQ;AAAA,QAC/B;AAAA,MACF;AACD,aAAO;AAAA,IACb,CAAK;AACD,UAAM,YAAY;AAClB,YAAQ,OAAO,EAAE,UAAS,CAAE;AAC5B,UAAM,OAAO,QAAQ;AAQrB,WAAO,MAAM;AACX,YAAM,YAAY,OAAO,SAAS,OAAO,SAAS;AAClD,YAAM,kBAAkB,MAAM,KAAK,oBAAoBC;AACvD,aAAO,QAAQ,YAAY,aAAa,iBAAiB;AAAA,QACvD,SAAS,MAAM,EAAE,UAAU,EAAE,aAAa,MAAM,WAAW,MAAM;AAC/D,mBAAS,IAAI;AAAA,QACvB,KAAa;AAAA,UACH,SAAS,MAAM;AAAA,YACb;AAAA,YACA;AAAA,cACE,aAAa,WAAW,QAAQ,OAAO,EAAE,KAAK,WAAW;AAAA,cACzD,KAAK,OAAO,SAAS;AAAA,cACrB,MAAM,OAAO;AAAA,cACb,eAAe,CAAC,MAAM;AAAA,cACtB,eAAe,CAAC,CAAC;AAAA,YAClB;AAAA,YACD,QAAQ;AAAA,UACT;AAAA,QACX,CAAS;AAAA,MACT,CAAO,EAAE,QAAO;AAAA,IAChB;AAAA,EACG;AACH,CAAC;AACD,MAAM,iBAAiB,gBAAgB;AAAA,EACrC,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,MACJ,MAAM,CAAC,QAAQ,OAAO;AAAA,IACvB;AAAA,IACD,aAAa;AAAA,MACX,MAAM;AAAA,IACP;AAAA,IACD,eAAe;AAAA,MACb,MAAM;AAAA,IACP;AAAA,IACD,eAAe;AAAA,MACb,MAAM;AAAA,IACP;AAAA,EACF;AAAA,EACD,MAAM,OAAO,SAAS;AACpB,UAAM,OAAO,MAAM;AACnB,QAAI,MAAM,eAAe;AACvB,cAAQ,kBAAkB;AAAA,QACxB,WAAW,CAAC,UAAU,UAAU,MAAM,KAAK,UAAU;AAAA,MAC7D,CAAO;AAAA,IACF;AAeD,WAAO,MAAM;;AACX,UAAI,CAAC,QAAQ,OAAO,SAAS,YAAY,EAAE,QAAQ,UAAU;AAK3D,gBAAO,mBAAQ,OAAM,YAAd;AAAA,MACR;AASD,aAAO;AAAA,QACL;AAAA,QACA,EAAE,KAAK,MAAM,aAAa,MAAM,aAAa,KAAM;AAAA,QACnD,QAAQ;AAAA,MAChB;AAAA,IACA;AAAA,EACG;AACH,CAAC;AC7IM,MAAM,gBAAgB,gBAAgB;AAAA,EAC3C,OAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,IACX;AAAA,IACD,OAAO;AAAA,MACL,MAAM;AAAA,MACN,UAAU;AAAA,IACX;AAAA,IACD,UAAU;AAAA,IACV,WAAW;AAAA,IACX,gBAAgB;AAAA,EACjB;AAAA,EACD,MAAM,OAAO;AACX,UAAM,cAAc,MAAM;AAC1B,UAAM,gBAAgB,MAAM;AAC5B,UAAM,QAAQ,CAAA;AACd,eAAW,OAAO,MAAM,OAAO;AAC7B,aAAO,eAAe,OAAO,KAAK;AAAA,QAChC,KAAK,MAAM,gBAAgB,MAAM,YAAY,MAAM,MAAM,GAAG,IAAI,cAAc,GAAG;AAAA,MACzF,CAAO;AAAA,IACF;AACD,YAAQ,iBAAiB,gBAAgB,KAAK,CAAC;AAY/C,WAAO,MAAM;AAKX,aAAO,EAAE,MAAM,OAAO,EAAE,KAAK,MAAM,SAAQ,CAAE;AAAA,IACnD;AAAA,EACG;AACH,CAAC;ACnCD,MAAA,qBAAe,gBAAgB;AAAA,EAC7B,MAAM;AAAA,EACN,cAAc;AAAA,EACd,OAAO;AAAA,IACL,MAAM;AAAA,MACJ,MAAM;AAAA,IACP;AAAA,IACD,YAAY;AAAA,MACV,MAAM,CAAC,SAAS,MAAM;AAAA,MACtB,SAAS;AAAA,IACV;AAAA,IACD,WAAW;AAAA,MACT,MAAM,CAAC,SAAS,MAAM;AAAA,MACtB,SAAS;AAAA,IACV;AAAA,IACD,OAAO;AAAA,MACL,MAAM;AAAA,IACP;AAAA,IACD,SAAS;AAAA,MACP,MAAM,CAAC,UAAU,MAAM;AAAA,MACvB,SAAS;AAAA,IACV;AAAA,EACF;AAAA,EACD,MAAM,OAAO,EAAE,OAAO,OAAM,GAAI;AAC9B,UAAM,UAAU;AAChB,UAAM,UAAU;AAChB,UAAM,YAAY,OAAO,iBAAiB,IAAI;AAC9C,QAAI;AACJ,WAAO,EAAE,QAAO,CAAE;AACE,WAAO,kBAAkB,IAAI;AACjD,QAAI;AACJ,UAAM,OAAO,QAAQ;AAKrB,QAAI,MAAM,SAAS;AACjB,YAAM,MAAM,MAAM,SAAS,CAAC,MAAM,SAAS;AACzC,YAAI,SAAS,MAAM;AACjB,kBAAQ,SAAS,oBAAoB;AAAA,QACtC;AAAA,MACT,CAAO;AAAA,IACF;AAID,WAAO,MAAM;AACX,aAAO,EAAE,YAAY,EAAE,MAAM,MAAM,MAAM,OAAO,MAAM,OAAO,GAAG,MAAK,GAAI;AAAA,QACvE,SAAS,CAAC,eAAe;AAGvB,cAAI,CAAC,WAAW,WAAW;AAIzB;AACA;AAAA,UACD;AAUD,gBAAM,MAAM9C,mBAAiB,YAAY,MAAM,OAAO;AACtD,cAAI,CAAC,QAAQ,eAAe,CAAC,kBAAkB,WAAW,WAAW,OAAO,WAAW,SAAS,KAAK,oBAAoB,KAAK;AAC5H,oBAAQ,SAAS,kBAAkB;AAAA,UACpC;AACD,4BAAkB;AAClB,gBAAM,gBAAgB,CAAC,EAAE,MAAM,cAAc,WAAW,MAAM,KAAK,kBAAkBoB;AACrF,gBAAM,kBAAkB,iBAAiB,sBAAsB;AAAA,YAC7D,MAAM;AAAA,YACN,WAAW,MAAM,KAAK;AAAA,YACtBA;AAAAA,YACA,EAAE,cAAc,MAAM;AACpB,sBAAQ,SAAS,0BAA0B,WAAW,SAAS;AAAA,YAC7E,EAAe;AAAA,UACf,EAAY,OAAO,OAAO,CAAC;AACjB,gBAAM,kBAAkB,MAAM,aAAa,WAAW,MAAM,KAAK,aAAa2B;AAC9E,kBAAQ;AAAA,YACN;AAAA,YACA,iBAAiB;AAAA,YACjB;AAAA,cACE;AAAA,cACA,EAAE,UAAU;AAAA,gBACV,aAAa;AAAA,gBACb,WAAW,MAAM,QAAQ,SAAS,cAAc,WAAW,SAAS;AAAA,gBACpE,WAAW,MAAM;AACf,2BAAS,MAAM,QAAQ,SAAS,eAAe,WAAW,SAAS,EAAE,KAAK,MAAM,QAAQ,SAAS,kBAAkB,CAAC,EAAE,QAAQ,IAAI,CAAC;AAAA,gBACpI;AAAA,cACjB,GAAiB;AAAA,gBACD,SAAS,MAAM;AACb,wBAAM,gBAAgB,EAAE,eAAe;AAAA,oBACrC,KAAK,OAAO;AAAA,oBACZ,OAAO,WAAW;AAAA,oBAClB,OAAO,WAAW;AAAA,oBAClB,WAAW,OAAO;AAAA,oBAClB,gBAAgB;AAAA,oBAChB,UAAU;AAAA,kBAC9B,CAAmB;AAID,yBAAO;AAAA,gBACR;AAAA,cACjB,CAAe;AAAA,YACF;AAAA,UACF,EAAC,QAAO;AACT,iBAAO;AAAA,QACR;AAAA,MACT,CAAO;AAAA,IACP;AAAA,EACG;AACH,CAAC;AACD,SAAS,sBAAsB,YAAY;AACzC,QAAM,SAAS,WAAW,IAAI,CAAC,UAAU;AAAA,IACvC,GAAG;AAAA,IACH,cAAc,KAAK,eAAe9C,UAAQ,KAAK,YAAY,IAAI;AAAA,EAChE,EAAC;AACF,SAAO,KAAK,GAAG,MAAM;AACvB;AAaA,SAAS,kBAAkB,MAAM,UAAU,WAAW;AACpD,MAAI,CAAC,MAAM;AACT,WAAO;AAAA,EACR;AACD,QAAM,QAAQ,SAAS,QAAQ,UAAU,CAAC;;AAAM,oBAAE,eAAF,mBAAc,cAAY,uCAAW;AAAA,GAAI;AACzF,SAAO,QAAQ,SAAS,QAAQ,SAAS;AAC3C;;;;;;;;;;;;ACxJA,QAAA,OAAA+C,eAAA,MAAA,CAAA,GAAA;AAAA,QAAAC,mBAIqB,uBAAA,MAAA;AAAA,IAJrB,SAAAC,QAAA,CAAA,GAAAC,QAAAC,UAAA,aAAA;UAAAD,QAAA;;;eAGwB;AAAA;;;KAHxB;AAAA;EAAA,GAAA,OAAA,CAAA;;;;;;;;;;;;;;;;;ACOA,UAAM,QAAQ;AAKd,UAAM,SAAS,MAAM;AAGF,WAAO,QACtB,OAAO,MACN,MAAM,IAAI,EACV,OAAO,CAAC,EACR,IAAI,CAAC,SAAS;AACb,YAAM,OAAO,KACV,QAAQ,aAAa,EAAE,EACvB,QAAQ,QAAQ,KAAK,EACrB,KAAM;AACT,aAAO;AAAA,QACL;AAAA,QACA,UAAW,KAAK,SAAS,cAAc,KAAK,CAAC,KAAK,SAAS,QAAQ,KACjE,KAAK,SAAS,UAAU,KACxB,KAAK,SAAS,aAAa;AAAA,MAC9B;AAAA,IACP,CAAK,EAAE,IAAI,OAAK,qBAAqB,EAAE,WAAW,cAAc,EAAE,KAAK,EAAE,IAAI,SAAS,EAAE,KAAK,IAAI,IAC7F;AAGJ,UAAM,aAAa,OAAO,OAAO,cAAc,GAAG;AAClD,UAAM,QAAQ,eAAe;AAE7B,UAAM,gBAAgB,OAAO,kBAAkB,QAAQ,mBAAmB;AAC1E,UAAM,cAAc,OAAO,WAAW,OAAO,SAAU;AACvD,UAAM,QAAuF;AAG7F,UAAM,YAAY,qBAAqB,MAAM,OAAO,+BAA4C,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC,CAAC;AAC3H,UAAM,SAEF,qBAAqB,MAAM,OAAO,+BAA4C,EAAE,KAAK,OAAK,EAAE,WAAW,CAAC,CAAC;AAE7G,UAAM,gBAAgB,QAAQ,YAAY;;;;;;;;;;;;;;;;;AClB1C,UAAM,iBAEF,MAAM;AAEV,UAAM,UAAU;AACE,YAAQ,eAAe;AAMR,YAAQ,WAAW;AACpD,UAAM,iBAAiB;AAIf,YAAA,iBAAiB,UAAU;AAGnB,YAAQ,MAAM,aAAa,CAAA,UAAS,MAAM,IAAI,CAAQ,SAAA,KAAM,CAAA,GAAG,WAAW;AAM1F,UAAM,QAAQ;AACE,oBAAA,CAAC,KAAK,QAAQ,SAAS;AACrC,cAAQ,MAAM,SAAS,aAAa,KAAK,QAAQ,IAAI,EAAE,MAAM,CAAa,cAAA,QAAQ,MAAM,oCAAoC,SAAS,CAAC;AACxD;AAC5E,cAAM,IAAI,QAAQ,eAAe,MAAM,UAAU,GAAG,CAAC;AACrD,yBAAiB,MAAM,CAAC;AACjB,eAAA;AAAA,MACT;AAAA,IAAA,CACD;AAGK,UAAA,gBAAsC,QAAQ,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;ACxD/D,IAAI;AACoB;AACd,UAAA,eAAe,oBAAoB,YAAY;AAC/C,UAAA,SAAS,UAAU,aAAa;AACtC,UAAM,OAAO,cAAc,EAAE,QAAQ,WAAY,CAAA;AAC7C,QAAA;AACI,YAAA,aAAa,MAAM,OAAO;AAChC,YAAM,KAAK,MAAM,SAAS,eAAe,MAAM;AAAA,aACxC,OAAO;AACd,YAAM,KAAK,MAAM,SAAS,aAAa,KAAK;AAC5C,WAAK,QAAQ,QAAQ,KAAK,QAAQ,SAAS,YAAY,KAAK;AAAA,IAC9D;AACA,QAAI,yCAAY,iBAAiB;AACzB,YAAA,IAAI,MAAM,iBAAiB;AAAA,IACnC;AACO,WAAA;AAAA,EAAA;AAEX;AA4CA,MAAA,UAAe,CAAC,eAAe,MAAM,UAAU;","x_google_ignoreList":[2,3,4,5,6,7,8,9,11,13,14,16,17,19,20,21,23,24,25,26,27,28,30,31,36,37,41,42,43,45,46,47]}